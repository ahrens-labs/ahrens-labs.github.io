z`<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dungeon Game - Ahrens Labs</title>
    
    <!-- Google Fonts Links -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Orbitron&family=Roboto+Mono&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="css/style.css">
    <link rel="icon" type="image/x-icon" href="/img/favicon.ico">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    
    <style>
        :root {
            --bg-primary: #020617;
            --bg-secondary: #0f172a;
            --bg-tertiary: #1e293b;
            --text-primary: #e2e8f0;
            --text-secondary: #94a3b8;
            --text-muted: #64748b;
            --border-color: #334155;
            --border-light: #475569;
            --bg-log: #0f172a;
            --text-log: #e2e8f0;
        }

        body.light-theme {
            --bg-primary: #f8fafc;
            --bg-secondary: #f1f5f9;
            --bg-tertiary: #e2e8f0;
            --text-primary: #1e293b;
            --text-secondary: #475569;
            --text-muted: #64748b;
            --border-color: #cbd5e1;
            --border-light: #e2e8f0;
            --bg-log: #f1f5f9;
            --text-log: #1e293b;
        }

        body { 
            font-family: 'JetBrains+Mono', monospace; 
            overflow-x: hidden;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            transition: background-color 0.3s, color 0.3s;
        }
        
        .custom-scrollbar::-webkit-scrollbar { width: 4px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: var(--bg-secondary); }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 10px; }
        .combat-active { animation: pulse-red 2s infinite; }
        @keyframes pulse-red { 0%, 100% { background-color: rgba(220, 38, 38, 0.05); } 50% { background-color: rgba(220, 38, 38, 0.15); } }
        .equipped { border-color: #fbbf24 !important; background-color: rgba(251, 191, 36, 0.1) !important; }
        
        /* Game wrapper styles */
        .game-wrapper {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            min-height: calc(100vh - 200px);
            padding: 2rem 1rem;
            transition: background-color 0.3s, color 0.3s;
        }

        /* Theme toggle button */
        #theme-toggle-btn {
            padding: 8px 16px;
            background: #6366f1;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9em;
            transition: all 0.3s;
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #theme-toggle-btn:hover {
            background: #4f46e5;
        }

        /* Combat menu boxes styling */
        #combat-main-menu button,
        #combat-direction-menu button,
        #combat-defense-menu button,
        #combat-items-menu button {
            border: 2px solid #334155 !important;
            transition: all 0.2s !important;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.5) !important;
        }
        
        #combat-main-menu button:hover,
        #combat-direction-menu button:hover,
        #combat-defense-menu button:hover,
        #combat-items-menu button:hover {
            border-color: #475569 !important;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.5), 0 0 8px rgba(255,255,255,0.1) !important;
            transform: translateY(-1px) !important;
        }
        
        #combat-main-menu button:active,
        #combat-direction-menu button:active,
        #combat-defense-menu button:active,
        #combat-items-menu button:active {
            transform: translateY(0) !important;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.8) !important;
        }

        /* Game UI Elements - Log Panel */
        #game-log {
            background-color: var(--bg-log) !important;
            color: var(--text-log) !important;
        }

        /* Board/Viewport */
        #viewport {
            background-color: var(--bg-secondary) !important;
            border-color: var(--border-color) !important;
        }

        /* Stats header boxes */
        .bg-slate-900 { 
            background-color: var(--bg-tertiary) !important;
            color: var(--text-primary) !important;
        }
        .bg-slate-800 { 
            background-color: var(--bg-secondary) !important;
            color: var(--text-primary) !important;
        }
        .border-slate-800 { border-color: var(--border-color) !important; }
        .text-slate-400, .text-slate-500 { color: var(--text-secondary) !important; }
        .text-slate-600 { color: var(--text-muted) !important; }
        .text-white { color: var(--text-primary) !important; }

        /* Buttons and interactive elements */
        .hover\:bg-slate-700:hover {
            background-color: var(--bg-secondary) !important;
        }

        /* Footer styling - match rest of site */
        footer {
            background-color: #2c3e50;
            color: #bbb;
            transition: background-color 0.3s, color 0.3s;
        }

        /* Header - match rest of site */
        header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 50%, #2c3e50 100%) !important;
        }

        header h1, header nav a, header nav ul li a {
            color: white !important;
        }
    </style>
</head>
<body>
    <script>
        // Initialize theme immediately to prevent flash
        (function() {
            const savedTheme = localStorage.getItem('dungeon-game-theme') || 'dark';
            if (savedTheme === 'light') {
                document.body.classList.add('light-theme');
            }
        })();
    </script>
    <div class="wrapper">
        <header>
            <div class="header-content">
                <a href="index.html" class="logo-link">
                    <img src="img/EagleLogo.png" alt="Ahrens Labs logo" class="header-logo">
                </a>
                <h1>Ahrens Labs</h1>
                <nav>
                    <ul>
                        <li><a href="index.html">Home</a></li>
                        <li><a href="labs.html">Labs & Projects</a></li>
                        <li><a href="contact.html">Contact</a></li>
                        <li><a href="chess_engine.html">Chess Engine</a></li>
                    </ul>
                </nav>
                <div id="header-auth-buttons" style="position: absolute; top: 10px; right: 10px; display: flex; gap: 8px; align-items: center; z-index: 1000;">
                    <button id="header-login-btn" onclick="window.location.href='account.html'" style="padding: 6px 14px; background: #3498db; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 0.85em; transition: all 0.3s; white-space: nowrap;">Login</button>
                    <button id="header-signup-btn" onclick="window.location.href='account.html'" style="padding: 6px 14px; background: #2ecc71; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 0.85em; transition: all 0.3s; white-space: nowrap;">Sign Up</button>
                    <button id="header-logout-btn" onclick="handleLogout()" style="display: none; padding: 6px 14px; background: #e74c3c; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 0.85em; transition: all 0.3s; white-space: nowrap;">Logout</button>
                    <span id="header-username" style="display: none; padding: 6px 14px; color: white; font-weight: 600; font-size: 0.9em; white-space: nowrap;"></span>
                </div>
            </div>
        </header>

        <main class="game-wrapper flex flex-col items-center">

    <!-- Header Stats -->
    <div id="stats-header" class="w-full max-w-6xl bg-gradient-to-r from-slate-900 via-slate-800 to-slate-900 border-2 border-purple-600 shadow-xl shadow-purple-500/20 p-6 rounded-lg mb-6 hidden">
        <div class="flex flex-col gap-4">
            <!-- Top Row: Level, EXP, Floor -->
            <div class="flex items-center justify-center gap-8 pb-4 border-b-2 border-purple-500/20">
                <div id="stat-level" class="text-2xl text-purple-400 font-black tracking-wide drop-shadow-lg">LVL 1</div>
                <div class="h-8 w-px bg-purple-500/30"></div>
                <div id="stat-exp" class="text-lg text-cyan-400 font-bold tracking-wide">EXP: 0/100</div>
                <div class="h-8 w-px bg-purple-500/30"></div>
                <div id="stat-floor" class="text-2xl text-blue-400 font-black tracking-wide drop-shadow-lg">FLOOR 1</div>
            </div>
            
            <!-- Bottom Row: All Stats in One Line -->
            <div class="flex items-center justify-center gap-6 flex-wrap">
                <!-- Primary Stats -->
                <div class="flex flex-col items-center gap-2 p-3 bg-slate-950/50 rounded-lg border border-red-500/30 w-[110px]">
                    <i class="fas fa-heart text-red-500 text-3xl drop-shadow-[0_0_8px_rgba(239,68,68,0.6)]"></i>
                    <div class="text-xs text-red-400 font-bold uppercase tracking-wider">HP</div>
                    <div id="stat-hp" class="text-white text-3xl font-black drop-shadow-lg">--/--</div>
                </div>
                <div class="flex flex-col items-center gap-2 p-3 bg-slate-950/50 rounded-lg border border-yellow-500/30 w-[110px]">
                    <i class="fas fa-coins text-yellow-500 text-3xl drop-shadow-[0_0_8px_rgba(234,179,8,0.6)]"></i>
                    <div class="text-xs text-yellow-400 font-bold uppercase tracking-wider">Gold</div>
                    <div id="stat-gold" class="text-white text-3xl font-black drop-shadow-lg">0</div>
                </div>
                <div class="flex flex-col items-center gap-2 p-3 bg-slate-950/50 rounded-lg border border-slate-400/30 w-[110px]">
                    <i class="fas fa-shield-alt text-slate-300 text-3xl drop-shadow-[0_0_8px_rgba(148,163,184,0.6)]"></i>
                    <div class="text-xs text-slate-300 font-bold uppercase tracking-wider">AC</div>
                    <div id="stat-armor" class="text-white text-3xl font-black drop-shadow-lg">--</div>
                </div>
                
                <!-- Divider -->
                <div class="h-20 w-px bg-purple-500/30"></div>
                
                <!-- Attributes -->
                <div class="flex flex-col items-center p-3 bg-slate-950/50 rounded-lg border border-slate-600/30 w-[110px]">
                    <div class="text-sm text-red-400 font-bold uppercase mb-2 tracking-wider">STR</div>
                    <div id="stat-str" class="text-white text-2xl font-black drop-shadow-lg">0</div>
                </div>
                <div class="flex flex-col items-center p-3 bg-slate-950/50 rounded-lg border border-slate-600/30 w-[110px]">
                    <div class="text-sm text-green-400 font-bold uppercase mb-2 tracking-wider">DEX</div>
                    <div id="stat-dex" class="text-white text-2xl font-black drop-shadow-lg">0</div>
                </div>
                <div class="flex flex-col items-center p-3 bg-slate-950/50 rounded-lg border border-slate-600/30 w-[110px]">
                    <div class="text-sm text-blue-400 font-bold uppercase mb-2 tracking-wider">INT</div>
                    <div id="stat-int" class="text-white text-2xl font-black drop-shadow-lg">0</div>
                </div>
                <div class="flex flex-col items-center p-3 bg-slate-950/50 rounded-lg border border-slate-600/30 w-[110px]">
                    <div class="text-sm text-purple-400 font-bold uppercase mb-2 tracking-wider">WIS</div>
                    <div id="stat-wis" class="text-white text-2xl font-black drop-shadow-lg">0</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Game Container -->
    <div class="w-full max-w-5xl grid grid-cols-1 lg:grid-cols-4 gap-4 flex-1">
        <!-- Log Panel -->
        <div class="lg:col-span-1 bg-black border border-slate-800 rounded flex flex-col h-[300px] lg:h-[600px] overflow-hidden">
            <div class="bg-slate-900 p-3 text-sm font-bold border-b border-slate-800 text-slate-500 flex justify-between items-center">
                <span>ADVENTURE LOG</span>
                <button id="theme-toggle-btn" onclick="toggleTheme()" title="Toggle Light/Dark Theme" style="padding: 4px 8px; background: #6366f1; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; font-size: 0.75em; transition: all 0.3s; display: flex; align-items: center; gap: 4px;">
                    <i class="fas fa-moon"></i>
                    <span id="theme-text" style="font-size: 0.9em;">Dark</span>
                </button>
            </div>
            <div id="game-log" class="flex-1 overflow-y-auto p-4 text-[13px] space-y-2 custom-scrollbar bg-slate-950/50"></div>
            <div id="combat-streak-indicator" class="hidden p-2 text-center bg-orange-900/30 border-t border-orange-700 text-orange-400 font-bold text-sm">
                üî• <span id="streak-count">0</span> Win Streak!
            </div>
            <div id="global-actions" class="p-3 border-t border-slate-800 bg-slate-900 hidden">
                <button onclick="toggleInventory()" class="w-full py-3 bg-slate-800 hover:bg-slate-700 text-sm font-bold rounded uppercase flex items-center justify-center gap-2">
                    <i class="fas fa-backpack text-base"></i> Inventory
                </button>
            </div>
        </div>

        <!-- Viewport -->
        <div id="viewport" class="lg:col-span-3 bg-slate-900 border border-slate-800 rounded p-6 relative flex flex-col items-center justify-center min-h-[500px] shadow-2xl transition-all duration-500">
            
            <div id="view-menu" class="text-center space-y-8">
                <h1 class="text-6xl font-black text-white italic tracking-tighter">DUNGEON<br>GAME</h1>
                <div class="flex flex-col gap-3">
                    <button onclick="initCharacterCreation()" class="bg-white text-black px-12 py-4 rounded font-bold text-lg hover:bg-yellow-400 transition-all shadow-xl">NEW GAME</button>
                    <button onclick="loadGame()" class="bg-slate-800 text-white px-12 py-4 rounded font-bold text-lg hover:bg-slate-700 transition-all shadow-xl border border-slate-700">LOAD GAME</button>
                </div>
            </div>

            <div id="view-creation" class="hidden w-full max-w-sm space-y-4">
                <div id="char-name-input" class="space-y-4">
                    <h2 class="text-lg font-bold text-center text-slate-400 uppercase tracking-widest">Create Your Character</h2>
                    <div class="space-y-2">
                        <label class="text-sm font-bold text-slate-400 uppercase">Character Name</label>
                        <input id="character-name" type="text" maxlength="20" placeholder="Enter name..." class="w-full p-4 bg-slate-800 border border-slate-700 rounded text-white text-base focus:border-blue-500 focus:outline-none">
                    </div>
                    <button onclick="confirmCharacterName()" class="w-full py-4 bg-blue-600 hover:bg-blue-700 rounded font-bold uppercase text-base">Continue</button>
                </div>
                <div id="attr-assignment" class="hidden space-y-4">
                    <h2 class="text-lg font-bold text-center text-slate-400 uppercase tracking-widest">Assign Attributes</h2>
                    <div id="rolls-container" class="flex justify-center gap-2"></div>
                    <div id="attr-selection" class="space-y-1"></div>
                </div>
            </div>

            <div id="view-town" class="hidden text-center space-y-6 w-full max-w-lg">
                <h2 class="text-4xl font-black text-white italic">OAKHAVEN</h2>
                <div class="bg-slate-800/50 border border-slate-700 p-4 rounded text-sm text-slate-300 font-mono">
                    <p class="mb-2">‚öîÔ∏è An ancient evil awakens...</p>
                    <p>The Goblin King sleeps deep within the cursed dungeons beneath Oakhaven. Only a true hero can venture through the 10 treacherous floors and defeat the darkness that threatens our world.</p>
                </div>
                <div class="grid grid-cols-2 gap-4">
                    <button onclick="showShop()" class="p-10 bg-slate-800 rounded hover:bg-slate-700 border border-slate-700 flex flex-col items-center gap-3">
                        <i class="fas fa-store text-4xl text-yellow-500"></i>
                        <span class="font-bold text-lg">SHOP</span>
                    </button>
                    <button onclick="enterDungeon()" class="p-10 bg-slate-800 rounded hover:bg-slate-700 border border-slate-700 flex flex-col items-center gap-3">
                        <i class="fas fa-dungeon text-4xl text-red-500"></i>
                        <span class="font-bold text-lg">DUNGEON</span>
                    </button>
                </div>
                <div class="flex gap-4 justify-center">
                    <button onclick="saveGame()" class="text-sm text-slate-500 hover:text-white underline font-bold">SAVE GAME</button>
                    <button onclick="showChangeNameModal()" class="text-sm text-slate-500 hover:text-white underline font-bold">CHANGE NAME</button>
                </div>
            </div>

            <div id="view-dungeon" class="hidden w-full flex flex-col items-center gap-6">
                <div id="mini-map" class="grid grid-cols-10 gap-2 bg-slate-950 p-6 rounded border-2 border-slate-800"></div>
                <div id="room-actions" class="flex flex-wrap justify-center gap-3 min-h-[40px]"></div>
                <div class="grid grid-cols-3 gap-2 w-48">
                    <div></div><button onclick="movePlayer(-1, 0)" class="h-14 w-14 bg-slate-800 rounded hover:bg-slate-700 flex items-center justify-center text-xl">&#9650;</button><div></div>
                    <button onclick="movePlayer(0, -1)" class="h-14 w-14 bg-slate-800 rounded hover:bg-slate-700 flex items-center justify-center text-xl">&#9664;</button>
                    <button onclick="movePlayer(1, 0)" class="h-14 w-14 bg-slate-800 rounded hover:bg-slate-700 flex items-center justify-center text-xl">&#9660;</button>
                    <button onclick="movePlayer(0, 1)" class="h-14 w-14 bg-slate-800 rounded hover:bg-slate-700 flex items-center justify-center text-xl">&#9654;</button>
                </div>
                <div class="flex gap-4">
                    <button id="btn-return-town" onclick="showView('view-town')" class="hidden text-sm text-slate-500 hover:text-white uppercase font-bold mt-4 flex items-center gap-2">
                        <i class="fas fa-door-open"></i> Return to Town
                    </button>
                    <button onclick="saveGame()" class="text-sm text-slate-500 hover:text-white uppercase font-bold mt-4 flex items-center gap-2">
                        <i class="fas fa-save"></i> Save
                    </button>
                </div>
            </div>

            <!-- COMBAT VIEW -->
            <div id="view-combat" class="hidden w-full flex flex-col items-center gap-6">
                <div class="text-center w-full">
                    <div id="monster-name" class="text-red-500 font-black text-3xl uppercase italic tracking-widest">MONSTER</div>
                    <div class="w-full max-w-sm mx-auto h-3 bg-slate-950 rounded mt-3 overflow-hidden border border-slate-800">
                        <div id="monster-hp-bar" class="h-full bg-red-600 transition-all duration-500" style="width: 100%"></div>
                    </div>
                    <div id="monster-stats-display" class="text-sm text-slate-500 mt-2"></div>
                </div>

                <div id="combat-main-menu" class="hidden grid grid-cols-1 gap-3 w-full max-w-xs">
                    <button onclick="showCombatSubMenu('attack')" class="p-4 bg-slate-800 hover:bg-slate-700 rounded font-bold text-base text-left px-6 flex justify-between items-center">
                        <span>ATTACK</span><i class="fas fa-sword text-slate-600 text-lg"></i>
                    </button>
                    <button onclick="showCombatSubMenu('items')" class="p-4 bg-slate-800 hover:bg-slate-700 rounded font-bold text-base text-left px-6 flex justify-between items-center">
                        <span>ITEMS</span><i class="fas fa-flask text-slate-600 text-lg"></i>
                    </button>
                    <button onclick="retreat()" class="p-4 bg-slate-900 border border-blue-900/40 text-blue-400 hover:bg-blue-950/20 rounded font-bold text-base text-left px-6 flex justify-between items-center">
                        <span>RETREAT (Roll)</span><i class="fas fa-person-running text-lg"></i>
                    </button>
                </div>

                <div id="combat-direction-menu" class="hidden grid grid-cols-3 gap-3 w-full max-w-md">
                    <div class="col-span-3 text-center text-sm font-bold text-yellow-500 mb-2 uppercase italic">Target Strike Area</div>
                    <button onclick="combatAction(1)" class="p-5 bg-slate-800 hover:bg-red-900/50 rounded flex flex-col items-center text-sm font-bold">HIGH</button>
                    <button onclick="combatAction(3)" class="p-5 bg-slate-800 hover:bg-red-900/50 rounded flex flex-col items-center text-sm font-bold">MID</button>
                    <button onclick="combatAction(2)" class="p-5 bg-slate-800 hover:bg-red-900/50 rounded flex flex-col items-center text-sm font-bold">LOW</button>
                    <button onclick="showCombatSubMenu('main')" class="col-span-3 text-sm text-slate-500 font-bold text-center mt-2">BACK</button>
                </div>

                <div id="combat-defense-menu" class="hidden grid grid-cols-3 gap-3 w-full max-w-md">
                    <div class="col-span-3 text-center text-sm font-bold text-blue-400 mb-2 uppercase italic">Guard Position!</div>
                    <button onclick="resolveMonsterTurn(1)" class="p-5 bg-blue-900/20 hover:bg-blue-800/40 rounded border border-blue-500/30 flex flex-col items-center text-sm font-bold">HIGH</button>
                    <button onclick="resolveMonsterTurn(3)" class="p-5 bg-blue-900/20 hover:bg-blue-800/40 rounded border border-blue-500/30 flex flex-col items-center text-sm font-bold">MID</button>
                    <button onclick="resolveMonsterTurn(2)" class="p-5 bg-blue-900/20 hover:bg-blue-800/40 rounded border border-blue-500/30 flex flex-col items-center text-sm font-bold">LOW</button>
                </div>

                <div id="combat-items-menu" class="hidden w-full max-w-xs space-y-2">
                    <div id="combat-inventory-list" class="space-y-2 max-h-48 overflow-y-auto custom-scrollbar"></div>
                    <button onclick="showCombatSubMenu('main')" class="w-full p-3 bg-slate-800 text-sm text-slate-500 rounded font-bold">BACK</button>
                </div>

                <div id="turn-indicator" class="text-sm font-black tracking-widest text-yellow-600 bg-black/40 px-6 py-2 rounded italic uppercase">...</div>
            </div>

            <!-- SHOP VIEW -->
            <div id="view-shop" class="hidden w-full h-full overflow-y-auto custom-scrollbar p-2">
                <div class="flex justify-between items-center mb-6 sticky top-0 bg-slate-900 py-3 border-b border-slate-800">
                    <h2 class="font-black text-2xl italic">TOWN MERCHANT</h2>
                    <div class="flex gap-2">
                        <button id="shop-mode-buy" onclick="setShopMode('buy')" class="text-sm bg-yellow-600 px-4 py-2 rounded font-bold">BUY</button>
                        <button id="shop-mode-sell" onclick="setShopMode('sell')" class="text-sm bg-slate-800 px-4 py-2 rounded font-bold">SELL</button>
                        <button onclick="showView('view-town')" class="text-sm bg-slate-800 px-4 py-2 rounded font-bold">EXIT</button>
                    </div>
                </div>
                <div id="shop-categories" class="space-y-6"></div>
            </div>

            <!-- INVENTORY VIEW -->
            <div id="view-inventory" class="hidden w-full h-full overflow-y-auto custom-scrollbar p-2">
                <div class="flex justify-between items-center mb-6 sticky top-0 bg-slate-900 py-3 border-b border-slate-800 z-10">
                    <h2 class="font-black text-2xl italic">INVENTORY</h2>
                    <div class="flex gap-2 items-center">
                        <div class="flex items-center gap-2 bg-slate-800 px-4 py-2 rounded border border-blue-500">
                            <i class="fas fa-key text-blue-400 text-lg"></i>
                            <span class="text-sm text-slate-400 font-bold">Keys:</span>
                            <span id="inv-keys-count" class="text-white text-base font-bold">0</span>
                        </div>
                        <button onclick="showView('view-achievements')" class="text-sm bg-blue-800 hover:bg-blue-700 px-4 py-2 rounded font-bold">ACHIEVEMENTS</button>
                        <button onclick="inventoryClose()" class="text-sm bg-slate-800 px-4 py-2 rounded font-bold">CLOSE</button>
                    </div>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div class="space-y-4">
                        <h3 class="text-sm font-bold text-slate-500 uppercase tracking-widest border-b border-slate-800 pb-2">Weapons</h3>
                        <div id="inv-weapons" class="space-y-2"></div>
                        <h3 class="text-sm font-bold text-slate-500 uppercase tracking-widest border-b border-slate-800 pb-2">Armor</h3>
                        <div id="inv-armors" class="space-y-2"></div>
                    </div>
                    <div class="space-y-4">
                        <h3 class="text-sm font-bold text-slate-500 uppercase tracking-widest border-b border-slate-800 pb-2">Consumables</h3>
                        <div id="inv-consumables" class="space-y-2"></div>
                        <h3 class="text-sm font-bold text-slate-500 uppercase tracking-widest border-b border-slate-800 pb-2">Tools</h3>
                        <div id="inv-tools" class="space-y-2"></div>
                    </div>
                </div>
            </div>

            <!-- ACHIEVEMENTS VIEW -->
            <div id="view-achievements" class="hidden w-full h-full overflow-y-auto custom-scrollbar p-4">
                <div class="flex justify-between items-center mb-6 sticky top-0 bg-slate-900 py-3 border-b border-slate-800 z-10">
                    <h2 class="font-black text-2xl italic">üèÜ ACHIEVEMENTS</h2>
                    <button onclick="showView('view-inventory')" class="text-sm bg-slate-800 px-4 py-2 rounded font-bold">BACK</button>
                </div>
                <div id="achievements-list" class="space-y-3 max-w-2xl"></div>
            </div>

        </div>
    </div>

    <script src="js/script.js"></script>
    <script>
        // ===============================================
        // THEME TOGGLE SYSTEM
        // ===============================================
        function initTheme() {
            const savedTheme = localStorage.getItem('dungeon-game-theme') || 'dark';
            applyTheme(savedTheme);
        }

        function applyTheme(theme) {
            const body = document.body;
            const themeBtn = document.getElementById('theme-toggle-btn');
            const themeText = document.getElementById('theme-text');
            const themeIcon = themeBtn.querySelector('i');

            if (theme === 'light') {
                body.classList.add('light-theme');
                themeText.textContent = 'Light';
                themeIcon.className = 'fas fa-sun';
            } else {
                body.classList.remove('light-theme');
                themeText.textContent = 'Dark';
                themeIcon.className = 'fas fa-moon';
            }
            
            localStorage.setItem('dungeon-game-theme', theme);
        }

        function toggleTheme() {
            const currentTheme = document.body.classList.contains('light-theme') ? 'light' : 'dark';
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            applyTheme(newTheme);
        }

        // Initialize theme on page load
        initTheme();
        // CLOUD SAVE SYSTEM
        // ===============================================
        const API_BASE_URL = 'https://chess-accounts.matthewahrens.workers.dev';
        let currentSaveSlot = null;
        let isLoggedIn = false;
        let sessionId = null;

        // Check authentication on page load
        async function checkAuth() {
            sessionId = localStorage.getItem('ahrenslabs_sessionId');
            if (!sessionId) {
                // Redirect to account page with return URL
                window.location.href = 'account.html?return=dungeon_game.html';
                return false;
            }

            // Verify session is valid
            try {
                const response = await fetch(`${API_BASE_URL}/api/user`, {
                    headers: {
                        'Authorization': `Bearer ${sessionId}`
                    }
                });
                
                if (!response.ok) {
                    window.location.href = 'account.html?return=dungeon_game.html';
                    return false;
                }
                
                isLoggedIn = true;
                return true;
            } catch (error) {
                console.error('Auth check failed:', error);
                window.location.href = 'account.html?return=dungeon_game.html';
                return false;
            }
        }

        // Save game to cloud slot
        async function saveToCloud(slotNumber, saveName) {
            if (!isLoggedIn || !sessionId) return false;

            const slot = `slot${slotNumber}`;
            
            // Determine current location (in town or in dungeon)
            const currentView = document.querySelector('#viewport > div:not(.hidden)')?.id;
            const inTown = currentView === 'view-town';
            
            const saveData = {
                stats: stats,
                map: floorMaps,
                monsters: monsterData,
                room: currentRoom,
                openedChests: Array.from(stats.openedChests),
                inTown: inTown
            };

            try {
                const response = await fetch(`${API_BASE_URL}/api/dungeon/save`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${sessionId}`
                    },
                    body: JSON.stringify({
                        slot: slot,
                        data: saveData,
                        name: saveName || stats.characterName || `Save ${slotNumber}`
                    })
                });

                const result = await response.json();
                if (result.success) {
                    currentSaveSlot = slotNumber;
                    return true;
                }
                return false;
            } catch (error) {
                console.error('Save to cloud failed:', error);
                return false;
            }
        }

        // Load game from cloud slot
        async function loadFromCloud(slotNumber) {
            if (!isLoggedIn || !sessionId) return null;

            const slot = `slot${slotNumber}`;

            try {
                const response = await fetch(`${API_BASE_URL}/api/dungeon/load`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${sessionId}`
                    },
                    body: JSON.stringify({ slot })
                });

                const result = await response.json();
                if (result && result.data) {
                    currentSaveSlot = slotNumber;
                    return result.data;
                }
                return null;
            } catch (error) {
                console.error('Load from cloud failed:', error);
                return null;
            }
        }

        // Get all save slots (with caching to avoid repeated requests)
        let cachedSlots = null;
        let slotsCacheTime = 0;
        async function getAllSaveSlots() {
            if (!isLoggedIn || !sessionId) return {};
            
            // Return cached slots if fresher than 500ms
            const now = Date.now();
            if (cachedSlots && (now - slotsCacheTime) < 500) {
                return cachedSlots;
            }

            try {
                const response = await fetch(`${API_BASE_URL}/api/dungeon/slots`, {
                    headers: {
                        'Authorization': `Bearer ${sessionId}`
                    }
                });

                const slots = await response.json();
                cachedSlots = slots;
                slotsCacheTime = now;
                return slots;
            } catch (error) {
                console.error('Get save slots failed:', error);
                return cachedSlots || {};
            }
        }

        // Delete save slot
        async function deleteSaveSlot(slotNumber) {
            if (!isLoggedIn || !sessionId) return false;

            const slot = `slot${slotNumber}`;

            try {
                const response = await fetch(`${API_BASE_URL}/api/dungeon/delete`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${sessionId}`
                    },
                    body: JSON.stringify({ slot })
                });

                const result = await response.json();
                return result.success;
            } catch (error) {
                console.error('Delete save slot failed:', error);
                return false;
            }
        }

        // Auto-save (debounced)
        let autoSaveTimeout;
        function triggerAutoSave() {
            if (!currentSaveSlot) return;
            
            clearTimeout(autoSaveTimeout);
            autoSaveTimeout = setTimeout(async () => {
                await saveToCloud(currentSaveSlot, `Auto-save ${currentSaveSlot}`);
                addLog('Game auto-saved', 'text-green-400');
            }, 3000); // Auto-save 3 seconds after last action
        }

        // ===============================================
        // ORIGINAL GAME DATA
        // ===============================================
        
        // Helper function to get weapon damage description
        function getWeaponDamageDesc(tier) {
            const damages = {
                1: "1d3 (1-3 damage)",
                2: "1d6 (1-6 damage)",
                3: "1d10 (1-10 damage)",
                4: "2d6+2 (4-14 damage)",
                5: "3d6+3 (6-21 damage)",
                6: "4d6+4 (8-28 damage)"
            };
            return damages[tier] || "Unknown";
        }
        
        // --- DATA MATCHING PYTHON EXACTLY ---
        // [Cost, Value, Type(1=Wep,2=Arm,3=Pot,4=Spl), Effect/Uses]
        const SHOP_DATA = {
            "dagger": [30, 2, 1],
            "short sword": [50, 3, 1],
            "long sword": [100, 4, 1],
            "axe": [200, 5, 1],
            "great sword": [500, 6, 1],
            "paded armor": [125, 10, 2],
            "leather armor": [200, 11, 2],
            "studded leather": [400, 12, 2],
            "scale mail": [700, 13, 2],
            "chainmail": [1000, 14, 2],
            "platemail": [1500, 15, 2],
            "healing potion": [25, 3, 3, 1],
            "intelligence potion": [70, 2, 3, 2],
            "speed potion": [100, 2, 3, 3],
            "strength potion": [130, 2, 3, 4],
            "protection potion": [150, 2, 3, 5],
            "magic missile spell": [50, 3, 4, 1],
            "weakness spell": [70, 2, 4, 2],
            "lightning spell": [100, 2, 4, 3],
            "freeze spell": [130, 2, 4, 4],
            "fireball spell": [150, 2, 4, 5],
            "town spell": [200, 2, 4, 6],
            "checkpoint": [500, 0, 5],
            "detailed map": [500, 0, 7, 6],
            "chest map": [50, 0, 7, 0],
            "monster map": [100, 0, 7, 1],
            "mini-boss map": [115, 0, 7, 2],
            "merchant map": [75, 0, 7, 3],
            "stairs map": [115, 0, 7, 4],
            "boss map": [150, 0, 7, 5]
        };

        // --- ACHIEVEMENTS SYSTEM ---
        const ACHIEVEMENTS = {
            // Easy Achievements (10-20 coins)
            first_kill: { name: "First Blood", desc: "Defeat your first monster", reward: 10, difficulty: "easy" },
            open_chest: { name: "Treasure Seeker", desc: "Open your first chest", reward: 15, difficulty: "easy" },
            kill_10: { name: "Monster Slayer", desc: "Defeat 10 monsters", reward: 15, difficulty: "easy" },
            loot_100: { name: "Coin Collector", desc: "Collect 100 gold", reward: 20, difficulty: "easy" },
            equip_item: { name: "Geared Up", desc: "Equip a weapon or armor", reward: 10, difficulty: "easy" },
            cast_spell: { name: "Apprentice Mage", desc: "Cast your first spell", reward: 12, difficulty: "easy" },
            
            // Medium Achievements (25-50 coins)
            level_5: { name: "Rising Power", desc: "Reach Level 5", reward: 25, difficulty: "medium" },
            kill_50: { name: "Monster Hunter", desc: "Defeat 50 monsters", reward: 30, difficulty: "medium" },
            loot_1000: { name: "Gold Digger", desc: "Collect 1,000 gold", reward: 35, difficulty: "medium" },
            floor_5: { name: "Deep Explorer", desc: "Reach Floor 5", reward: 40, difficulty: "medium" },
            defeat_mini: { name: "Mini Boss Bane", desc: "Defeat a Mini Boss", reward: 45, difficulty: "medium" },
            collect_3_spells: { name: "Spellcaster", desc: "Collect 3 different spells", reward: 30, difficulty: "medium" },
            combat_streak: { name: "On A Roll", desc: "Win 5 combats in a row", reward: 35, difficulty: "medium" },
            level_10: { name: "Veteran Adventurer", desc: "Reach Level 10", reward: 40, difficulty: "medium" },
            librarian: { name: "Spell Master", desc: "Collect all 5 spell types", reward: 50, difficulty: "medium" },
            
            // Hard Achievements (75-150 coins)
            boss_killer: { name: "Boss Slayer", desc: "Defeat a Boss", reward: 75, difficulty: "hard" },
            hoarder: { name: "Treasure Hoarder", desc: "Collect 5,000 gold", reward: 80, difficulty: "hard" },
            floor_10: { name: "Dungeon Delver", desc: "Reach Floor 10", reward: 100, difficulty: "hard" },
            level_15: { name: "Master Fighter", desc: "Reach Level 15", reward: 90, difficulty: "hard" },
            kill_200: { name: "Exterminator", desc: "Defeat 200 monsters", reward: 85, difficulty: "hard" },
            wealthy: { name: "Wealthy Noble", desc: "Collect 10,000 gold", reward: 110, difficulty: "hard" },
            defeat_3_bosses: { name: "Boss Hunter", desc: "Defeat 3 Bosses", reward: 120, difficulty: "hard" },
            combat_streak_8: { name: "Unstoppable Force", desc: "Win 8 combats in a row", reward: 95, difficulty: "hard" },
            floor_15: { name: "Abyss Walker", desc: "Reach Floor 15", reward: 125, difficulty: "hard" },
            golden_touch: { name: "Golden Touch", desc: "Collect 50,000 gold", reward: 150, difficulty: "hard" },
            level_20: { name: "Legendary Warrior", desc: "Reach Level 20", reward: 130, difficulty: "hard" },
            floor_master: { name: "Floor Master", desc: "Reach Floor 25", reward: 140, difficulty: "hard" },
            defeat_50_monsters: { name: "Monster Apocalypse", desc: "Defeat 500 monsters", reward: 115, difficulty: "hard" }
        };

        // --- ITEM RARITY SYSTEM ---
        const RARITY = {
            common: { color: "#a0a0a0", name: "Common" },
            uncommon: { color: "#00ff00", name: "Uncommon" },
            rare: { color: "#3b82f6", name: "Rare" },
            epic: { color: "#a855f7", name: "Epic" },
            legendary: { color: "#fbbf24", name: "Legendary" }
        };

        function getItemRarity() {
            const roll = Math.random();
            if (roll < 0.6) return 'common';
            if (roll < 0.85) return 'uncommon';
            if (roll < 0.95) return 'rare';
            if (roll < 0.99) return 'epic';
            return 'legendary';
        }

        // --- GAME STATE ---
        let stats = {
            characterName: "",
            HP: 15, maxHP: 15, coins: 0, armor: 9, keys: 0, floor: 1,
            exp: 0, level: 1, totalExp: 0, expToNextLevel: 100,
            strength: 0, dexterity: 0, intelligence: 0, wisdom: 0,
            temporary_strength: 0, temporary_dexterity: 0, temporary_intelligence: 0, temporary_armor: 0,
            attackBonus: 0,  // Permanent attack roll bonus from merchant weapons
            acBonus: 0,  // Permanent AC bonus from merchant armor
            temporary_attackBonus: 0,  // Temporary attack bonus from potions
            temporary_acBonus: 0,  // Temporary AC bonus from potions
            temporary_allRollsBonus: 0,  // Temporary bonus to all rolls
            weapons: { "stick": { tier: 1, durability: 100, maxDurability: 100 } }, 
            armors: { "none": 9 }, 
            potions: {}, 
            spells: {},
            equippedWeapon: "stick",
            equippedArmor: "none",
            openedChests: new Set(),
            deathCount: 0,
            achievements: {},
            combatWinStreak: 0,
            lastCombatWon: false,
            activeBuff: null,
            activeBuffTurns: 0,
            kills: 0,
            miniBossesDefeated: 0,
            bossesDefeated: 0,
            spellsCast: 0,
            checkpointsPurchased: 0,  // Total checkpoints bought
            checkpoints: {},  // Named checkpoints: {name: {floor, row, col}, ...}
            hasMap: false,  // Whether player owns the map item
            hasDetailedMap: false,  // Whether player owns the detailed map item
            // Map layers - which types of rooms are visible
            mapLayers: {
                chests: false,
                monsters: false,
                miniBosses: false,
                merchants: false,
                stairs: false,
                bosses: false
            },
            // Track which map layers are owned (purchased)
            ownedMapLayers: {
                chests: false,
                monsters: false,
                miniBosses: false,
                merchants: false,
                stairs: false,
                bosses: false
            },
            stairEntryPoints: {},  // Track where player entered each floor from stairs: {floor: {row, col}}
            unlockedStairs: new Set()  // Track unlocked stairs by "floor,row,col"
        };
        let floorMaps = {}; // Store maps per floor
        let monsterData = {}; // Store pre-generated monster stats by room
        let currentRoom = [9, 9];
        let pendingRolls = [];
        let combatData = null;
        let isProcessing = false;
        let previousView = "view-town";
        let shopMode = "buy";

        // --- WEAPON DURABILITY ---
        // Defines durability tiers for different weapon damage tiers
        // Higher damage = lower durability (and vice versa)
        const WEAPON_DURABILITY = {
            1: 70,   // Stick: very durable
            2: 55,   // Tier 2: good durability
            3: 45,   // Tier 3: moderate durability
            4: 35,   // Tier 4: lower durability
            5: 28,   // Tier 5: fragile
            6: 20,   // Tier 6: very fragile
            // Merchant weapons (custom): durability/damage trade-off
            "custom_low": 80,      // Custom formula weapons with lower damage: high durability
            "custom_mid": 60,      // Medium damage custom: medium durability
            "custom_high": 35      // Custom formula weapons with high damage: low durability
        };
        
        function initializeWeaponDurability(weaponName, weaponData) {
            if (weaponData && typeof weaponData === 'object') {
                if (weaponData.durability === undefined) {
                    if (weaponData.damageFormula) {
                        // Custom damage formula - determine durability based on formula complexity
                        if (weaponData.damageFormula.includes('6d') || weaponData.damageFormula.includes('5d')) {
                            weaponData.maxDurability = WEAPON_DURABILITY.custom_high;
                        } else if (weaponData.damageFormula.includes('3d') || weaponData.damageFormula.includes('4d')) {
                            weaponData.maxDurability = WEAPON_DURABILITY.custom_mid;
                        } else {
                            weaponData.maxDurability = WEAPON_DURABILITY.custom_low;
                        }
                    } else {
                        // Tier-based weapon
                        const tier = weaponData.tier || 1;
                        weaponData.maxDurability = WEAPON_DURABILITY[tier] || WEAPON_DURABILITY[1];
                    }
                    weaponData.durability = weaponData.maxDurability;
                }
            }
        }
        
        function ensureAllWeaponsInitialized() {
            // Make sure all weapons have durability initialized
            for (let weaponName in stats.weapons) {
                initializeWeaponDurability(weaponName, stats.weapons[weaponName]);
            }
        }
        
        function damageWeaponDurability(weaponName) {
            const weaponData = stats.weapons[weaponName];
            if (weaponData && typeof weaponData === 'object' && weaponData.durability !== undefined) {
                weaponData.durability = Math.max(0, weaponData.durability - 1);
                
                if (weaponData.durability === 0) {
                    // Weapon broke!
                    if (stats.equippedWeapon === weaponName) {
                        stats.equippedWeapon = "stick";
                        stats.attackBonus = 0;
                        addLog(`‚ö†Ô∏è Your ${weaponName} shattered! You're back to your stick.`, "text-red-600 font-bold");
                    } else {
                        addLog(`‚ö†Ô∏è Your ${weaponName} has broken and shattered!`, "text-red-500");
                    }
                    delete stats.weapons[weaponName];
                    renderInventory();
                } else if (weaponData.durability <= Math.ceil(weaponData.maxDurability * 0.2)) {
                    // Low durability warning
                    addLog(`‚ö†Ô∏è Your ${weaponName} is badly worn! (${weaponData.durability}/${weaponData.maxDurability})`, "text-yellow-600 font-bold");
                }
            }
        }

        // --- CORE UTILS ---
        function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

        async function logLoading(text, dots = 3, speed = 200) {
            const log = document.getElementById('game-log');
            const entry = document.createElement('div');
            entry.className = "text-slate-500 italic";
            log.appendChild(entry);
            for(let i=0; i<3; i++) {
                for(let d=1; d<=dots; d++) {
                    entry.innerText = `${text}${'.'.repeat(d)}`;
                    log.scrollTop = log.scrollHeight;
                    await sleep(speed);
                }
            }
            entry.remove();
        }

        function addLog(msg, color="text-slate-400") {
            const log = document.getElementById('game-log');
            const d = document.createElement('div');
            d.className = `${color} leading-snug`;
            d.innerText = msg;
            log.appendChild(d);
            log.scrollTop = log.scrollHeight;
        }

        function updateUI() {
            document.getElementById('stat-hp').innerText = `${stats.HP}/${stats.maxHP}`;
            document.getElementById('stat-gold').innerText = stats.coins;
            document.getElementById('stat-armor').innerText = getTotalAC();
            document.getElementById('stat-floor').innerText = `FLOOR ${stats.floor}`;
            document.getElementById('stat-level').innerText = `LVL ${stats.level}`;
            
            // Calculate total EXP needed for next level: 50 * level * (level + 1)
            const totalExpForNextLevel = 50 * stats.level * (stats.level + 1);
            
            document.getElementById('stat-exp').innerText = `EXP: ${stats.totalExp}/${totalExpForNextLevel}`;
            
            // Update individual attribute displays
            document.getElementById('stat-str').innerText = stats.strength;
            document.getElementById('stat-dex').innerText = stats.dexterity;
            document.getElementById('stat-int').innerText = stats.intelligence;
            document.getElementById('stat-wis').innerText = stats.wisdom;
            
            // Update combat streak indicator
            const streakEl = document.getElementById('combat-streak-indicator');
            if (stats.combatWinStreak >= 2) {
                streakEl.classList.remove('hidden');
                document.getElementById('streak-count').innerText = stats.combatWinStreak;
            } else {
                streakEl.classList.add('hidden');
            }
            
            const btn = document.getElementById('btn-return-town');
            if (currentRoom[0] === 9 && currentRoom[1] === 9 && stats.floor === 1) {
                btn.classList.remove('hidden');
            } else {
                btn.classList.add('hidden');
            }
        }

        function showView(viewId) {
            // Store the current view BEFORE hiding everything
            const currentView = document.querySelector('#viewport > div:not(.hidden)')?.id;
            
            // Only update previousView when opening inventory (to remember where to return)
            // Do NOT overwrite previousView when returning to inventory from the achievements view
            if (viewId === "view-inventory" && currentView && currentView !== "view-inventory" && currentView !== 'view-achievements') {
                previousView = currentView;
            }
            // When closing inventory or doing any other transition, DON'T update previousView
            
            ['view-menu','view-creation','view-town','view-dungeon','view-combat','view-shop','view-inventory','view-achievements'].forEach(v => 
                document.getElementById(v).classList.add('hidden')
            );
            
            document.getElementById('viewport').classList.toggle('combat-active', viewId === 'view-combat');
            document.getElementById(viewId).classList.remove('hidden');
            
            if(viewId !== 'view-menu') {
                document.getElementById('stats-header').classList.remove('hidden');
                document.getElementById('global-actions').classList.remove('hidden');
            }
            if(viewId === 'view-dungeon') updateUI();
            if(viewId === 'view-achievements') renderAchievements();
        }

        function toggleInventory() {
            if (!document.getElementById('view-inventory').classList.contains('hidden')) {
                closeInventory();
            } else {
                renderInventory();
                showView('view-inventory');
            }
        }

        function closeInventory() {
            // If we're returning to combat, make sure combat state is still valid
            if (previousView === 'view-combat') {
                if (combatData && combatData.HP > 0) {
                    // Combat is still active, restore it
                    showView('view-combat');
                    updateCombatUI();
                    // Restore the appropriate menu based on whose turn it is
                    if (combatData.turn === 'player') {
                        showCombatSubMenu('main');
                    } else if (combatData.turn === 'monster') {
                        showCombatSubMenu('defense');
                    }
                } else {
                    // Combat ended while in inventory, go back to dungeon
                    showView('view-dungeon');
                    renderDungeon();
                    checkRoom(true);
                }
            } else {
                showView(previousView);
            }
        }

        // Robust UI handler for the inventory close button (fallbacks and safety)
        function inventoryClose() {
            try {
                // Prefer the existing closeInventory logic (handles combat)
                if (typeof closeInventory === 'function') closeInventory();
            } catch (e) {
                console.error('closeInventory failed:', e);
            }

            // Ensure inventory is hidden and we show a sensible view
            const inv = document.getElementById('view-inventory');
            if (inv && !inv.classList.contains('hidden')) inv.classList.add('hidden');

            const target = previousView || 'view-town';
            if (document.getElementById(target)) {
                // Use showView to properly render headers/UI
                showView(target);
            } else {
                showView('view-town');
            }

            // Reset previousView to avoid unexpected back-navigation
            previousView = 'view-town';
        }

        async function saveGame() {
            // Show save slot selection modal
            showSaveSlotModal();
        }

        async function loadGame() {
            // Check authentication before loading
            if (!isLoggedIn) {
                addLog('Please log in to load your game!', 'text-red-400');
                window.location.href = 'account.html?return=dungeon_game.html';
                return;
            }
            // Show loading indicator while fetching slots
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.9);display:flex;align-items:center;justify-content:center;z-index:10000;';
            modal.innerHTML = '<div style="text-align:center;color:white;"><div style="font-size:2rem;margin-bottom:1rem;">‚è≥</div><div>Loading save slots...</div></div>';
            modal.id = 'loading-modal';
            document.body.appendChild(modal);
            
            // Show load slot selection modal
            await showLoadSlotModal();
            
            const loadingModal = document.getElementById('loading-modal');
            if (loadingModal) loadingModal.remove();
        }

        // Show save slot selection modal
        async function showSaveSlotModal() {
            // Show loading indicator while fetching slots
            const loadingModal = document.createElement('div');
            loadingModal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.9);display:flex;align-items:center;justify-content:center;z-index:10000;';
            loadingModal.innerHTML = '<div style="text-align:center;color:white;"><div style="font-size:2rem;margin-bottom:1rem;">‚è≥</div><div>Loading save slots...</div></div>';
            loadingModal.id = 'loading-modal';
            document.body.appendChild(loadingModal);
            
            const slots = await getAllSaveSlots();
            
            // Remove loading modal immediately
            const existingLoading = document.getElementById('loading-modal');
            if (existingLoading) existingLoading.remove();
            
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.9);display:flex;align-items:center;justify-content:center;z-index:10000;';
            
            let html = '<div style="background:#1e293b;padding:2rem;border-radius:10px;max-width:500px;width:90%;">';
            html += '<h2 style="font-size:1.5rem;font-weight:bold;margin-bottom:1.5rem;text-align:center;color:white;">SAVE TO SLOT</h2>';
            html += '<div style="display:flex;flex-direction:column;gap:1rem;">';
            
            for (let i = 1; i <= 3; i++) {
                const slot = slots[`slot${i}`];
                const slotName = slot ? slot.name : `Empty Slot ${i}`;
                const slotDate = slot ? new Date(slot.savedAt).toLocaleString() : '';
                const currentCharName = stats.characterName || 'Unnamed Hero';
                
                html += `<button onclick="saveToSlotAndClose(${i})" style="padding:1rem;background:#334155;border-radius:8px;text-align:left;cursor:pointer;border:2px solid #475569;transition:all 0.2s;color:white;" onmouseover="this.style.background='#475569'" onmouseout="this.style.background='#334155'">`;
                html += `<div style="font-weight:bold;font-size:1.1rem;">Slot ${i}</div>`;
                if (slot) {
                    html += `<div style="font-size:0.9rem;color:#fbbf24;">${slotName}</div>`;
                    html += `<div style="font-size:0.8rem;color:#94a3b8;">${slotDate}</div>`;
                } else {
                    html += `<div style="font-size:0.9rem;color:#64748b;">Empty</div>`;
                }
                html += `<div style="font-size:0.75rem;color:#3b82f6;margin-top:0.25rem;">Will save: ${currentCharName}</div>`;
                html += '</button>';
            }
            
            html += '</div>';
            html += '<button onclick="closeSaveModal()" style="margin-top:1.5rem;width:100%;padding:0.75rem;background:#64748b;border-radius:8px;font-weight:bold;color:white;">CANCEL</button>';
            html += '</div>';
            
            modal.innerHTML = html;
            modal.id = 'save-modal';
            document.body.appendChild(modal);
        }

        // Show load slot selection modal
        async function showLoadSlotModal() {
            const slots = await getAllSaveSlots();
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.9);display:flex;align-items:center;justify-content:center;z-index:10000;';
            
            let html = '<div style="background:#1e293b;padding:2rem;border-radius:10px;max-width:500px;width:90%;">';
            html += '<h2 style="font-size:1.5rem;font-weight:bold;margin-bottom:1.5rem;text-align:center;color:white;">LOAD FROM SLOT</h2>';
            html += '<div style="display:flex;flex-direction:column;gap:1rem;">';
            
            for (let i = 1; i <= 3; i++) {
                const slot = slots[`slot${i}`];
                const slotDate = slot ? new Date(slot.savedAt).toLocaleString() : '';
                
                if (slot) {
                    const characterName = slot.name || `Save ${i}`;
                    html += `<div style="padding:1rem;background:#334155;border-radius:8px;border:2px solid #475569;display:flex;justify-content:space-between;align-items:center;">`;
                    html += `<div style="flex:1;cursor:pointer;color:white;" onclick="loadFromSlotAndClose(${i})">`;
                    html += `<div style="font-weight:bold;font-size:1.1rem;">Slot ${i}</div>`;
                    html += `<div style="font-size:1rem;color:#fbbf24;">${characterName}</div>`;
                    html += `<div style="font-size:0.8rem;color:#94a3b8;">${slotDate}</div>`;
                    html += `</div>`;
                    html += `<button onclick="deleteSlotAndRefresh(${i})" style="padding:0.5rem 1rem;background:#ef4444;border-radius:6px;font-size:0.8rem;font-weight:bold;color:white;cursor:pointer;">DELETE</button>`;
                    html += '</div>';
                } else {
                    html += `<div style="padding:1rem;background:#1e293b;border-radius:8px;border:2px solid #334155;color:#64748b;">`;
                    html += `<div style="font-weight:bold;">Slot ${i}: Empty</div>`;
                    html += '</div>';
                }
            }
            
            html += '</div>';
            html += '<button onclick="closeLoadModal()" style="margin-top:1.5rem;width:100%;padding:0.75rem;background:#64748b;border-radius:8px;font-weight:bold;color:white;">CANCEL</button>';
            html += '</div>';
            
            modal.innerHTML = html;
            modal.id = 'load-modal';
            document.body.appendChild(modal);
        }

        async function saveToSlotAndClose(slotNumber) {
            const saveName = stats.characterName || `Save ${slotNumber}`;
            const success = await saveToCloud(slotNumber, saveName);
            if (success) {
                addLog(`Game saved to Slot ${slotNumber}!`, 'text-green-400');
                closeSaveModal();
            } else {
                addLog('Failed to save game', 'text-red-400');
            }
        }

        async function loadFromSlotAndClose(slotNumber) {
            const saveData = await loadFromCloud(slotNumber);
            if (saveData) {
                stats = saveData.stats;
                
                // Ensure new properties exist (backward compatibility with old saves)
                if (!stats.kills) stats.kills = 0;
                if (!stats.miniBossesDefeated) stats.miniBossesDefeated = 0;
                if (!stats.bossesDefeated) stats.bossesDefeated = 0;
                if (!stats.spellsCast) stats.spellsCast = 0;
                if (!stats.achievements) stats.achievements = {};
                
                floorMaps = saveData.map || {};
                monsterData = saveData.monsters || {};
                currentRoom = saveData.room;
                stats.openedChests = new Set(saveData.openedChests);
                
                // Check if player was in town when they saved
                const wasInTown = saveData.inTown === true;
                
                if (wasInTown) {
                    // Load into town
                    showView('view-town');
                    addLog(`Game loaded from Slot ${slotNumber}!`, 'text-yellow-400');
                    addLog(`Welcome back to Oakhaven, ${stats.characterName || 'adventurer'}!`, 'text-slate-400');
                } else {
                    // Load into dungeon
                    showView('view-dungeon');
                    renderDungeon();
                    addLog(`Game loaded from Slot ${slotNumber}!`, 'text-yellow-400');
                    // Check room for events (including battles) - don't suppress, but don't spawn new wandering monsters
                    checkRoom(false, false);
                }
                
                updateUI();
                closeLoadModal();
            } else {
                addLog('Failed to load game', 'text-red-400');
            }
        }

        function deleteSlotAndRefresh(slotNumber) {
            showDeleteConfirmation(slotNumber);
        }

        function showDeleteConfirmation(slotNumber) {
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.95);display:flex;align-items:center;justify-content:center;z-index:11000;';
            
            let html = '<div style="background:#1e293b;padding:2rem;border-radius:10px;max-width:400px;width:90%;border:3px solid #ef4444;">';
            html += '<div style="text-align:center;font-size:3rem;margin-bottom:1rem;">‚ö†Ô∏è</div>';
            html += '<h2 style="font-size:1.3rem;font-weight:bold;margin-bottom:1rem;text-align:center;color:#ef4444;">DELETE SAVE?</h2>';
            html += '<div style="background:#0f172a;padding:1.5rem;border-radius:8px;margin-bottom:1.5rem;border:2px solid #7f1d1d;text-align:center;">';
            html += `<div style="font-size:1.1rem;font-weight:bold;color:#fbbf24;margin-bottom:0.5rem;">Save Slot ${slotNumber}</div>`;
            html += '<div style="font-size:0.9rem;color:#ef4444;font-weight:bold;margin-top:1rem;">This action cannot be undone!</div>';
            html += '</div>';
            html += '<div style="display:flex;gap:0.75rem;flex-direction:column;">';
            html += `<button onclick="confirmDelete(${slotNumber})" style="width:100%;padding:0.75rem;background:#ef4444;border-radius:8px;font-weight:bold;color:white;font-size:0.95rem;cursor:pointer;border:none;">DELETE SAVE</button>`;
            html += '<button onclick="closeDeleteModal()" style="width:100%;padding:0.75rem;background:#64748b;border-radius:8px;font-weight:bold;color:white;font-size:0.95rem;cursor:pointer;border:none;">CANCEL</button>';
            html += '</div>';
            html += '</div>';
            
            modal.innerHTML = html;
            modal.id = 'delete-modal';
            document.body.appendChild(modal);
        }

        async function confirmDelete(slotNumber) {
            closeDeleteModal();
            const success = await deleteSaveSlot(slotNumber);
            if (success) {
                addLog(`Deleted save slot ${slotNumber}`, 'text-red-400');
                closeLoadModal();
                setTimeout(() => showLoadSlotModal(), 100);
            } else {
                addLog('Failed to delete save', 'text-red-400');
            }
        }

        function closeDeleteModal() {
            const modal = document.getElementById('delete-modal');
            if (modal) modal.remove();
        }

        function closeSaveModal() {
            const modal = document.getElementById('save-modal');
            if (modal) modal.remove();
        }

        function closeLoadModal() {
            const modal = document.getElementById('load-modal');
            if (modal) modal.remove();
        }

        // --- CHANGE CHARACTER NAME ---
        function showChangeNameModal() {
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.9);display:flex;align-items:center;justify-content:center;z-index:10000;';
            
            let html = '<div style="background:#1e293b;padding:2rem;border-radius:10px;max-width:450px;width:90%;">';
            html += '<h2 style="font-size:1.5rem;font-weight:bold;margin-bottom:1.5rem;text-align:center;color:white;">CHANGE CHARACTER NAME</h2>';
            html += '<div style="background:#0f172a;padding:1.5rem;border-radius:8px;margin-bottom:1rem;border:2px solid #334155;">';
            html += `<div style="font-size:0.9rem;color:#94a3b8;margin-bottom:0.5rem;">Current Name:</div>`;
            html += `<div style="font-size:1.2rem;font-weight:bold;color:#fbbf24;margin-bottom:1rem;">${stats.characterName || 'Unnamed'}</div>`;
            html += '<div style="font-size:0.9rem;color:#94a3b8;margin-bottom:0.5rem;">New Name:</div>';
            html += '<input id="new-character-name" type="text" maxlength="20" placeholder="Enter new name..." style="width:100%;padding:0.75rem;background:#1e293b;border:2px solid #475569;border-radius:6px;color:white;font-size:1rem;outline:none;" />';
            html += '</div>';
            html += '<div style="display:flex;gap:0.75rem;">';
            html += '<button onclick="confirmNameChange()" style="flex:1;padding:0.75rem;background:#3b82f6;border-radius:8px;font-weight:bold;color:white;font-size:0.95rem;cursor:pointer;border:none;">CHANGE NAME</button>';
            html += '<button onclick="closeChangeNameModal()" style="flex:1;padding:0.75rem;background:#64748b;border-radius:8px;font-weight:bold;color:white;font-size:0.95rem;cursor:pointer;border:none;">CANCEL</button>';
            html += '</div>';
            html += '</div>';
            
            modal.innerHTML = html;
            modal.id = 'change-name-modal';
            document.body.appendChild(modal);
            
            // Focus the input field
            setTimeout(() => {
                document.getElementById('new-character-name').focus();
            }, 100);
        }

        function confirmNameChange() {
            const newName = document.getElementById('new-character-name').value.trim();
            
            if (newName === '') {
                addLog('Please enter a valid name!', 'text-red-400');
                return;
            }
            
            const oldName = stats.characterName || 'Unnamed';
            stats.characterName = newName;
            
            closeChangeNameModal();
            addLog(`Character name changed from "${oldName}" to "${newName}"`, 'text-blue-400');
            addLog('Remember to save your game to keep the new name!', 'text-yellow-400');
        }

        function closeChangeNameModal() {
            const modal = document.getElementById('change-name-modal');
            if (modal) modal.remove();
        }

        // --- CHARACTER CREATION ---
        function create_value() {
            const rolls = Array.from({length:4}, () => Math.floor(Math.random()*6)+1);
            return rolls.reduce((a,b)=>a+b,0) - Math.min(...rolls);
        }

        function initCharacterCreation() {
            // Show character name input first
            document.getElementById('char-name-input').classList.remove('hidden');
            document.getElementById('attr-assignment').classList.add('hidden');
            document.getElementById('character-name').value = '';
            showView('view-creation');
        }
        
        function confirmCharacterName() {
            const nameInput = document.getElementById('character-name').value.trim();
            if (nameInput === '') {
                addLog('Please enter a character name!', 'text-red-400');
                return;
            }
            stats.characterName = nameInput;
            
            // Now proceed to attribute assignment
            pendingRolls = [create_value(), create_value(), create_value(), create_value()];
            stats.coins = 0;
            for(let i=0; i<20; i++) stats.coins += Math.floor(Math.random()*6)+1;
            
            document.getElementById('char-name-input').classList.add('hidden');
            document.getElementById('attr-assignment').classList.remove('hidden');
            renderCreation();
        }

        function renderCreation() {
            const rc = document.getElementById('rolls-container');
            rc.innerHTML = '';
            pendingRolls.forEach(r => {
                const b = document.createElement('div');
                b.className = "w-10 h-10 bg-slate-800 border border-slate-700 flex items-center justify-center font-bold text-yellow-500 rounded";
                b.innerText = r;
                rc.appendChild(b);
            });

            const ac = document.getElementById('attr-selection');
            ac.innerHTML = '';
            ['strength', 'wisdom', 'dexterity', 'intelligence'].forEach(attr => {
                const row = document.createElement('div');
                row.className = "flex justify-between items-center p-2 bg-slate-800/30 rounded";
                row.innerHTML = `<span class="capitalize text-sm font-bold text-slate-400">${attr}</span>`;
                const group = document.createElement('div');
                group.className = "flex gap-1";
                if(stats[attr] === 0 || stats[attr] === null) {
                    pendingRolls.forEach((r, i) => {
                        const btn = document.createElement('button');
                        btn.className = "w-10 h-10 bg-blue-600 rounded text-sm font-bold";
                        btn.innerText = r;
                        btn.onclick = () => {
                            stats[attr] = r;
                            pendingRolls.splice(i, 1);
                            if(pendingRolls.length === 0) {
                                showView('view-town');
                                updateUI();
                            } else renderCreation();
                        };
                        group.appendChild(btn);
                    });
                } else {
                    group.innerHTML = `<span class="text-green-500 font-bold text-sm">${stats[attr]}</span>`;
                }
                row.appendChild(group);
                ac.appendChild(row);
            });
        }

        // --- FLOOR ITEMS SYSTEM ---
        // Each floor has 10 unique themed items, merchants sell random 3
        // Format: [Cost, Type(1=Weapon,2=Armor,3=Potion), BaseTier/BaseAC/EffectType, BonusValue]
        // All items are UNIQUE and BETTER than starting gear (AC >= 10, Tier >= 2)
        const FLOOR_ITEMS = {
            1: {
                items: {
                    "Goblin's Lucky Dagger": [150, 1, 2, "1d6+1d4"],  // Custom: 1d6+1d4 damage (2-10), +2 attack rolls
                    "Greedy Goblin Cloak": [400, 2, 11, {type: 'coins', threshold: 500, bonus: 2}],  // AC 11 base, +2 AC when coins >= 500 (GREED THEME)
                    "Warren Blade": [250, 1, 3, "2d6"],  // Custom: 2d6 damage (2-12), +3 attack rolls
                    "Hoarder's Armor": [550, 2, 12, {type: 'coins', threshold: 1000, bonus: 3}],  // AC 12 base, +3 AC when coins >= 1000 (GREED THEME)
                    "Goblin Luck Potion": [100, 3, 1, 2],  // +2 to all rolls for 1 turn
                    "Lucky Coin": [120, 3, 4, 2],  // +2 attack rolls for 1 turn
                    "Warren Elixir": [140, 3, 5, 2],  // +2 AC for 1 turn
                    "checkpoint": [500, 0, 5, 0]
                },
                names: ["Goblin Merchant Gruk", "Goblin Trader", "Surface Merchant"],
                greetings: ["Welcome to my humble stall, adventurer!", "Fresh goods from the surface!", "Best prices in the warrens!"]
            },
            2: {
                items: {
                    "Plague Blade": [350, 1, 3, "1d8+1d6"],  // Custom: 1d8+1d6 damage (2-14), +3 attack rolls (disease theme)
                    "Desperate Rat Cloak": [600, 2, 12, {type: 'lowHP', threshold: 8, bonus: 2}],  // AC 12 base, +2 AC when HP <= 8 (DESPERATION)
                    "Antidote Potion": [180, 3, 1, 3],  // +3 to all rolls for 1 turn (poison resistance theme)
                    "Infected Blade": [450, 1, 4, {type: 'lowHP', threshold: 10, bonus: 2, baseDamage: "2d8"}],  // 2d8+4 base, +2 dmg when HP<=10 (DISEASE FEEDS ON WEAKNESS)
                    "Disease Ward": [750, 2, 13, {type: 'percentHP', threshold: 0.5, bonus: 2}],  // AC 13 base, +2 AC when HP <= 50%
                    "Plague Remedy": [200, 3, 2, 2],  // +2 to all rolls for 1 turn
                    "Pestilence Guard": [900, 2, 14, 2],  // AC 14 base, +2 AC bonus (AC 16 total)
                    "checkpoint": [500, 0, 5, 0]
                },
                names: ["Rat King's Quartermaster", "Plague Merchant", "Vermin Trader"],
                greetings: ["Ssssss... you wish to buy from my master's stores?", "Disease-resistant goods available!", "Fair prices for brave adventurers!"]
            },
            3: {
                items: {
                    "Stone Crusher": [550, 1, 4, "2d10"],  // Custom: 2d10 damage (2-20), +4 attack rolls, ENHANCED DURABILITY
                    "Resilient Stone Armor": [1100, 2, 13, {type: 'highHP', threshold: 20, bonus: 3}],  // AC 13 base, +3 AC when HP >= 20 (STONE RESILIENCE)
                    "Stone Skin Potion": [250, 3, 3, 3],  // +3 AC for 1 turn (golem theme)
                    "Petrified Blade": [750, 1, 5, "3d8"],  // Custom: 3d8 damage (3-24), +5 attack rolls, ENHANCED DURABILITY
                    "Golem's Guard": [1400, 2, 14, {type: 'percentHP', threshold: 0.6, bonus: 4}],  // AC 14 base, +4 AC when HP >= 60% (SOLID DEFENSE)
                    "Rock Hard Elixir": [300, 3, 5, 3],  // +3 AC for 1 turn
                    "Granite Hammer": [950, 1, 6, {type: 'floor', bonus: 1, baseDamage: "3d8"}],  // 3d8+6 base, +1 dmg per floor (GROWS STRONGER)
                    "Ancient Armor": [1700, 2, 15, {type: 'highHP', threshold: 25, bonus: 4}],  // AC 15 base, +4 AC when HP >= 25 (ENHANCED DURABILITY)
                    "checkpoint": [500, 0, 5, 0]
                },
                names: ["Stone Golem Keeper", "Granite Merchant", "Petrified Trader"],
                greetings: ["GOODS... FOR SALE... REINFORCED... DURABLE...", "Stone-crafted wares built to last!", "Ancient goods with enhanced durability!"]
            },
            4: {
                items: {
                    "Ember Blade": [700, 1, 5, "3d6"],  // Custom: 3d6 damage (3-18), +5 attack rolls (fire theme)
                    "Aggressive Flame Guard": [1200, 2, 13, {type: 'boss', bonus: 3}],  // AC 13 base, +3 AC vs bosses (AGGRESSIVE FIRE THEME)
                    "Inferno Potion": [300, 3, 4, 4],  // +4 attack rolls for 1 turn (fire power)
                    "Boss Slayer Sword": [900, 1, 6, {type: 'boss', bonus: 2, baseDamage: "4d6"}],  // 4d6+6 base, +2 dmg vs bosses (FIRE AGGRESSION)
                    "Fireproof Plate": [1500, 2, 14, {type: 'miniBoss', bonus: 3}],  // AC 14 base, +3 AC vs mini-bosses/bosses
                    "Ember Essence": [350, 3, 4, 5],  // +5 attack rolls for 1 turn
                    "Magma Blade": [1100, 1, 7, "5d6"],  // Custom: 5d6 damage (5-30), +7 attack rolls (high damage fire theme)
                    "Infernal Armor": [1800, 2, 15, {type: 'highHP', threshold: 30, bonus: 3}],  // AC 15 base, +3 AC when HP >= 30 (BURNING VITALITY)
                    "checkpoint": [500, 0, 5, 0]
                },
                names: ["Ember Trader", "Flame Merchant", "Infernal Vendor"],
                greetings: ["Feel the heat of my wares, traveler!", "Fire-forged weapons deal extra damage!", "Scorching deals for brave souls!"]
            },
            5: {
                items: {
                    "Frostbite Blade": [850, 1, 5, "2d10+1d6"],  // Custom: 2d10+1d6 damage (3-26), +5 attack rolls (ice theme)
                    "Frozen Fortress Armor": [1300, 2, 13, {type: 'highHP', threshold: 25, bonus: 4}],  // AC 13 base, +4 AC when HP >= 25 (FROZEN SOLID)
                    "Glacial Potion": [320, 3, 1, 3],  // +3 to all rolls for 1 turn (ice resilience)
                    "Frozen Edge": [1050, 1, 6, "3d10"],  // Custom: 3d10 damage (3-30), +6 attack rolls
                    "Permafrost Plate": [1600, 2, 14, {type: 'percentHP', threshold: 0.7, bonus: 4}],  // AC 14 base, +4 AC when HP >= 70% (ICE RESILIENCE)
                    "Ice Elixir": [370, 3, 3, 4],  // +4 AC for 1 turn
                    "Blizzard Blade": [1250, 1, 7, "4d8"],  // Custom: 4d8 damage (4-32), +7 attack rolls
                    "Arctic Armor": [1900, 2, 15, {type: 'coins', threshold: 2000, bonus: 4}],  // AC 15 base, +4 AC when coins >= 2000 (ICE HOARD)
                    "checkpoint": [500, 0, 5, 0]
                },
                names: ["Frost Merchant Elara", "Ice Trader", "Glacial Vendor"],
                greetings: ["Welcome to my frozen emporium.", "Ice weapons slow enemies with each strike!", "Frost-forged equipment available!"]
            },
            6: {
                items: {
                    "Cursed Blade": [1000, 1, 6, {type: 'lowHP', threshold: 12, bonus: 2, baseDamage: "3d8+1d6"}],  // 3d8+1d6+6 base, +2 dmg when HP<=12 (CURSE FEEDS)
                    "Blight Ward": [1450, 2, 14, {type: 'lowHP', threshold: 15, bonus: 4}],  // AC 14 base, +4 AC when HP <= 15 (CORRUPTION EMPOWERS)
                    "Corruption Potion": [350, 3, 4, 5],  // +5 attack rolls for 1 turn (dark power)
                    "Twisted Weapon": [1200, 1, 7, "4d10"],  // Custom: 4d10 damage (4-40), +7 attack rolls
                    "Cursed Armor": [1700, 2, 15, {type: 'percentHP', threshold: 0.4, bonus: 4}],  // AC 15 base, +4 AC when HP <= 40% (DARKNESS PROTECTS THE WEAK)
                    "Blight Elixir": [400, 3, 1, 4],  // +4 to all rolls for 1 turn
                    "Dark Blade": [1400, 1, 8, "5d8"],  // Custom: 5d8 damage (5-40), +8 attack rolls (corruption power)
                    "Corrupted Plate": [2000, 2, 16, {type: 'lowHP', threshold: 20, bonus: 4}],  // AC 16 base, +4 AC when HP <= 20
                    "checkpoint": [500, 0, 5, 0]
                },
                names: ["Corrupted Sage", "Twisted Merchant", "Blight Trader"],
                greetings: ["Ah, another seeker of forbidden knowledge...", "Cursed items channel dark power!", "Corruption comes at a price..."]
            },
            7: {
                items: {
                    "Void Edge": [1150, 1, 7, {type: 'floor', bonus: 1, baseDamage: "4d8"}],  // 4d8+7 base, +1 dmg per floor (CHAOS GROWS)
                    "Chaotic Cloak": [1600, 2, 14, {type: 'floorParity', evenBonus: 4, oddBonus: 0}],  // AC 14 base, +4 AC on even floors (CHAOS SHIFTS)
                    "Chaos Potion": [420, 3, 1, 4],  // +4 to all rolls for 1 turn (chaos power)
                    "Reality Breaker": [1350, 1, 8, "5d8"],  // Custom: 5d8 damage (5-40), +8 attack rolls
                    "Void Armor": [1850, 2, 15, {type: 'coins', threshold: 3000, bonus: 4}],  // AC 15 base, +4 AC when coins >= 3000 (VOID WEALTH)
                    "Chaos Elixir": [470, 3, 1, 5],  // +5 to all rolls for 1 turn
                    "Dimensional Blade": [1550, 1, 9, {type: 'floorParity', evenBonus: 0, oddBonus: 3, baseDamage: "6d8"}],  // 6d8+9 base, +3 dmg on odd floors (REALITY WARPS)
                    "Rift Plate": [2150, 2, 16, {type: 'percentHP', threshold: 0.5, bonus: 4}],  // AC 16 base, +4 AC when HP <= 50% (BALANCED CHAOS)
                    "checkpoint": [500, 0, 5, 0]
                },
                names: ["Void Merchant", "Rift Trader", "Chaos Vendor"],
                greetings: ["Reality bends around my wares... interested?", "Items from beyond the void!", "Chaos-touched equipment warps reality!"]
            },
            8: {
                items: {
                    "Abyssal Blade": [1350, 1, 8, {type: 'boss', bonus: 3, baseDamage: "5d10"}],  // 5d10+8 base, +3 dmg vs bosses (TITAN SLAYER)
                    "Depth Plate": [1900, 2, 15, {type: 'miniBoss', bonus: 4}],  // AC 15 base, +4 AC vs mini-bosses/bosses (ABYSS DEFENSE)
                    "Abyss Potion": [500, 3, 4, 6],  // +6 attack rolls for 1 turn (abyssal power)
                    "Leviathan's Edge": [1600, 1, 9, {type: 'miniBoss', bonus: 4, baseDamage: "6d10"}],  // 6d10+9 base, +4 dmg vs mini-bosses/bosses (MASSIVE POWER)
                    "Abyssal Armor": [2200, 2, 16, {type: 'boss', bonus: 4}],  // AC 16 base, +4 AC vs bosses (LEGENDARY PROTECTION)
                    "Depth Elixir": [550, 3, 1, 5],  // +5 to all rolls for 1 turn
                    "Titan's Blade": [1850, 1, 10, "7d10"],  // Custom: 7d10 damage (7-70), +10 attack rolls (massive power)
                    "Ancient Plate": [2500, 2, 17, {type: 'coins', threshold: 5000, bonus: 3}],  // AC 17 base, +3 AC when coins >= 5000 (DEEP WEALTH)
                    "checkpoint": [500, 0, 5, 0]
                },
                names: ["Abyssal Trader", "Depth Merchant", "Leviathan Vendor"],
                greetings: ["The abyss offers legendary power...", "Ancient treasures from the depths!", "Only the worthy can wield these!"]
            },
            9: {
                items: {
                    "Shadow Blade": [1650, 1, 9, {type: 'floorParity', evenBonus: 2, oddBonus: 0, baseDamage: "6d10"}],  // 6d10+9 base, +2 dmg on even floors (SHADOW DUALITY)
                    "Obsidian Armor": [2300, 2, 16, {type: 'floorParity', evenBonus: 4, oddBonus: 0}],  // AC 16 base, +4 AC on even floors (SHADOW SHIFTS)
                    "Shadow Potion": [600, 3, 1, 6],  // +6 to all rolls for 1 turn (shadow power)
                    "Dark Lord's Edge": [2000, 1, 10, {type: 'boss', bonus: 4, baseDamage: "7d10"}],  // 7d10+10 base, +4 dmg vs bosses (ULTIMATE SLAYER)
                    "Shadow Plate": [2700, 2, 17, {type: 'lowHP', threshold: 25, bonus: 3}],  // AC 17 base, +3 AC when HP <= 25 (SHADOW EMBRACE)
                    "Dark Elixir": [650, 3, 4, 7],  // +7 attack rolls for 1 turn
                    "Sovereign's Blade": [2400, 1, 11, {type: 'floor', bonus: 1, baseDamage: "8d10"}],  // 8d10+11 base, +1 dmg per floor (POWER ESCALATES)
                    "Legendary Plate": [3000, 2, 18, {type: 'highHP', threshold: 40, bonus: 2}],  // AC 18 base, +2 AC when HP >= 40 (LEGENDARY VITALITY)
                    "checkpoint": [500, 0, 5, 0]
                },
                names: ["Shadow Lord's Merchant", "Obsidian Trader", "Dark Vendor"],
                greetings: ["Few reach this level... excellent taste!", "The finest equipment in existence!", "Legendary items for legendary heroes!"]
            }
        };

        // Generate merchant inventory (random 3 items from floor's 10 items)
        function generateMerchantInventory(floor) {
            const floorData = FLOOR_ITEMS[floor] || FLOOR_ITEMS[1];
            const itemKeys = Object.keys(floorData.items);
            const selectedItems = {};
            
            // Randomly select 3 items
            const shuffled = itemKeys.sort(() => 0.5 - Math.random());
            for (let i = 0; i < Math.min(3, shuffled.length); i++) {
                const itemName = shuffled[i];
                selectedItems[itemName] = floorData.items[itemName];
            }
            
            return selectedItems;
        }

        // Get merchant name and greeting for a floor
        function getMerchantInfo(floor) {
            const floorData = FLOOR_ITEMS[floor] || FLOOR_ITEMS[1];
            const nameIndex = Math.floor(Math.random() * floorData.names.length);
            const greetingIndex = Math.floor(Math.random() * floorData.greetings.length);
            return {
                name: floorData.names[nameIndex],
                greeting: floorData.greetings[greetingIndex]
            };
        }

        // --- FLOOR THEMES SYSTEM ---
        const FLOOR_THEMES = {
            1: {
                name: "The Goblin Warrens",
                description: "Small green creatures scurry through damp tunnels.",
                color: "#10b981",
                enemies: ["goblin", "goblin", "goblin", "bandit", "cultist"],
                specialty: "weak but numerous"
            },
            2: {
                name: "The Rat King's Domain",
                description: "Oversized rodents and vermin infest this level.",
                color: "#8b5a00",
                enemies: ["rat", "rat", "zombie", "beast", "troll"],
                specialty: "disease and poison"
            },
            3: {
                name: "Petrified Stone Halls",
                description: "Ancient golems guard chambers of carved stone.",
                color: "#6b7280",
                enemies: ["golem", "skeleton", "guardian", "golem", "knight"],
                specialty: "high armor"
            },
            4: {
                name: "The Infernal Furnace",
                description: "Scorching heat radiates from walls of lava and ash.",
                color: "#ef4444",
                enemies: ["imp", "elemental", "imp", "mage", "wraith"],
                specialty: "fire damage"
            },
            5: {
                name: "Frozen Catacombs",
                description: "Shards of ice pierce through arctic winds.",
                color: "#06b6d4",
                enemies: ["spirit", "elemental", "wraith", "creature", "guardian"],
                specialty: "slowing attacks"
            },
            6: {
                name: "The Corrupted Grove",
                description: "Twisted flora and foul magic permeate the air.",
                color: "#8b5cf6",
                enemies: ["creature", "cultist", "mage", "beast", "knight"],
                specialty: "curse abilities"
            },
            7: {
                name: "Void Rift Chambers",
                description: "Reality warps and bends around swirling darkness.",
                color: "#3b0764",
                enemies: ["wraith", "creature", "specter", "entity", "horror"],
                specialty: "evasion and chaos"
            },
            8: {
                name: "The Abyssal Depths",
                description: "An endless abyss stretches below. Ancient horrors lurk here.",
                color: "#1e1b4b",
                enemies: ["horror", "entity", "leviathan", "titan", "overlord"],
                specialty: "massive damage"
            },
            9: {
                name: "The Obsidian Throne",
                description: "Dark energy crackles around a massive throne of shadow.",
                color: "#0f172a",
                enemies: ["overlord", "tyrant", "lord", "sovereign", "deity"],
                specialty: "multiple abilities"
            },
            10: {
                name: "The Goblin King's Throne",
                description: "The source of all darkness. The Goblin King awaits.",
                color: "#dc2626",
                enemies: ["GOBLIN KING"],
                specialty: "ultimate power"
            }
        };

        // --- BOSS ABILITIES SYSTEM ---
        const BOSS_ABILITIES = {
            // Ability structure: { name, description, trigger_hp_percent, effect_function }
            phase_shift: {
                name: "Phase Shift",
                description: "Boss phases out and recovers health!",
                effect: function() {
                    const heal = Math.floor(combatData.maxHP * 0.2);
                    combatData.HP = Math.min(combatData.HP + heal, combatData.maxHP);
                    addLog(`The boss phases out and recovers ${heal} HP!`, "text-purple-400 font-bold");
                }
            },
            multi_attack: {
                name: "Multi-Strike",
                description: "Boss attacks multiple times in succession!",
                effect: async function() {
                    addLog("The boss winds up for a devastating combo!", "text-red-500 font-bold");
                    await sleep(200);
                    const numAttacks = 3;
                    for (let i = 0; i < numAttacks; i++) {
                        const roll = Math.floor(Math.random()*20)+1 + combatData.strength;
                        const ac = stats.armor + stats.temporary_armor;
                        if (roll >= ac) {
                            let dmg = Math.floor(Math.random()*8)+2;
                            stats.HP -= dmg;
                            addLog(`[Hit ${i+1}/3] Took ${dmg} damage!`, "text-red-600");
                        } else {
                            addLog(`[Miss ${i+1}/3] Dodged!`, "text-green-400");
                        }
                        await sleep(200);
                    }
                    if (stats.HP <= 0) {
                        updateUI();
                        return false; // Handled by caller
                    }
                    updateUI();
                }
            },
            stun_attack: {
                name: "Stunning Strike",
                description: "Boss stunning attack! You lose a turn!",
                effect: async function() {
                    const roll = Math.floor(Math.random()*20)+1 + combatData.strength;
                    const ac = stats.armor + stats.temporary_armor;
                    addLog("The boss attempts a devastating strike!", "text-orange-500 font-bold");
                    await sleep(200);
                    if (roll >= ac) {
                        let dmg = Math.floor(Math.random()*12)+4;
                        stats.HP -= dmg;
                        addLog(`YOU WERE STUNNED! Took ${dmg} damage!`, "text-red-600 font-black");
                        addLog("Your next attack will be skipped!", "text-yellow-500 font-bold");
                        stats.stunned = true;
                        await sleep(400);
                    } else {
                        addLog("You narrowly avoid the stun!", "text-green-400");
                    }
                    updateUI();
                }
            },
            power_surge: {
                name: "Power Surge",
                description: "Boss gains increased strength!",
                effect: function() {
                    combatData.attack += 2;
                    combatData.strength += 3;
                    addLog("The boss surges with dark energy!", "text-red-500 font-bold");
                    addLog(`Attack increased! (now ${combatData.attack})`, "text-red-400");
                }
            },
            dark_blessing: {
                name: "Dark Blessing",
                description: "Boss gains increased defense!",
                effect: function() {
                    combatData.armor += 3;
                    addLog("The boss gains a protective aura!", "text-purple-400 font-bold");
                    addLog(`Armor increased! (now ${combatData.armor})`, "text-purple-400");
                }
            },
            freeze_field: {
                name: "Freeze Field",
                description: "Boss encases area in ice, reducing your damage!",
                effect: function() {
                    stats.frozen_field = 3; // Lasts 3 of player's turns
                    addLog("The boss creates a freeze field around you!", "text-cyan-400 font-bold");
                    addLog("Your damage will be reduced for the next 3 turns!", "text-cyan-400");
                }
            },
            drain_life: {
                name: "Drain Life",
                description: "Boss steals your health!",
                effect: function() {
                    const damage = Math.floor(Math.random()*10)+5;
                    stats.HP -= damage;
                    combatData.HP = Math.min(combatData.HP + damage, combatData.maxHP);
                    addLog(`The boss drains ${damage} HP from you!`, "text-purple-500 font-bold");
                    addLog(`The boss recovers ${damage} HP!`, "text-red-400");
                    updateUI();
                }
            },
            summon_minion: {
                name: "Summon Minion",
                description: "Boss summons an ally to aid in battle!",
                effect: function() {
                    combatData.minion_hp = Math.floor(Math.random()*20)+10;
                    addLog("The boss summons a dark minion to aid it!", "text-red-500 font-bold");
                    addLog(`Minion HP: ${combatData.minion_hp}`, "text-red-400");
                }
            }
        };

        // Function to determine if boss uses ability
        function bossShouldUseAbility(type, hpPercent) {
            // Boss-type specific abilities
            if (type === 'boss') {
                if (hpPercent < 0.3) return Math.random() < 0.6; // 60% at low health
                if (hpPercent < 0.6) return Math.random() < 0.4; // 40% at mid health
                return Math.random() < 0.2; // 20% at high health
            } else if (type === 'mini') {
                if (hpPercent < 0.4) return Math.random() < 0.4;
                return Math.random() < 0.15;
            } else if (type === 'lichking') {
                if (hpPercent < 0.2) return Math.random() < 0.8; // Very aggressive at low health
                if (hpPercent < 0.5) return Math.random() < 0.6;
                return Math.random() < 0.3;
            }
            return false;
        }

        // Function to get themed abilities based on floor specialty
        function getThemedBossAbilities(specialty) {
            const specialtyAbilities = {
                'weak but numerous': ['multi_attack', 'power_surge'],
                'disease and poison': ['stun_attack', 'drain_life'],
                'high armor': ['dark_blessing', 'power_surge'],
                'fire damage': ['multi_attack', 'power_surge'],
                'slowing attacks': ['freeze_field', 'stun_attack'],
                'curse abilities': ['drain_life', 'dark_blessing'],
                'evasion and chaos': ['phase_shift', 'multi_attack'],
                'massive damage': ['multi_attack', 'power_surge', 'stun_attack'],
                'multiple abilities': ['phase_shift', 'multi_attack', 'power_surge', 'dark_blessing']
            };
            return specialtyAbilities[specialty] || ['phase_shift', 'multi_attack', 'power_surge', 'dark_blessing'];
        }

        // Function to get available abilities for a specific boss type
        function getAvailableAbilities(type) {
            // Check if this boss has themed abilities
            if (combatData && combatData.themedAbilities) {
                return combatData.themedAbilities;
            }
            
            const abilityMap = {
                'boss': ['phase_shift', 'multi_attack', 'power_surge', 'dark_blessing'],
                'mini': ['power_surge', 'stun_attack', 'dark_blessing'],
                'lichking': ['phase_shift', 'multi_attack', 'drain_life', 'power_surge', 'dark_blessing', 'freeze_field', 'summon_minion']
            };
            return abilityMap[type] || [];
        }

        // --- DUNGEON ---
        function generateMonsterName(type) {
            const wanderingNames = [
                'Wandering Goblin', 'Wandering Orc', 'Wandering Bandit', 'Wandering Skeleton',
                'Wandering Troll', 'Wandering Zombie', 'Wandering Wraith', 'Wandering Ghoul',
                'Wandering Brigand', 'Wandering Specter', 'Wandering Shadow', 'Wandering Beast'
            ];
            
            const normalNames = [
                'Forest Goblin', 'Stone Golem', 'Giant Rat', 'Dark Knight',
                'Cursed Warrior', 'Shadow Mage', 'Plague Zombie', 'Ice Elemental',
                'Fire Imp', 'Void Creature', 'Twisted Beast', 'Corrupt Cultist',
                'Frostbite Spider', 'Acid Slime', 'Blood Knight', 'Chaos Thrall'
            ];
            
            const miniNames = [
                'Warlord Kex', 'Sorcerer Malach', 'Guardian Vex', 'Dread Knight Thorne',
                'Plague Master', 'Void Caller', 'Storm Tyrant', 'Shadow Lord',
                'Infernal Protector', 'Cursed Champion', 'Abomination King', 'Lich Keeper'
            ];
            
            const bossNames = [
                'ANCIENT DRAGON', 'DARK LORD', 'VOID EMPRESS', 'CHAOS TYRANT',
                'SHADOW SOVEREIGN', 'ABYSSAL OVERLORD', 'CORRUPTED TITAN', 'NIGHTMARE KING',
                'ETERNAL WRAITH', 'INFERNAL DEITY', 'COSMIC HORROR', 'DREAD LEVIATHAN'
            ];
            
            if (type === 'wandering') {
                return wanderingNames[Math.floor(Math.random() * wanderingNames.length)];
            } else if (type === 'normal') {
                return normalNames[Math.floor(Math.random() * normalNames.length)];
            } else if (type === 'mini') {
                return miniNames[Math.floor(Math.random() * miniNames.length)];
            } else if (type === 'boss') {
                return bossNames[Math.floor(Math.random() * bossNames.length)];
            }
            return "Unknown Monster";
        }

        function generateThemedBossName(floor) {
            const theme = FLOOR_THEMES[floor] || FLOOR_THEMES[1];
            const bossNames = {
                1: ['Goblin Chieftain', 'Goblin Warlord', 'Goblin King', 'Goblin Overlord'],
                2: ['Rat King', 'Plague Lord', 'Vermin Tyrant', 'Disease Master'],
                3: ['Stone Guardian', 'Petrified Colossus', 'Granite Warden', 'Rock Titan'],
                4: ['Infernal Lord', 'Flame Tyrant', 'Lava Overlord', 'Fire Demon King'],
                5: ['Frost King', 'Ice Sovereign', 'Glacial Warden', 'Arctic Tyrant'],
                6: ['Corruption Master', 'Twisted Lord', 'Blight Sovereign', 'Cursed Overlord'],
                7: ['Void Master', 'Rift Warden', 'Chaos Sovereign', 'Reality Breaker'],
                8: ['Abyssal Horror', 'Depth Tyrant', 'Leviathan King', 'Abyss Overlord'],
                9: ['Shadow Sovereign', 'Obsidian Lord', 'Dark Tyrant', 'Void Emperor']
            };
            
            const names = bossNames[floor] || ['Ancient Guardian', 'Floor Master', 'Dungeon Lord'];
            return names[Math.floor(Math.random() * names.length)];
        }

        function generateMonsterStats(type) {
            // Scale difficulty with both floor and player level
            let floorMultiplier = 1 + (stats.floor - 1) * 0.20; // Each floor +20%
            
            // Level scaling: Much easier at level 1, gradually increases
            let levelMultiplier;
            if (stats.level === 1) {
                levelMultiplier = 0.6; // Level 1: 60% difficulty (much easier)
            } else if (stats.level === 2) {
                levelMultiplier = 0.75; // Level 2: 75% difficulty
            } else if (stats.level === 3) {
                levelMultiplier = 0.9; // Level 3: 90% difficulty
            } else {
                // Level 4+: 100% + 15% per level above 3
                levelMultiplier = 1.0 + (stats.level - 4) * 0.15;
            }
            
            let diffMultiplier = floorMultiplier * levelMultiplier;
            
            let mStats = {};
            if (type === 'wandering') {
                mStats = {
                    HP: 0, 
                    armor: Math.floor((Math.floor(Math.random()*3)+10) * diffMultiplier),
                    attack: Math.floor((Math.floor(Math.random()*3)+2) * diffMultiplier),
                    strength: Math.floor((Math.floor(Math.random()*3)+1) * diffMultiplier),
                    dexterity: Math.floor((Math.floor(Math.random()*4)+9) * diffMultiplier),
                    change_strength: false, freeze: 0, fire: false
                };
                for(let i=0; i<4; i++) mStats.HP += Math.floor((Math.floor(Math.random()*4)+2) * diffMultiplier);
            } else if (type === 'normal') {
                mStats = {
                    HP: Math.floor((Math.floor(Math.random()*12)+Math.floor(Math.random()*12)+Math.floor(Math.random()*12)+15) * diffMultiplier),
                    armor: Math.floor((Math.floor(Math.random()*3)+13) * diffMultiplier),
                    attack: Math.floor((Math.floor(Math.random()*3)+3) * diffMultiplier),
                    strength: Math.floor((Math.floor(Math.random()*3)+2) * diffMultiplier),
                    dexterity: Math.floor((Math.floor(Math.random()*4)+11) * diffMultiplier),
                    change_strength: false, freeze: 0, fire: false
                };
            } else if (type === 'mini') {
                mStats = {
                    HP: Math.floor((Math.floor(Math.random()*25)+70) * diffMultiplier),
                    armor: Math.floor((Math.floor(Math.random()*3)+16) * diffMultiplier),
                    attack: Math.floor((Math.floor(Math.random()*3)+5) * diffMultiplier),
                    strength: Math.floor((Math.floor(Math.random()*3)+4) * diffMultiplier),
                    dexterity: Math.floor((Math.floor(Math.random()*4)+13) * diffMultiplier),
                    change_strength: false, freeze: 0, fire: false,
                    type: 'mini',
                    maxHP: 0  // Will be set after all stats
                };
                for(let i=0; i<5; i++) mStats.HP += Math.floor((Math.floor(Math.random()*8)+4) * diffMultiplier);
                mStats.maxHP = mStats.HP;
            } else if (type === 'boss') {
                mStats = {
                    HP: 0, 
                    armor: Math.floor((Math.floor(Math.random()*4)+18) * diffMultiplier),
                    attack: Math.floor((Math.floor(Math.random()*3)+6) * diffMultiplier),
                    strength: Math.floor((Math.floor(Math.random()*4)+5) * diffMultiplier),
                    dexterity: Math.floor((Math.floor(Math.random()*5)+15) * diffMultiplier),
                    change_strength: false, freeze: 0, fire: false,
                    type: 'boss',
                    maxHP: 0  // Will be set after all stats
                };
                for(let i=0; i<25; i++) mStats.HP += Math.floor((Math.floor(Math.random()*6)+2) * diffMultiplier);
                mStats.maxHP = mStats.HP;
            }
            return mStats;
        }

        function generateRoom(row, col) {
            let val = 10000000;
            
            // Make starting room (9,9) on floor 1 completely safe
            if (row === 9 && col === 9 && stats.floor === 1) {
                return val; // Empty safe room
            }
            
            const r1 = Math.floor(Math.random()*5)+1; // Reduced chest chance (20%)
            if (r1 === 1) { // Chest
                if(Math.floor(Math.random()*4)+1 === 1) val += 10;
                else val += 1;
            }
            const r2 = Math.floor(Math.random()*5)+1; // Reduced monster chance (20%)
            if (r2 === 1) { // Monster
                if(Math.floor(Math.random()*3)+1 === 1) {
                    val += 1000;
                    const w = generateMonsterStats('wandering');
                    w.name = generateMonsterName('wandering');
                    monsterData[`${row},${col},${stats.floor}`] = w;
                } else {
                    val += 100;
                    const m = generateMonsterStats('normal');
                    m.name = generateMonsterName('normal');
                    monsterData[`${row},${col},${stats.floor}`] = m;
                }
            }
            // Bosses and stairs are now placed by enterDungeon, not randomly here
            // Mini-bosses can still spawn randomly
            if (Math.floor(Math.random()*25)+1 === 1) {
                val += 100000;
                const mm = generateMonsterStats('mini');
                mm.name = generateMonsterName('mini');
                mm.type = 'mini';
                monsterData[`${row},${col},${stats.floor}`] = mm;
            }
            // Shopkeeper chance (10% per room, but only on floors 1-9)
            if (stats.floor <= 9 && Math.floor(Math.random()*10)+1 === 1) {
                val += 100000000; // Shopkeeper marker (highest value to prioritize)
                const merchantInfo = getMerchantInfo(stats.floor);
                const merchantInventory = generateMerchantInventory(stats.floor);
                const shopData = {
                    floor: stats.floor,
                    row: row,
                    col: col,
                    name: merchantInfo.name,
                    greeting: merchantInfo.greeting,
                    inventory: merchantInventory
                };
                monsterData[`shop_${row},${col},${stats.floor}`] = shopData;
            }
            return val;
        }

        function generateLichKing() {
            // The final boss scales with player level significantly
            let levelMultiplier = 1 + (stats.level - 1) * 0.2;
            const hp = Math.floor(150 * levelMultiplier);
            return {
                HP: hp,
                maxHP: hp,
                armor: Math.floor(20 * levelMultiplier),
                attack: Math.floor(8 * levelMultiplier),
                strength: Math.floor(8 * levelMultiplier),
                dexterity: Math.floor(16 * levelMultiplier),
                name: 'THE GOBLIN KING',
                type: 'lichking',
                change_strength: false, freeze: 0, fire: false
            };
        }

        function enterDungeon() {
            // Special handling for floor 10 - The Goblin King's throne
            if (stats.floor === 10) {
                const theme = FLOOR_THEMES[10];
                addLog(`===== ${theme.name} =====`, 'text-red-600 font-black text-lg');
                addLog(theme.description, 'text-red-500 italic');
                addLog('You have reached the deepest depths of the dungeon...', 'text-red-500 font-bold');
                addLog('Before you stands THE GOBLIN KING, an ancient evil incarnate!', 'text-red-600 font-black text-lg');
                const lichKing = generateLichKing();
                monsterData['lichking'] = lichKing;
                setTimeout(() => showPreCombatSavePrompt('THE GOBLIN KING', 'lichking'), 500);
                return;
            }
            
            const theme = FLOOR_THEMES[stats.floor] || FLOOR_THEMES[1];
            addLog(`===== FLOOR ${stats.floor}: ${theme.name} =====`, 'text-cyan-400 font-bold text-lg');
            addLog(theme.description, 'text-cyan-300 italic');
            
            const floorKey = `floor_${stats.floor}`;
            if(!floorMaps[floorKey]) {
                // Generate all rooms first
                floorMaps[floorKey] = Array.from({length:10}, (_, row) => 
                    Array.from({length:10}, (_, col) => generateRoom(row, col))
                );
                
                // Place exactly one boss per floor (not in starting room on floor 1)
                let bossPlaced = false;
                while (!bossPlaced) {
                    const bossRow = Math.floor(Math.random() * 10);
                    const bossCol = Math.floor(Math.random() * 10);
                    if (stats.floor === 1 && bossRow === 9 && bossCol === 9) continue; // Skip starting room
                    
                    const bossKey = `${bossRow},${bossCol},${stats.floor}`;
                    if (!monsterData[bossKey] || monsterData[bossKey].type !== 'boss') {
                        floorMaps[floorKey][bossRow][bossCol] += 1000000; // Add boss marker
                        const boss = generateMonsterStats('boss');
                        boss.name = generateThemedBossName(stats.floor);
                        boss.type = 'boss';
                        // Assign themed abilities based on floor specialty
                        const theme = FLOOR_THEMES[stats.floor] || FLOOR_THEMES[1];
                        boss.themedAbilities = getThemedBossAbilities(theme.specialty);
                        monsterData[bossKey] = boss;
                        bossPlaced = true;
                    }
                }
                
                // Place exactly one staircase per floor (not in starting room on floor 1, not in boss room)
                let stairsPlaced = false;
                while (!stairsPlaced) {
                    const stairsRow = Math.floor(Math.random() * 10);
                    const stairsCol = Math.floor(Math.random() * 10);
                    if (stats.floor === 1 && stairsRow === 9 && stairsCol === 9) continue; // Skip starting room
                    
                    const stairsKey = `${stairsRow},${stairsCol},${stats.floor}`;
                    const val = String(floorMaps[floorKey][stairsRow][stairsCol]).padStart(9, '0');
                    if (val[2] !== '1') { // Not in boss room
                        floorMaps[floorKey][stairsRow][stairsCol] += 10000; // Add stairs marker
                        stairsPlaced = true;
                    }
                }
            }
            // Only reset to [9,9] if entering from town (floor 1 and no current position set)
            if (stats.floor === 1 && (currentRoom[0] !== 9 || currentRoom[1] !== 9)) {
                currentRoom = [9, 9];
            }
            showView('view-dungeon');
            renderDungeon();
            checkRoom(false, true);  // Entering dungeon - can spawn wandering monsters
        }

        function renderDungeon() {
            const mapEl = document.getElementById('mini-map');
            mapEl.innerHTML = '';
            const floorKey = `floor_${stats.floor}`;
            
            for(let r=0; r<10; r++) {
                for(let c=0; c<10; c++) {
                    const isPlayer = r===currentRoom[0] && c===currentRoom[1];
                    const cell = document.createElement('div');
                    
                    // Default styling
                    let bgColor = 'bg-slate-800';
                    let icon = '';
                    
                    // If player has map, show special room markers based on enabled layers
                    if (stats.hasMap && floorMaps[floorKey]) {
                        const val = String(floorMaps[floorKey][r][c]).padStart(9, '0');
                        const shopKey = `shop_${r},${c},${stats.floor}`;
                        const entryPoint = stats.stairEntryPoints[stats.floor];
                        const hasUpStairs = entryPoint && r === entryPoint.row && c === entryPoint.col;
                        
                        // Collect all features in this room based on active map layers
                        let features = [];
                        
                        // Check for stairs (if layer enabled)
                        if (stats.mapLayers.stairs) {
                            if (val[4] === '1') features.push({icon: '‚¨á', color: 'bg-green-700'});
                            if (hasUpStairs) features.push({icon: '‚¨Ü', color: 'bg-blue-600'});
                        }
                        
                        // Check for bosses (if layer enabled)
                        if (stats.mapLayers.bosses && val[2] === '1') {
                            features.push({icon: 'üëë', color: 'bg-red-700'});
                        }
                        
                        // Check for mini-bosses (if layer enabled)
                        if (stats.mapLayers.miniBosses && val[3] === '1') {
                            features.push({icon: '‚öî', color: 'bg-orange-700'});
                        }
                        
                        // Check for merchants (if layer enabled)
                        if (stats.mapLayers.merchants && monsterData[shopKey]) {
                            features.push({icon: 'üì¶', color: 'bg-amber-700'});
                        }
                        
                        // Check for chests (if layer enabled)
                        if (stats.mapLayers.chests && (val[7] === '1' || val[8] === '1')) {
                            features.push({icon: 'üí∞', color: 'bg-yellow-600'});
                        }
                        
                        // Check for regular monsters (if layer enabled)
                        if (stats.mapLayers.monsters && (val[6] === '1' || val[5] === '1')) {
                            features.push({icon: 'üëπ', color: 'bg-purple-700'});
                        }
                        
                        // Show all features (up to 2 icons)
                        if (features.length > 0) {
                            // Use the first feature's color as background
                            bgColor = features[0].color;
                            // Combine icons
                            if (features.length === 1) {
                                icon = features[0].icon;
                            } else {
                                // Show first two icons
                                icon = features.slice(0, 2).map(f => f.icon).join('');
                            }
                        }
                    }
                    
                    // Player position overrides everything
                    if (isPlayer) {
                        bgColor = 'bg-blue-400 shadow-[0_0_10px_rgba(96,165,250,0.8)]';
                        icon = '';
                    }
                    
                    cell.className = `w-6 h-6 rounded ${bgColor} flex items-center justify-center text-xs`;
                    if (icon) {
                        cell.innerText = icon;
                    }
                    
                    // Make cell clickable if player has detailed map
                    if (stats.hasDetailedMap && !isPlayer) {
                        cell.style.cursor = 'pointer';
                        cell.onclick = () => inspectRoom(r, c);
                        cell.onmouseenter = () => {
                            if (!isPlayer) cell.style.opacity = '0.7';
                        };
                        cell.onmouseleave = () => {
                            cell.style.opacity = '1';
                        };
                    }
                    
                    mapEl.appendChild(cell);
                }
            }
        }

        function inspectRoom(row, col) {
            if (!stats.hasDetailedMap) return;
            
            const floorKey = `floor_${stats.floor}`;
            if (!floorMaps[floorKey]) return;
            
            const val = String(floorMaps[floorKey][row][col]).padStart(9, '0');
            const shopKey = `shop_${row},${col},${stats.floor}`;
            const monsterKey = `${row},${col},${stats.floor}`;
            
            // Build inspection content
            let content = [];
            
            // Check for merchant
            if (monsterData[shopKey]) {
                content.push({ type: 'Merchant', icon: 'üì¶', color: '#d97706' });
            }
            
            // Check for boss
            if (val[2] === '1') {
                const monster = monsterData[monsterKey];
                const name = monster ? monster.name : 'Boss';
                content.push({ type: 'Boss', icon: 'üëë', color: '#dc2626', detail: name });
            }
            
            // Check for mini-boss
            if (val[3] === '1') {
                const monster = monsterData[monsterKey];
                const name = monster ? monster.name : 'Mini-Boss';
                content.push({ type: 'Mini-Boss', icon: '‚öî', color: '#ea580c', detail: name });
            }
            
            // Check for wandering monster (position 5 = '1')
            if (val[5] === '1') {
                const monster = monsterData[monsterKey];
                const name = monster ? monster.name : 'Wandering Monster';
                content.push({ type: 'Monster', icon: 'üëæ', color: '#6b7280', detail: name });
            }
            // Check for normal monster (position 6 = '1')
            else if (val[6] === '1') {
                const monster = monsterData[monsterKey];
                const name = monster ? monster.name : 'Monster';
                content.push({ type: 'Monster', icon: 'üëæ', color: '#6b7280', detail: name });
            }
            
            // Check for stairs down
            if (val[4] === '1') {
                content.push({ type: 'Stairs Down', icon: '‚¨á', color: '#16a34a' });
            }
            
            // Check for stairs up
            const entryPoint = stats.stairEntryPoints[stats.floor];
            if (entryPoint && row === entryPoint.row && col === entryPoint.col) {
                content.push({ type: 'Stairs Up', icon: '‚¨Ü', color: '#2563eb' });
            }
            
            // Check for large chest
            if (val[7] === '1') {
                content.push({ type: 'Large Chest', icon: 'üì¶', color: '#eab308' });
            }
            
            // Check for small chest
            if (val[8] === '1') {
                content.push({ type: 'Small Chest', icon: 'üì¶', color: '#ca8a04' });
            }
            
            if (content.length === 0) {
                content.push({ type: 'Empty Room', icon: '¬∑', color: '#64748b' });
            }
            
            // Create modal
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.9);display:flex;align-items:center;justify-content:center;z-index:10000;';
            
            let html = '<div style="background:#1e293b;padding:2rem;border-radius:10px;max-width:400px;width:90%;border:2px solid #3b82f6;">';
            html += `<h2 style="font-size:1.3rem;font-weight:bold;margin-bottom:1rem;text-align:center;color:#60a5fa;">Room Inspection</h2>`;
            html += `<div style="font-size:0.9rem;color:#94a3b8;text-align:center;margin-bottom:1rem;">Floor ${stats.floor} - Position (${row}, ${col})</div>`;
            html += '<div style="background:#0f172a;padding:1rem;border-radius:8px;margin-bottom:1.5rem;border:1px solid #334155;">';
            
            content.forEach(item => {
                html += `<div style="display:flex;align-items:center;gap:1rem;padding:0.5rem;border-bottom:1px solid #1e293b;">`;
                html += `<div style="font-size:1.5rem;">${item.icon}</div>`;
                html += `<div style="flex:1;">`;
                html += `<div style="font-weight:bold;color:${item.color};">${item.type}</div>`;
                if (item.detail) {
                    html += `<div style="font-size:0.85rem;color:#94a3b8;">${item.detail}</div>`;
                }
                html += `</div></div>`;
            });
            
            html += '</div>';
            html += '<button onclick="closeInspectionModal()" style="width:100%;padding:0.75rem;background:#64748b;border-radius:8px;font-weight:bold;color:white;cursor:pointer;border:none;">CLOSE</button>';
            html += '</div>';
            
            modal.innerHTML = html;
            modal.id = 'inspection-modal';
            document.body.appendChild(modal);
        }

        function closeInspectionModal() {
            const modal = document.getElementById('inspection-modal');
            if (modal) modal.remove();
        }

        function movePlayer(dr, dc) {
            if (isProcessing) return;
            // Block movement if any modal is open
            if (document.getElementById('pre-combat-modal') || document.getElementById('quick-save-modal') || document.getElementById('load-modal') || document.getElementById('save-modal')) {
                return;
            }
            const nr = currentRoom[0] + dr, nc = currentRoom[1] + dc;
            if(nr >= 0 && nr < 10 && nc >= 0 && nc < 10) {
                currentRoom = [nr, nc];
                renderDungeon();
                updateUI();
                checkRoom(false, true);  // Entering new room - can spawn wandering monsters
            }
        }

        function checkRoom(suppressEvents = false, isEnteringRoom = false) {
            if(suppressEvents) return;
            const floorKey = `floor_${stats.floor}`;
            const val = String(floorMaps[floorKey][currentRoom[0]][currentRoom[1]]).padStart(9, '0');
            const act = document.getElementById('room-actions');
            act.innerHTML = '';

            // Check for shopkeeper first
            const shopKey = `shop_${currentRoom[0]},${currentRoom[1]},${stats.floor}`;
            if (monsterData[shopKey]) {
                const shopData = monsterData[shopKey];
                // Use stored shop data if available, otherwise generate new
                let shop;
                if (shopData.inventory) {
                    shop = {
                        name: shopData.name,
                        greeting: shopData.greeting,
                        inventory: shopData.inventory
                    };
                } else {
                    const merchantInfo = getMerchantInfo(stats.floor);
                    shop = {
                        name: merchantInfo.name,
                        greeting: merchantInfo.greeting,
                        inventory: generateMerchantInventory(stats.floor)
                    };
                    // Store it for future visits
                    shopData.name = shop.name;
                    shopData.greeting = shop.greeting;
                    shopData.inventory = shop.inventory;
                }
                const b = document.createElement('button');
                b.className = "px-6 py-3 bg-amber-700 hover:bg-amber-600 rounded text-sm font-bold uppercase";
                b.innerText = `üì¶ Talk to ${shop.name}`;
                b.onclick = () => showDungeonShop(shop);
                act.appendChild(b);
                
                const br = document.createElement('br');
                act.appendChild(br);
            }

            // Check for permanent room encounters
            const monsterKey = `${currentRoom[0]},${currentRoom[1]},${stats.floor}`;
            let hasMonster = false;
            
            // Check if there's already a permanent monster in this room
            const hasPermanentMonster = val[2] === '1' || val[3] === '1' || val[5] === '1' || val[6] === '1';
            
            if (val[2] === '1') {
                const name = monsterData[monsterKey] && monsterData[monsterKey].name ? monsterData[monsterKey].name : generateMonsterName('boss');
                showPreCombatSavePrompt(name, 'boss');
                hasMonster = true;
            } else if (val[3] === '1') {
                const name = monsterData[monsterKey] && monsterData[monsterKey].name ? monsterData[monsterKey].name : generateMonsterName('mini');
                showPreCombatSavePrompt(name, 'mini');
                hasMonster = true;
            } else if (val[5] === '1') {
                // Pre-placed wandering monster
                const name = monsterData[monsterKey] && monsterData[monsterKey].name ? monsterData[monsterKey].name : generateMonsterName('wandering');
                showPreCombatSavePrompt(name, 'wandering');
                hasMonster = true;
            } else if (val[6] === '1') {
                const name = monsterData[monsterKey] && monsterData[monsterKey].name ? monsterData[monsterKey].name : generateMonsterName('normal');
                showPreCombatSavePrompt(name, 'normal');
                hasMonster = true;
            } else if (isEnteringRoom && Math.random() < 0.25 && !(currentRoom[0] === 9 && currentRoom[1] === 9 && stats.floor === 1)) {
                // Random wandering monster spawn ONLY when entering room (25% chance)
                // Can spawn in rooms with chests or merchants, as long as there's no predetermined monster
                
                // Only spawn if no existing predetermined monster
                if (!hasPermanentMonster) {
                    const name = generateMonsterName('wandering');
                    showPreCombatSavePrompt(name, 'wandering');
                    hasMonster = true;
                }
            }
            
            // If there's a monster, don't show other room features yet
            if (hasMonster) return;
            
            // Show chests and other room features
            if (val[7] === '1') createChestBtn(act, true);
            if (val[8] === '1') createChestBtn(act, false);
            
            // Stairs Down (requires key first time only)
            if (val[4] === '1') {
                const stairKey = `${stats.floor},${currentRoom[0]},${currentRoom[1]}`;
                const isUnlocked = stats.unlockedStairs.has(stairKey);
                
                const b = document.createElement('button');
                if (isUnlocked || stats.keys > 0) {
                    b.className = "px-6 py-3 bg-blue-700 hover:bg-blue-600 rounded text-sm font-bold uppercase";
                    b.innerText = isUnlocked ? `Stairs Down` : `Stairs Down (Use Key)`;
                    b.onclick = () => {
                        if (!isUnlocked) {
                            stats.keys--;
                            stats.unlockedStairs.add(stairKey);
                            addLog(`Used a key to unlock the stairs!`, "text-yellow-400 font-bold");
                        }
                        
                        // Save the current room position as the entry point for the next floor
                        const entryRow = currentRoom[0];
                        const entryCol = currentRoom[1];
                        
                        stats.floor++;
                        
                        // Set the entry point for the new floor (this is where the up stairs will be)
                        stats.stairEntryPoints[stats.floor] = {row: entryRow, col: entryCol};
                        
                        addLog(`Descending to Floor ${stats.floor}...`, "text-blue-400 font-bold");
                        
                        // Show floor introduction if first time visiting this floor
                        if (!stats.visitedFloors) stats.visitedFloors = new Set();
                        if (!stats.visitedFloors.has(stats.floor) && FLOOR_THEMES[stats.floor]) {
                            stats.visitedFloors.add(stats.floor);
                            const theme = FLOOR_THEMES[stats.floor];
                            setTimeout(() => {
                                addLog(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`, "text-gray-500");
                                addLog(`${theme.name}`, "text-yellow-400 font-black text-xl");
                                addLog(`${theme.description}`, "text-gray-300 italic");
                                addLog(`Specialty: ${theme.specialty}`, theme.color + " font-bold");
                                addLog(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`, "text-gray-500");
                            }, 100);
                        }
                        updateUI();
                        
                        // Generate floor if needed
                        const floorKey = `floor_${stats.floor}`;
                        if(!floorMaps[floorKey]) {
                            // Generate all rooms first
                            floorMaps[floorKey] = Array.from({length:10}, (_, row) => 
                                Array.from({length:10}, (_, col) => generateRoom(row, col))
                            );
                            
                            // Place exactly one boss per floor (not in starting room on floor 1)
                            let bossPlaced = false;
                            while (!bossPlaced) {
                                const bossRow = Math.floor(Math.random() * 10);
                                const bossCol = Math.floor(Math.random() * 10);
                                if (stats.floor === 1 && bossRow === 9 && bossCol === 9) continue; // Skip starting room
                                
                                const bossKey = `${bossRow},${bossCol},${stats.floor}`;
                                if (!monsterData[bossKey] || monsterData[bossKey].type !== 'boss') {
                                    floorMaps[floorKey][bossRow][bossCol] += 1000000; // Add boss marker
                                    const boss = generateMonsterStats('boss');
                                    boss.name = generateThemedBossName(stats.floor);
                                    boss.type = 'boss';
                                    monsterData[bossKey] = boss;
                                    bossPlaced = true;
                                }
                            }
                            
                            // Place exactly one staircase per floor (not in starting room on floor 1, not in boss room)
                            let stairsPlaced = false;
                            while (!stairsPlaced) {
                                const stairsRow = Math.floor(Math.random() * 10);
                                const stairsCol = Math.floor(Math.random() * 10);
                                if (stats.floor === 1 && stairsRow === 9 && stairsCol === 9) continue; // Skip starting room
                                
                                const stairsKey = `${stairsRow},${stairsCol},${stats.floor}`;
                                const val = String(floorMaps[floorKey][stairsRow][stairsCol]).padStart(9, '0');
                                if (val[2] !== '1') { // Not in boss room
                                    floorMaps[floorKey][stairsRow][stairsCol] += 10000; // Add stairs marker
                                    stairsPlaced = true;
                                }
                            }
                        }
                        
                        // Stay in same room position
                        showView('view-dungeon');
                        renderDungeon();
                        checkRoom(false, true);  // Entering new floor - can spawn wandering monsters
                    };
                } else {
                    b.className = "px-6 py-3 bg-slate-600 rounded text-sm font-bold uppercase opacity-50 cursor-not-allowed";
                    b.innerText = "Stairs Down (üîí Requires Key)";
                    b.disabled = true;
                }
                act.appendChild(b);
            }
            
            // Stairs Up (only show if not on floor 1 AND in the room where player came down)
            if (stats.floor > 1) {
                const entryPoint = stats.stairEntryPoints[stats.floor];
                if (entryPoint && currentRoom[0] === entryPoint.row && currentRoom[1] === entryPoint.col) {
                    const upBtn = document.createElement('button');
                    upBtn.className = "px-6 py-3 bg-green-700 hover:bg-green-600 rounded text-sm font-bold uppercase";
                    upBtn.innerText = "Stairs Up";
                    upBtn.onclick = () => {
                        stats.floor--;
                        addLog(`Ascending to Floor ${stats.floor}...`, "text-green-400 font-bold");
                        
                        // Stay in same room position
                        showView('view-dungeon');
                        renderDungeon();
                        checkRoom(false, true);  // Entering new floor - can spawn wandering monsters
                    };
                    act.appendChild(upBtn);
                }
            }
            
            // Checkpoint buttons
            const checkpointBtn = document.createElement('button');
            checkpointBtn.className = "px-6 py-3 bg-cyan-700 hover:bg-cyan-600 rounded text-sm font-bold uppercase";
            
            // Check if there's a checkpoint at current location
            let checkpointAtLocation = null;
            for (let cpName in stats.checkpoints) {
                const cp = stats.checkpoints[cpName];
                if (cp.floor === stats.floor && cp.row === currentRoom[0] && cp.col === currentRoom[1]) {
                    checkpointAtLocation = cpName;
                    break;
                }
            }
            
            if (checkpointAtLocation) {
                checkpointBtn.innerText = `‚úì ${checkpointAtLocation}`;
                checkpointBtn.disabled = true;
                checkpointBtn.className = "px-6 py-3 bg-green-700 rounded text-sm font-bold uppercase opacity-75";
            } else {
                checkpointBtn.innerText = `Set Checkpoint (${Object.keys(stats.checkpoints).length}/${stats.checkpointsPurchased})`;
                if (stats.checkpointsPurchased > Object.keys(stats.checkpoints).length) {
                    checkpointBtn.onclick = () => showCheckpointNamingDialog();
                } else {
                    checkpointBtn.disabled = true;
                    checkpointBtn.className = "px-6 py-3 bg-slate-700 rounded text-sm font-bold uppercase opacity-50 cursor-not-allowed";
                    checkpointBtn.innerText = "No Checkpoints Available (Buy One!)";
                }
            }
            act.appendChild(checkpointBtn);
            
            // Teleport to checkpoint button (if any checkpoints exist)
            if (Object.keys(stats.checkpoints).length > 0) {
                const teleportBtn = document.createElement('button');
                teleportBtn.className = "px-6 py-3 bg-purple-700 hover:bg-purple-600 rounded text-sm font-bold uppercase";
                teleportBtn.innerText = `Teleport to Checkpoint`;
                teleportBtn.onclick = () => showCheckpointTeleportDialog();
                act.appendChild(teleportBtn);
            }
        }

        function showCheckpointNamingDialog() {
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.9);display:flex;align-items:center;justify-content:center;z-index:10000;';
            
            let html = '<div style="background:#1e293b;padding:2rem;border-radius:10px;max-width:400px;width:90%;">';
            html += '<h2 style="font-size:1.3rem;font-weight:bold;margin-bottom:1rem;text-align:center;color:white;">NAME YOUR CHECKPOINT</h2>';
            html += '<div style="background:#0f172a;padding:1.5rem;border-radius:8px;margin-bottom:1rem;border:2px solid #334155;">';
            html += '<div style="font-size:0.9rem;color:#94a3b8;margin-bottom:0.5rem;">Enter a name for this checkpoint:</div>';
            html += '<input id="checkpoint-name-input" type="text" placeholder="e.g., Safe Room, Boss Arena..." style="width:100%;padding:0.75rem;background:#1e293b;border:2px solid #475569;border-radius:6px;color:white;font-size:0.95rem;outline:none;box-sizing:border-box;" />';
            html += '<div style="font-size:0.8rem;color:#64748b;margin-top:0.5rem;">Location: Floor ' + stats.floor + ' [' + currentRoom[0] + ',' + currentRoom[1] + ']</div>';
            html += '</div>';
            html += '<div style="display:flex;gap:0.75rem;">';
            html += '<button onclick="confirmCheckpointName()" style="flex:1;padding:0.75rem;background:#06b6d4;border-radius:8px;font-weight:bold;color:white;font-size:0.95rem;cursor:pointer;border:none;">SET CHECKPOINT</button>';
            html += '<button onclick="closeCheckpointDialog()" style="flex:1;padding:0.75rem;background:#64748b;border-radius:8px;font-weight:bold;color:white;font-size:0.95rem;cursor:pointer;border:none;">CANCEL</button>';
            html += '</div>';
            html += '</div>';
            
            modal.innerHTML = html;
            modal.id = 'checkpoint-naming-modal';
            document.body.appendChild(modal);
            
            setTimeout(() => {
                document.getElementById('checkpoint-name-input').focus();
            }, 100);
        }
        
        function confirmCheckpointName() {
            const name = document.getElementById('checkpoint-name-input').value.trim();
            if (name === '') {
                addLog('Please enter a checkpoint name!', 'text-red-400');
                return;
            }
            
            if (stats.checkpoints[name]) {
                addLog('A checkpoint with that name already exists!', 'text-red-400');
                return;
            }
            
            stats.checkpoints[name] = { floor: stats.floor, row: currentRoom[0], col: currentRoom[1] };
            addLog(`Checkpoint "${name}" set at Floor ${stats.floor} [${currentRoom[0]},${currentRoom[1]}]`, "text-cyan-400 font-bold");
            closeCheckpointDialog();
            checkRoom(false, false);  // After setting checkpoint - do NOT spawn wandering monsters
        }
        
        function closeCheckpointDialog() {
            const modal = document.getElementById('checkpoint-naming-modal');
            if (modal) modal.remove();
        }
        
        function showCheckpointTeleportDialog() {
            const checkpoints = Object.keys(stats.checkpoints);
            if (checkpoints.length === 0) {
                addLog('No checkpoints set!', 'text-red-400');
                return;
            }
            
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.9);display:flex;align-items:center;justify-content:center;z-index:10000;';
            
            let html = '<div style="background:#1e293b;padding:2rem;border-radius:10px;max-width:400px;width:90%;max-height:70vh;overflow-y:auto;">';
            html += '<h2 style="font-size:1.3rem;font-weight:bold;margin-bottom:1rem;text-align:center;color:white;">SELECT CHECKPOINT</h2>';
            
            checkpoints.forEach(cpName => {
                const cp = stats.checkpoints[cpName];
                html += `<button onclick="teleportToCheckpoint('${cpName}')" style="width:100%;padding:1rem;margin-bottom:0.75rem;background:#0f172a;border:2px solid #334155;border-radius:8px;color:white;text-align:left;cursor:pointer;transition:all 0.2s;font-weight:bold;font-size:0.95rem;">`;
                html += `<div style="color:#06b6d4;">${cpName}</div>`;
                html += `<div style="color:#94a3b8;font-size:0.85rem;margin-top:0.25rem;">Floor ${cp.floor} [${cp.row},${cp.col}]</div>`;
                html += `</button>`;
            });
            
            html += '<button onclick="closeTeleportDialog()" style="width:100%;padding:0.75rem;background:#64748b;border-radius:8px;font-weight:bold;color:white;font-size:0.95rem;cursor:pointer;border:none;margin-top:1rem;">CANCEL</button>';
            html += '</div>';
            
            modal.innerHTML = html;
            modal.id = 'checkpoint-teleport-modal';
            document.body.appendChild(modal);
        }
        
        function teleportToCheckpoint(cpName) {
            const cp = stats.checkpoints[cpName];
            
            if (cp.floor !== stats.floor) {
                stats.floor = cp.floor;
                addLog(`Teleporting to Floor ${stats.floor}...`, "text-purple-400 font-bold");
                closeTeleportDialog();
                enterDungeon();
            } else {
                currentRoom = [cp.row, cp.col];
                addLog(`Teleported to "${cpName}"!`, "text-purple-400 font-bold");
                closeTeleportDialog();
                renderDungeon();
                checkRoom(false, true);  // Teleporting to room - can spawn wandering monsters
            }
        }
        
        function closeTeleportDialog() {
            const modal = document.getElementById('checkpoint-teleport-modal');
            if (modal) modal.remove();
        }

        function showDungeonShop(shop) {
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.95);display:flex;align-items:center;justify-content:center;z-index:10000;';
            
            let html = '<div style="background:#1e293b;padding:2rem;border-radius:10px;max-width:500px;width:95%;max-height:70vh;overflow-y:auto;">';
            html += `<h2 style="font-size:1.3rem;font-weight:bold;margin-bottom:0.5rem;text-align:center;color:#fbbf24;">üè™ ${shop.name}</h2>`;
            html += `<p style="text-align:center;color:#94a3b8;margin-bottom:1.5rem;font-size:0.9rem;font-style:italic;">"${shop.greeting}"</p>`;
            html += '<div style="background:#0f172a;padding:1rem;border-radius:8px;border:2px solid #334155;margin-bottom:1rem;">';
            html += `<div style="color:#94a3b8;font-size:0.85rem;">Your Gold: <span style="color:#fbbf24;font-weight:bold;">${stats.coins}</span></div>`;
            html += '</div>';
            
            html += '<div style="max-height:350px;overflow-y:auto;" id="dungeon-shop-items">';
            const buttonData = []; // Store button data for event listeners
            
            for (let itemName in shop.inventory) {
                const itemData = shop.inventory[itemName];
                const cost = itemData[0];
                const itemType = itemData[1]; // 1=weapon, 2=armor, 3=potion, 0=special
                const bonusType = itemData[2]; // Base tier/AC or effect type
                const bonusValue = itemData[3]; // Bonus amount
                
                let typeLabel = '';
                let typeColor = '';
                let effectDesc = '';
                
                if (itemType === 1) {
                    typeLabel = '‚öîÔ∏è Weapon';
                    typeColor = '#ef4444';
                    // Check if bonusValue is a damage formula string
                    if (typeof bonusValue === 'string' && bonusValue.includes('d')) {
                        const attackBonus = bonusType || 0;
                        if (attackBonus > 0) {
                            effectDesc = `${bonusValue} damage, +${attackBonus} attack rolls`;
                        } else {
                            effectDesc = `${bonusValue} damage`;
                        }
                    } else if (typeof bonusValue === 'object' && bonusValue !== null && bonusValue.baseDamage) {
                        // Conditional damage bonus weapon
                        const attackBonus = bonusType || 0;
                        let condBonus = '';
                        if (bonusValue.type === 'lowHP') {
                            condBonus = `, +${bonusValue.bonus} dmg when HP ‚â§ ${bonusValue.threshold}`;
                        } else if (bonusValue.type === 'boss') {
                            condBonus = `, +${bonusValue.bonus} dmg vs bosses`;
                        } else if (bonusValue.type === 'miniBoss') {
                            condBonus = `, +${bonusValue.bonus} dmg vs mini-bosses/bosses`;
                        } else if (bonusValue.type === 'floor') {
                            condBonus = `, +${bonusValue.bonus} dmg per floor`;
                        } else if (bonusValue.type === 'floorParity') {
                            if (bonusValue.evenBonus > 0 && bonusValue.oddBonus > 0) {
                                condBonus = `, +${bonusValue.evenBonus}/${bonusValue.oddBonus} dmg (even/odd)`;
                            } else if (bonusValue.evenBonus > 0) {
                                condBonus = `, +${bonusValue.evenBonus} dmg on even floors`;
                            } else {
                                condBonus = `, +${bonusValue.oddBonus} dmg on odd floors`;
                            }
                        }
                        effectDesc = `${bonusValue.baseDamage} dmg, +${attackBonus} attack${condBonus}`;
                    } else {
                        const baseTier = bonusType || 2;
                        const val = bonusValue || 0;
                        if (val > 0) {
                            effectDesc = `Tier ${baseTier} base, +${val} attack rolls`;
                        } else {
                            effectDesc = `Tier ${baseTier} weapon`;
                        }
                    }
                } else if (itemType === 2) {
                    typeLabel = 'üõ°Ô∏è Armor';
                    typeColor = '#3b82f6';
                    const baseAC = bonusType || 10;
                    // Check if bonusValue is a conditional bonus object
                    if (typeof bonusValue === 'object' && bonusValue !== null && bonusValue.type) {
                        let conditionText = '';
                        if (bonusValue.type === 'lowHP') {
                            conditionText = `AC ${baseAC}, +${bonusValue.bonus} when HP ‚â§ ${bonusValue.threshold}`;
                        } else if (bonusValue.type === 'percentHP') {
                            const percent = Math.round(bonusValue.threshold * 100);
                            conditionText = `AC ${baseAC}, +${bonusValue.bonus} when HP ‚â§ ${percent}%`;
                        } else if (bonusValue.type === 'highHP') {
                            conditionText = `AC ${baseAC}, +${bonusValue.bonus} when HP ‚â• ${bonusValue.threshold}`;
                        } else if (bonusValue.type === 'coins') {
                            conditionText = `AC ${baseAC}, +${bonusValue.bonus} when gold ‚â• ${bonusValue.threshold}`;
                        } else if (bonusValue.type === 'boss') {
                            conditionText = `AC ${baseAC}, +${bonusValue.bonus} vs bosses`;
                        } else if (bonusValue.type === 'miniBoss') {
                            conditionText = `AC ${baseAC}, +${bonusValue.bonus} vs mini-bosses/bosses`;
                        } else if (bonusValue.type === 'floorParity') {
                            if (bonusValue.evenBonus > 0 && bonusValue.oddBonus > 0) {
                                conditionText = `AC ${baseAC}, +${bonusValue.evenBonus} on even floors, +${bonusValue.oddBonus} on odd`;
                            } else if (bonusValue.evenBonus > 0) {
                                conditionText = `AC ${baseAC}, +${bonusValue.evenBonus} on even floors`;
                            } else {
                                conditionText = `AC ${baseAC}, +${bonusValue.oddBonus} on odd floors`;
                            }
                        }
                        effectDesc = conditionText;
                    } else {
                        const val = bonusValue || 0;
                        if (val > 0) {
                            effectDesc = `AC ${baseAC} base, +${val} AC bonus`;
                        } else {
                            effectDesc = `AC ${baseAC} armor`;
                        }
                    }
                } else if (itemType === 3) {
                    typeLabel = 'üß™ Potion';
                    typeColor = '#10b981';
                    const val = bonusValue || 0;
                    if (bonusType === 1 || bonusType === 2) effectDesc = `+${val} to all rolls for 1 turn`;
                    else if (bonusType === 3 || bonusType === 5) effectDesc = `+${val} AC for 1 turn`;
                    else if (bonusType === 4 || bonusType === 6) effectDesc = `+${val} attack rolls for 1 turn`;
                    else if (bonusType === 7) effectDesc = `+${val} to all rolls for 1 turn`;
                    else effectDesc = 'Unique potion effect';
                } else if (itemType === 0 && bonusType === 5) {
                    typeLabel = 'üìç Special';
                    typeColor = '#06b6d4';
                    effectDesc = 'Set a checkpoint and teleport to it';
                } else {
                    // Fallback for unknown items
                    typeLabel = '‚ùì Item';
                    typeColor = '#94a3b8';
                    effectDesc = 'Unique dungeon item';
                }
                
                // Ensure effectDesc is always set
                if (!effectDesc) {
                    effectDesc = 'Unique item effect';
                }
                
                const canAfford = stats.coins >= cost;
                const itemIndex = buttonData.length;
                
                // Calculate durability for weapons
                let durabilityText = '';
                if (itemType === 1) {
                    let maxDur = WEAPON_DURABILITY[1];
                    if (typeof bonusValue === 'string' && bonusValue.includes('d')) {
                        if (bonusValue.includes('6d') || bonusValue.includes('5d')) {
                            maxDur = WEAPON_DURABILITY.custom_high;
                        } else if (bonusValue.includes('3d') || bonusValue.includes('4d')) {
                            maxDur = WEAPON_DURABILITY.custom_mid;
                        } else {
                            maxDur = WEAPON_DURABILITY.custom_low;
                        }
                    } else {
                        const tier = bonusType || 1;
                        maxDur = WEAPON_DURABILITY[tier] || WEAPON_DURABILITY[1];
                    }
                    const barColor = '#10b981';
                    durabilityText = `<div style="margin-top:0.5rem;position:relative;"><div style="width:100%;height:6px;background:#1e293b;border-radius:3px;overflow:hidden;border:1px solid #334155;" title="${maxDur}/${maxDur}"><div style="height:100%;width:100%;background:${barColor};transition:width 0.3s ease;"></div></div><div style="position:absolute;top:-20px;left:50%;transform:translateX(-50%);background:#0f172a;color:#fbbf24;padding:2px 6px;border-radius:3px;font-size:0.7rem;font-weight:bold;white-space:nowrap;border:1px solid #334155;opacity:0;pointer-events:none;transition:opacity 0.2s ease;" class="durability-tooltip">${maxDur}/${maxDur}</div></div>`;
                }
                
                html += '<div class="dungeon-shop-item-card" style="display:block;position:relative;padding:1rem;margin-bottom:1rem;background:#0f172a;border:2px solid #334155;border-radius:8px;min-height:1px;">';
                html += '<div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:0.5rem;">';
                html += '<div style="flex:1;min-width:0;">';
                html += `<div style="font-weight:bold;margin-bottom:0.25rem;color:white;">${itemName}</div>`;
                html += `<div style="color:#94a3b8;font-size:0.85rem;margin-bottom:0.25rem;"><span style="color:${typeColor};">${typeLabel}</span></div>`;
                html += `<div style="color:#10b981;font-size:0.8rem;font-weight:bold;">${effectDesc}</div>`;
                html += durabilityText;
                html += '</div>';
                html += '<div style="text-align:right;margin-left:1rem;flex-shrink:0;">';
                html += `<div style="color:#fbbf24;font-weight:bold;font-size:1.1rem;margin-bottom:0.5rem;">${cost}g</div>`;
                html += '</div>';
                html += '</div>';
                html += '<div style="display:flex;gap:0.5rem;margin-top:0.75rem;">';
                html += '<button type="button" class="dungeon-shop-view-btn" style="flex:1;padding:0.5rem 0.75rem;background:#3b82f6;border-radius:6px;font-weight:bold;color:white;font-size:0.85rem;cursor:pointer;border:none;">VIEW STATS</button>';
                html += '<button type="button" class="dungeon-shop-buy-btn" style="flex:1;padding:0.5rem 0.75rem;background:' + (canAfford ? '#10b981' : '#475569') + ';border-radius:6px;font-weight:bold;color:white;font-size:0.85rem;cursor:' + (canAfford ? 'pointer' : 'not-allowed') + ';border:none;opacity:' + (canAfford ? '1' : '0.7') + ';">BUY</button>';
                html += '</div>';
                html += '</div>';
                
                // Store button data for later - create a deep copy to prevent corruption
                const dataCopy = Array.isArray(itemData) ? [...itemData] : JSON.parse(JSON.stringify(itemData));
                // Ensure nested objects are properly copied
                if (Array.isArray(dataCopy) && typeof dataCopy[3] === 'object' && dataCopy[3] !== null) {
                    dataCopy[3] = JSON.parse(JSON.stringify(dataCopy[3]));
                }
                buttonData.push({ name: itemName, data: dataCopy, canAfford });
            }
            html += '</div>';
            
            html += '<button onclick="closeDungeonShop()" style="width:100%;padding:0.75rem;margin-top:1rem;background:#64748b;border-radius:8px;font-weight:bold;color:white;font-size:0.95rem;cursor:pointer;border:none;">LEAVE SHOP</button>';
            html += '</div>';
            
            modal.innerHTML = html;
            modal.id = 'dungeon-shop-modal';
            document.body.appendChild(modal);
            
            // Add hover listeners for durability tooltips
            const durabilityBars = modal.querySelectorAll('[title]');
            durabilityBars.forEach(bar => {
                const tooltip = bar.nextElementSibling;
                if (tooltip && tooltip.classList.contains('durability-tooltip')) {
                    bar.addEventListener('mouseenter', () => {
                        tooltip.style.opacity = '1';
                    });
                    bar.addEventListener('mouseleave', () => {
                        tooltip.style.opacity = '0';
                    });
                }
            });
            
            // Set up event listeners for all buttons
            const viewButtons = modal.querySelectorAll('.dungeon-shop-view-btn');
            const buyButtons = modal.querySelectorAll('.dungeon-shop-buy-btn');
            
            viewButtons.forEach((btn, index) => {
                if (buttonData[index]) {
                    btn.onclick = () => {
                        // Ensure we're passing the correct data and calling the RIGHT function
                        const itemData = buttonData[index].data;
                        // Make sure we're calling showDungeonItemStats, not showItemStats
                        showDungeonItemStats(buttonData[index].name, itemData);
                    };
                }
            });
            
            buyButtons.forEach((btn, index) => {
                if (buttonData[index] && buttonData[index].canAfford) {
                    btn.onclick = () => confirmDungeonPurchase(buttonData[index].name, buttonData[index].data);
                }
            });
        }
        
        function confirmDungeonPurchase(itemName, itemData) {
            // Close shop modal first
            closeDungeonShop();
            
            const cost = Array.isArray(itemData) ? itemData[0] : (itemData.cost || itemData[0] || 0);
            const itemType = Array.isArray(itemData) ? itemData[1] : (itemData.itemType || itemData[1] || 0);
            
            let itemTypeName = 'item';
            if (itemType === 1) itemTypeName = 'weapon';
            else if (itemType === 2) itemTypeName = 'armor';
            else if (itemType === 3) itemTypeName = 'potion';
            else if (itemType === 0) itemTypeName = 'special item';
            
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.9);display:flex;align-items:center;justify-content:center;z-index:10002;';
            
            let html = '<div style="background:#1e293b;padding:2rem;border-radius:10px;max-width:400px;width:90%;">';
            html += '<h2 style="font-size:1.3rem;font-weight:bold;margin-bottom:1rem;text-align:center;color:white;">CONFIRM PURCHASE</h2>';
            html += '<div style="background:#0f172a;padding:1.5rem;border-radius:8px;margin-bottom:1rem;border:2px solid #334155;">';
            html += `<div style="font-size:1.1rem;font-weight:bold;color:#fbbf24;text-align:center;margin-bottom:0.5rem;">${itemName}</div>`;
            html += `<div style="font-size:0.9rem;color:#94a3b8;text-align:center;margin-bottom:1rem;">${itemTypeName}</div>`;
            html += `<div style="font-size:1rem;color:#64748b;text-align:center;">Price: <span style="color:#fbbf24;font-weight:bold;">${cost} Gold</span></div>`;
            html += `<div style="font-size:0.9rem;color:#64748b;text-align:center;margin-top:0.5rem;">Your Gold: <span style="color:#fbbf24;font-weight:bold;">${stats.coins}</span></div>`;
            html += '</div>';
            html += '<div style="display:flex;gap:0.75rem;">';
            html += '<button id="confirm-dungeon-purchase-cancel" style="flex:1;padding:0.75rem;background:#64748b;border-radius:8px;font-weight:bold;color:white;font-size:0.95rem;cursor:pointer;border:none;">CANCEL</button>';
            html += '<button id="confirm-dungeon-purchase-buy" style="flex:1;padding:0.75rem;background:#10b981;border-radius:8px;font-weight:bold;color:white;font-size:0.95rem;cursor:pointer;border:none;">BUY</button>';
            html += '</div>';
            html += '</div>';
            
            modal.innerHTML = html;
            modal.id = 'confirm-dungeon-purchase-modal';
            document.body.appendChild(modal);
            
            document.getElementById('confirm-dungeon-purchase-cancel').onclick = () => {
                modal.remove();
                showDungeonShop({ name: 'Merchant', greeting: 'Welcome!', inventory: getCurrentMerchantInventory() });
            };
            
            document.getElementById('confirm-dungeon-purchase-buy').onclick = () => {
                modal.remove();
                buyDungeonItemFromData(itemName, itemData);
            };
        }
        
        function getCurrentMerchantInventory() {
            // Find the current merchant shop data
            const currentRoom = mapData[stats.floor][stats.dungeonY][stats.dungeonX];
            if (currentRoom && currentRoom.shop) {
                return currentRoom.shop.inventory;
            }
            return {};
        }
        
        function showDungeonItemDetails(itemName, itemData, shop) {
            const detailsModal = document.createElement('div');
            detailsModal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.95);display:flex;align-items:center;justify-content:center;z-index:10001;';
            
            const cost = itemData[0];
            const itemType = itemData[1];
            const bonusType = itemData[2];
            const bonusValue = itemData[3];
            
            let html = '<div style="background:#1e293b;padding:2rem;border-radius:10px;max-width:600px;width:95%;max-height:80vh;overflow-y:auto;">';
            html += '<h2 style="font-size:1.5rem;font-weight:bold;margin-bottom:1rem;text-align:center;color:#fbbf24;">ITEM DETAILS</h2>';
            html += '<div style="background:#0f172a;padding:1.5rem;border-radius:8px;margin-bottom:1rem;border:2px solid #334155;">';
            html += `<div style="font-size:1.3rem;font-weight:bold;color:white;text-transform:uppercase;margin-bottom:0.5rem;text-align:center;">${itemName}</div>`;
            html += `<div style="color:#fbbf24;font-size:1.2rem;font-weight:bold;text-align:center;margin-bottom:1rem;">${cost} Gold</div>`;
            html += '<div style="border-top:1px solid #334155;padding-top:1rem;">';
            
            if (itemType === 1) {
                // Weapon details
                html += '<div style="color:#ef4444;font-weight:bold;margin-bottom:1rem;font-size:1.1rem;">‚öîÔ∏è WEAPON</div>';
                
                if (typeof bonusValue === 'string' && bonusValue.includes('d')) {
                    html += `<div style="color:#10b981;font-weight:bold;font-size:1rem;margin-bottom:0.5rem;">Damage: ${bonusValue}</div>`;
                    const attackBonus = bonusType || 0;
                    if (attackBonus > 0) {
                        html += `<div style="color:#3b82f6;font-weight:bold;font-size:1rem;margin-bottom:0.5rem;">+${attackBonus} to attack rolls</div>`;
                    }
                } else if (typeof bonusValue === 'object' && bonusValue !== null && bonusValue.baseDamage) {
                    // Conditional damage bonus weapon
                    html += `<div style="color:#10b981;font-weight:bold;font-size:1rem;margin-bottom:0.5rem;">Base Damage: ${bonusValue.baseDamage}</div>`;
                    const attackBonus = bonusType || 0;
                    if (attackBonus > 0) {
                        html += `<div style="color:#3b82f6;font-weight:bold;font-size:1rem;margin-bottom:0.5rem;">+${attackBonus} to attack rolls</div>`;
                    }
                    
                    // Show conditional damage bonus
                    html += '<div style="background:#1e293b;padding:0.75rem;border-radius:6px;margin-top:0.75rem;border:1px solid #06b6d4;">';
                    html += '<div style="color:#06b6d4;font-weight:bold;margin-bottom:0.5rem;">‚ú® CONDITIONAL BONUS</div>';
                    if (bonusValue.type === 'lowHP') {
                        html += `<div style="color:#94a3b8;">+${bonusValue.bonus} damage when your HP ‚â§ ${bonusValue.threshold}</div>`;
                    } else if (bonusValue.type === 'boss') {
                        html += `<div style="color:#94a3b8;">+${bonusValue.bonus} damage when fighting bosses</div>`;
                    } else if (bonusValue.type === 'miniBoss') {
                        html += `<div style="color:#94a3b8;">+${bonusValue.bonus} damage when fighting mini-bosses or bosses</div>`;
                    } else if (bonusValue.type === 'floor') {
                        html += `<div style="color:#94a3b8;">+${bonusValue.bonus} damage per floor (currently +${bonusValue.bonus * stats.floor})</div>`;
                    } else if (bonusValue.type === 'floorParity') {
                        if (bonusValue.evenBonus > 0 && bonusValue.oddBonus > 0) {
                            html += `<div style="color:#94a3b8;">+${bonusValue.evenBonus} damage on even floors, +${bonusValue.oddBonus} on odd floors</div>`;
                        } else if (bonusValue.evenBonus > 0) {
                            html += `<div style="color:#94a3b8;">+${bonusValue.evenBonus} damage on even floors</div>`;
                        } else {
                            html += `<div style="color:#94a3b8;">+${bonusValue.oddBonus} damage on odd floors</div>`;
                        }
                    }
                    html += '</div>';
                } else {
                    const tier = bonusType || 1;
                    html += `<div style="color:#64748b;font-size:0.95rem;margin-bottom:0.5rem;">Tier: <span style="color:#fbbf24;font-weight:bold;">${tier}</span></div>`;
                    html += `<div style="color:#10b981;font-weight:bold;font-size:1rem;margin-bottom:0.5rem;">Damage: ${getWeaponDamageDesc(tier)}</div>`;
                    const attackBonus = bonusValue || 0;
                    if (attackBonus > 0) {
                        html += `<div style="color:#3b82f6;font-weight:bold;font-size:1rem;margin-bottom:0.5rem;">+${attackBonus} to attack rolls</div>`;
                    }
                }
                
                // Durability info
                let maxDur = WEAPON_DURABILITY[1];
                if (typeof bonusValue === 'string' && bonusValue.includes('d')) {
                    if (bonusValue.includes('6d') || bonusValue.includes('5d')) {
                        maxDur = WEAPON_DURABILITY.custom_high;
                    } else if (bonusValue.includes('3d') || bonusValue.includes('4d')) {
                        maxDur = WEAPON_DURABILITY.custom_mid;
                    } else {
                        maxDur = WEAPON_DURABILITY.custom_low;
                    }
                } else {
                    const tier = bonusType || 1;
                    maxDur = WEAPON_DURABILITY[tier] || WEAPON_DURABILITY[1];
                }
                html += `<div style="color:#94a3b8;font-size:0.9rem;margin-top:1rem;">Durability: ${maxDur}/${maxDur}</div>`;
                html += '<div style="font-size:0.85rem;color:#94a3b8;margin-top:1rem;font-style:italic;">Used for attacking enemies in combat. Higher tier weapons deal more damage.</div>';
                
            } else if (itemType === 2) {
                // Armor details
                html += '<div style="color:#3b82f6;font-weight:bold;margin-bottom:1rem;font-size:1.1rem;">üõ°Ô∏è ARMOR</div>';
                const baseAC = bonusType || 10;
                html += `<div style="color:#3b82f6;font-weight:bold;font-size:1.2rem;margin-bottom:0.5rem;">Base AC: ${baseAC}</div>`;
                
                if (typeof bonusValue === 'object' && bonusValue !== null && bonusValue.type) {
                    // Conditional AC bonus
                    html += '<div style="background:#1e293b;padding:0.75rem;border-radius:6px;margin-top:0.75rem;border:1px solid #06b6d4;">';
                    html += '<div style="color:#06b6d4;font-weight:bold;margin-bottom:0.5rem;">‚ú® CONDITIONAL BONUS</div>';
                    if (bonusValue.type === 'lowHP') {
                        html += `<div style="color:#94a3b8;">+${bonusValue.bonus} AC when your HP ‚â§ ${bonusValue.threshold}</div>`;
                        html += `<div style="color:#10b981;font-weight:bold;margin-top:0.5rem;">Max AC: ${baseAC + bonusValue.bonus}</div>`;
                    } else if (bonusValue.type === 'percentHP') {
                        const percent = Math.round(bonusValue.threshold * 100);
                        html += `<div style="color:#94a3b8;">+${bonusValue.bonus} AC when your HP ‚â§ ${percent}%</div>`;
                        html += `<div style="color:#10b981;font-weight:bold;margin-top:0.5rem;">Max AC: ${baseAC + bonusValue.bonus}</div>`;
                    } else if (bonusValue.type === 'highHP') {
                        html += `<div style="color:#94a3b8;">+${bonusValue.bonus} AC when your HP ‚â• ${bonusValue.threshold}</div>`;
                        html += `<div style="color:#10b981;font-weight:bold;margin-top:0.5rem;">Max AC: ${baseAC + bonusValue.bonus}</div>`;
                    } else if (bonusValue.type === 'coins') {
                        html += `<div style="color:#94a3b8;">+${bonusValue.bonus} AC when you have ‚â• ${bonusValue.threshold} gold</div>`;
                        html += `<div style="color:#10b981;font-weight:bold;margin-top:0.5rem;">Max AC: ${baseAC + bonusValue.bonus}</div>`;
                    } else if (bonusValue.type === 'boss') {
                        html += `<div style="color:#94a3b8;">+${bonusValue.bonus} AC when fighting bosses</div>`;
                        html += `<div style="color:#10b981;font-weight:bold;margin-top:0.5rem;">Max AC: ${baseAC + bonusValue.bonus}</div>`;
                    } else if (bonusValue.type === 'miniBoss') {
                        html += `<div style="color:#94a3b8;">+${bonusValue.bonus} AC when fighting mini-bosses or bosses</div>`;
                        html += `<div style="color:#10b981;font-weight:bold;margin-top:0.5rem;">Max AC: ${baseAC + bonusValue.bonus}</div>`;
                    } else if (bonusValue.type === 'floorParity') {
                        if (bonusValue.evenBonus > 0 && bonusValue.oddBonus > 0) {
                            html += `<div style="color:#94a3b8;">+${bonusValue.evenBonus} AC on even floors, +${bonusValue.oddBonus} AC on odd floors</div>`;
                            html += `<div style="color:#10b981;font-weight:bold;margin-top:0.5rem;">Max AC: ${baseAC + Math.max(bonusValue.evenBonus, bonusValue.oddBonus)}</div>`;
                        } else if (bonusValue.evenBonus > 0) {
                            html += `<div style="color:#94a3b8;">+${bonusValue.evenBonus} AC on even floors</div>`;
                            html += `<div style="color:#10b981;font-weight:bold;margin-top:0.5rem;">Max AC: ${baseAC + bonusValue.evenBonus}</div>`;
                        } else {
                            html += `<div style="color:#94a3b8;">+${bonusValue.oddBonus} AC on odd floors</div>`;
                            html += `<div style="color:#10b981;font-weight:bold;margin-top:0.5rem;">Max AC: ${baseAC + bonusValue.oddBonus}</div>`;
                        }
                    }
                    html += '</div>';
                } else {
                    const flatBonus = bonusValue || 0;
                    if (flatBonus > 0) {
                        html += `<div style="color:#10b981;font-weight:bold;font-size:1rem;margin-top:0.5rem;">+${flatBonus} AC bonus (Total AC: ${baseAC + flatBonus})</div>`;
                    }
                }
                html += '<div style="font-size:0.85rem;color:#94a3b8;margin-top:1rem;font-style:italic;">Protects you from enemy attacks. Higher AC makes you harder to hit.</div>';
                
            } else if (itemType === 3) {
                // Potion details
                html += '<div style="color:#10b981;font-weight:bold;margin-bottom:1rem;font-size:1.1rem;">üß™ POTION</div>';
                const val = bonusValue || 0;
                if (bonusType === 1 || bonusType === 2) {
                    html += `<div style="color:#06b6d4;font-weight:bold;font-size:1rem;">Effect: +${val} to ALL rolls for 1 turn</div>`;
                } else if (bonusType === 3 || bonusType === 5) {
                    html += `<div style="color:#3b82f6;font-weight:bold;font-size:1rem;">Effect: +${val} AC for 1 turn</div>`;
                } else if (bonusType === 4 || bonusType === 6) {
                    html += `<div style="color:#ef4444;font-weight:bold;font-size:1rem;">Effect: +${val} to attack rolls for 1 turn</div>`;
                } else if (bonusType === 7) {
                    html += `<div style="color:#8b5cf6;font-weight:bold;font-size:1rem;">Effect: +${val} to all rolls for 1 turn</div>`;
                }
                html += '<div style="font-size:0.85rem;color:#94a3b8;margin-top:1rem;font-style:italic;">Single-use consumable that provides temporary combat bonuses.</div>';
                
            } else if (itemType === 0 && bonusType === 5) {
                // Checkpoint
                html += '<div style="color:#06b6d4;font-weight:bold;margin-bottom:1rem;font-size:1.1rem;">üìç CHECKPOINT</div>';
                html += '<div style="color:#94a3b8;font-size:1rem;">Set a checkpoint at your current location. You can teleport back to this checkpoint at any time from the dungeon menu.</div>';
            }
            
            html += '</div>';
            html += '</div>';
            html += '<button id="close-item-details" style="width:100%;padding:1rem;background:#475569;color:white;border:none;border-radius:6px;font-weight:bold;cursor:pointer;margin-top:1rem;">CLOSE</button>';
            html += '</div>';
            
            detailsModal.innerHTML = html;
            document.body.appendChild(detailsModal);
            
            document.getElementById('close-item-details').onclick = () => {
                detailsModal.remove();
            };
        }

        // Wrapper function to handle purchase with full item data
        function buyDungeonItemFromData(itemName, itemData) {
            // Parse JSON if it's a string
            let data;
            try {
                data = typeof itemData === 'string' ? JSON.parse(itemData.replace(/&quot;/g, '"')) : itemData;
            } catch (e) {
                data = itemData;
            }
            buyDungeonItem(itemName, data[0], data[1], data[2], data[3]);
        }

        function buyDungeonItem(itemName, cost, itemType, bonusType, bonusValue) {
            if (stats.coins < cost) {
                addLog('You cannot afford that!', 'text-red-400');
                return;
            }
            
            stats.coins -= cost;
            
            if (itemType === 1) {
                // Unique Weapon - check if bonusValue is a damage formula string
                if (!stats.weapons[itemName]) {
                    const weaponData = { unique: true };
                    
                    // Check if bonusValue is a string (damage formula) or number (attack bonus)
                    if (typeof bonusValue === 'string' && bonusValue.includes('d')) {
                        // Custom damage formula
                        weaponData.damageFormula = bonusValue;
                        weaponData.attackBonus = bonusType || 0; // bonusType becomes attackBonus
                    } else {
                        // Standard tier-based weapon
                        weaponData.tier = bonusType || 2;
                        weaponData.attackBonus = bonusValue || 0;
                    }
                    
                    // Initialize durability
                    initializeWeaponDurability(itemName, weaponData);
                    
                    stats.weapons[itemName] = weaponData;
                    // Update attack bonus if equipping
                    if (stats.equippedWeapon === itemName || Object.keys(stats.weapons).length === 1) {
                        stats.equippedWeapon = itemName;
                        stats.attackBonus = weaponData.attackBonus || 0;
                    }
                    const bonusText = weaponData.attackBonus > 0 ? ` (+${weaponData.attackBonus} attack rolls)` : '';
                    const durabilityText = weaponData.maxDurability ? ` [Durability: ${weaponData.durability}/${weaponData.maxDurability}]` : '';
                    addLog(`Purchased ${itemName}!${bonusText}${durabilityText}`, 'text-green-400 font-bold');
                } else {
                    stats.coins += cost; // Refund if already have
                    addLog('You already have this weapon!', 'text-yellow-400');
                    return;
                }
            } else if (itemType === 2) {
                // Unique Armor - check if bonusValue is a conditional bonus object
                if (!stats.armors[itemName]) {
                    const baseAC = bonusType || 10;
                    const armorData = { ac: baseAC, unique: true };
                    
                    // Check if bonusValue is an object (conditional bonus) or number (flat bonus)
                    if (typeof bonusValue === 'object' && bonusValue !== null) {
                        armorData.conditionalBonus = bonusValue;
                    } else {
                        armorData.acBonus = bonusValue || 0;
                    }
                    
                    stats.armors[itemName] = armorData;
                    // Update AC if equipping
                    if (stats.equippedArmor === itemName || Object.keys(stats.armors).length === 1) {
                        stats.equippedArmor = itemName;
                        stats.armor = baseAC;
                        stats.acBonus = armorData.acBonus || 0;
                    }
                    let bonusText = '';
                    if (armorData.conditionalBonus) {
                        const cond = armorData.conditionalBonus;
                        if (cond.type === 'lowHP') {
                            bonusText = ` (AC ${baseAC}, +${cond.bonus} when HP ‚â§ ${cond.threshold})`;
                        } else if (cond.type === 'percentHP') {
                            const percent = Math.round(cond.threshold * 100);
                            bonusText = ` (AC ${baseAC}, +${cond.bonus} when HP ‚â§ ${percent}%)`;
                        } else if (cond.type === 'highHP') {
                            bonusText = ` (AC ${baseAC}, +${cond.bonus} when HP ‚â• ${cond.threshold})`;
                        }
                    } else if (armorData.acBonus > 0) {
                        bonusText = ` (+${armorData.acBonus} AC)`;
                    }
                    addLog(`Purchased ${itemName}!${bonusText}`, 'text-green-400 font-bold');
                } else {
                    stats.coins += cost; // Refund if already have
                    addLog('You already have this armor!', 'text-yellow-400');
                    return;
                }
            } else if (itemType === 3) {
                // Unique Potion - store effect type and value
                if (!stats.potions[itemName]) {
                    stats.potions[itemName] = [1, bonusType, bonusValue]; // [count, effectType, effectValue]
                } else {
                    stats.potions[itemName][0]++;
                }
                addLog(`Purchased ${itemName}!`, 'text-green-400 font-bold');
            } else if (itemType === 0 && bonusType === 5) {
                // Checkpoint
                stats.checkpointsPurchased++;
                addLog(`Checkpoint purchased! You now have ${stats.checkpointsPurchased} checkpoint(s) available.`, "text-cyan-400 font-bold");
            }
            
            updateUI();
            closeDungeonShop();
            // Reopen shop with current merchant data
            const shopKey = `shop_${currentRoom[0]},${currentRoom[1]},${stats.floor}`;
            if (monsterData[shopKey]) {
                const shopData = monsterData[shopKey];
                const shop = {
                    name: shopData.name,
                    greeting: shopData.greeting,
                    inventory: shopData.inventory
                };
                showDungeonShop(shop);
            }
        }

        // Wrapper function to handle JSON parsing from onclick
        function showDungeonItemStatsWrapper(name, dataStr) {
            let data;
            try {
                // Try parsing as JSON string first
                if (typeof dataStr === 'string') {
                    // Replace &quot; back to " for proper JSON parsing
                    const jsonStr = dataStr.replace(/&quot;/g, '"');
                    data = JSON.parse(jsonStr);
                } else {
                    data = dataStr;
                }
            } catch (e) {
                console.error('Error parsing item data:', e, dataStr);
                // If parsing fails, try to extract as array
                if (typeof dataStr === 'string') {
                    // Try to manually parse if JSON.parse fails
                    try {
                        data = eval('(' + dataStr.replace(/&quot;/g, '"') + ')');
                    } catch (e2) {
                        data = dataStr;
                    }
                } else {
                    data = dataStr;
                }
            }
            showDungeonItemStats(name, data);
        }

        function showDungeonItemStats(name, data) {
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.9);display:flex;align-items:center;justify-content:center;z-index:10001;';
            
            // Handle both array and object formats - ensure we get the correct values
            let cost, itemType, bonusType, bonusValue;
            
            // First, ensure data is an array
            if (!Array.isArray(data)) {
                if (data && typeof data === 'object') {
                    // Try to reconstruct array from object
                    cost = data.cost !== undefined ? data.cost : (data[0] !== undefined ? data[0] : 0);
                    itemType = data.itemType !== undefined ? data.itemType : (data[1] !== undefined ? data[1] : 0);
                    bonusType = data.bonusType !== undefined ? data.bonusType : (data[2] !== undefined ? data[2] : 0);
                    bonusValue = data.bonusValue !== undefined ? data.bonusValue : (data[3] !== undefined ? data[3] : 0);
                } else {
                    console.error('Invalid item data for', name, data);
                    cost = 0;
                    itemType = 0;
                    bonusType = 0;
                    bonusValue = 0;
                }
            } else {
                // Data is an array - extract values directly
                // IMPORTANT: Array format is [cost, itemType, bonusType, bonusValue]
                cost = data[0] !== undefined ? data[0] : 0;
                itemType = data[1] !== undefined ? data[1] : 0;  // 1=weapon, 2=armor, 3=potion, 0=special
                bonusType = data[2] !== undefined ? data[2] : 0;  // Base tier/AC or effect type
                bonusValue = data[3] !== undefined ? data[3] : 0;  // Bonus amount or damage formula
            }
            
            // Validate itemType is a number
            if (typeof itemType !== 'number') {
                itemType = parseInt(itemType) || 0;
            }
            // Ensure itemType is an integer
            itemType = Math.floor(itemType);
            
            // Validate bonusType is a number (unless it's an object for conditional bonuses)
            if (typeof bonusType !== 'number' && typeof bonusType !== 'object') {
                bonusType = parseInt(bonusType) || 0;
            }
            
            // Handle null/undefined for bonusValue - set to 0 only if truly null/undefined
            // Preserve objects, strings, and numbers (including 0)
            if (bonusValue === null || bonusValue === undefined) {
                bonusValue = 0;
            }
            // Note: bonusValue can be: number, string (damage formula), or object (conditional bonus)
            
            // Ensure itemType is correct - merchant items use: 1=weapon, 2=armor, 3=potion, 0=special
            // NEVER treat merchant potions (itemType 3) as spells (itemType 4)
            if (itemType === 4) {
                // This shouldn't happen for merchant items, but if it does, treat as potion
                console.warn('Item type 4 detected for merchant item - treating as potion:', name);
                itemType = 3;
            }
            
            let html = '<div style="background:#1e293b;padding:2rem;border-radius:10px;max-width:500px;width:90%;">';
            html += '<h2 style="font-size:1.5rem;font-weight:bold;margin-bottom:1rem;text-align:center;color:white;">ITEM DETAILS</h2>';
            html += '<div style="background:#0f172a;padding:1.5rem;border-radius:8px;margin-bottom:1rem;border:2px solid #334155;">';
            html += `<div style="font-size:1.2rem;font-weight:bold;color:#fbbf24;text-transform:uppercase;margin-bottom:0.5rem;text-align:center;">${name}</div>`;
            
            // Ensure we're displaying the correct item type
            // itemType: 1=weapon, 2=armor, 3=potion, 0=special
            
            if (itemType === 1) {
                // Unique Weapon - ALWAYS show weapon information
                html += `<div style="font-size:0.9rem;color:#94a3b8;margin-bottom:1rem;text-align:center;">Unique Weapon</div>`;
                html += '<div style="border-top:1px solid #334155;padding-top:1rem;">';
                
                // Check if bonusValue is a damage formula string
                if (typeof bonusValue === 'string' && bonusValue.includes('d')) {
                    html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Damage Formula: <span style="color:#10b981;font-weight:bold;">${bonusValue}</span></div>`;
                    // Calculate damage range for display
                    try {
                        const testRolls = [];
                        for (let i = 0; i < 100; i++) {
                            testRolls.push(calculateCustomDamage(bonusValue));
                        }
                        const minDmg = Math.min(...testRolls);
                        const maxDmg = Math.max(...testRolls);
                        html += `<div style="font-size:0.9rem;color:#64748b;margin-bottom:0.5rem;">Damage Range: <span style="color:#10b981;font-weight:bold;">${minDmg}-${maxDmg}</span></div>`;
                    } catch (e) {
                        // Ignore calculation errors
                    }
                    if (bonusType && typeof bonusType === 'number' && bonusType > 0) {
                        html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Attack Bonus: <span style="color:#3b82f6;font-weight:bold;">+${bonusType} to attack rolls</span></div>`;
                    }
                    html += '<div style="font-size:0.85rem;color:#94a3b8;margin-top:1rem;font-style:italic;">Unique damage formula! This weapon deals damage differently than standard weapons. Each attack uses this formula to calculate damage.</div>';
                } else if (typeof bonusValue === 'object' && bonusValue !== null && bonusValue.baseDamage) {
                    // Conditional damage bonus weapon
                    html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Base Damage: <span style="color:#10b981;font-weight:bold;">${bonusValue.baseDamage}</span></div>`;
                    if (bonusType && typeof bonusType === 'number' && bonusType > 0) {
                        html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Attack Bonus: <span style="color:#3b82f6;font-weight:bold;">+${bonusType} to attack rolls</span></div>`;
                    }
                    
                    // Show conditional damage bonus
                    html += '<div style="background:#1e293b;padding:0.75rem;border-radius:6px;margin-top:0.75rem;border:1px solid #06b6d4;">';
                    html += '<div style="color:#06b6d4;font-weight:bold;margin-bottom:0.5rem;">‚ú® CONDITIONAL DAMAGE BONUS</div>';
                    if (bonusValue.type === 'lowHP') {
                        html += `<div style="color:#94a3b8;">+${bonusValue.bonus} damage when your HP ‚â§ ${bonusValue.threshold}</div>`;
                    } else if (bonusValue.type === 'boss') {
                        html += `<div style="color:#94a3b8;">+${bonusValue.bonus} damage when fighting bosses</div>`;
                    } else if (bonusValue.type === 'miniBoss') {
                        html += `<div style="color:#94a3b8;">+${bonusValue.bonus} damage when fighting mini-bosses or bosses</div>`;
                    } else if (bonusValue.type === 'floor') {
                        html += `<div style="color:#94a3b8;">+${bonusValue.bonus} damage per floor (currently +${bonusValue.bonus * stats.floor})</div>`;
                    } else if (bonusValue.type === 'floorParity') {
                        if (bonusValue.evenBonus > 0 && bonusValue.oddBonus > 0) {
                            html += `<div style="color:#94a3b8;">+${bonusValue.evenBonus} damage on even floors, +${bonusValue.oddBonus} on odd floors</div>`;
                        } else if (bonusValue.evenBonus > 0) {
                            html += `<div style="color:#94a3b8;">+${bonusValue.evenBonus} damage on even floors</div>`;
                        } else {
                            html += `<div style="color:#94a3b8;">+${bonusValue.oddBonus} damage on odd floors</div>`;
                        }
                    }
                    html += '</div>';
                    html += '<div style="font-size:0.85rem;color:#94a3b8;margin-top:1rem;font-style:italic;">Conditional bonus! This weapon deals extra damage when specific conditions are met.</div>';
                } else if (typeof bonusValue === 'number' || bonusValue === 0 || bonusValue === null || bonusValue === undefined) {
                    // Standard tier-based weapon
                    const baseTier = (typeof bonusType === 'number' && bonusType > 0) ? bonusType : 2;
                    html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Base Tier: <span style="color:#fbbf24;font-weight:bold;">${baseTier}</span></div>`;
                    html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Damage: <span style="color:#10b981;font-weight:bold;">${getWeaponDamageDesc(baseTier)}</span></div>`;
                    if (bonusValue && typeof bonusValue === 'number' && bonusValue > 0) {
                        html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Attack Bonus: <span style="color:#3b82f6;font-weight:bold;">+${bonusValue} to attack rolls</span></div>`;
                    }
                    html += '<div style="font-size:0.85rem;color:#94a3b8;margin-top:1rem;font-style:italic;">Permanently increases your attack roll chance. Stacks with weapon tier damage.</div>';
                } else {
                    // Fallback - always show something
                    html += '<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Unique weapon with special properties.</div>';
                    html += `<div style="font-size:0.9rem;color:#64748b;margin-bottom:0.5rem;">Bonus Type: ${typeof bonusType === 'object' ? JSON.stringify(bonusType) : bonusType}, Value: ${typeof bonusValue === 'object' ? JSON.stringify(bonusValue) : bonusValue}</div>`;
                }
                html += '</div>'; // Close border-top div
            } else if (itemType === 2) {
                // Unique Armor - ALWAYS show armor information
                const baseAC = (typeof bonusType === 'number' && bonusType > 0) ? bonusType : 10;
                html += `<div style="font-size:0.9rem;color:#94a3b8;margin-bottom:1rem;text-align:center;">Unique Armor</div>`;
                html += '<div style="border-top:1px solid #334155;padding-top:1rem;">';
                html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Base AC: <span style="color:#3b82f6;font-weight:bold;">${baseAC}</span></div>`;
                
                // Check if bonusValue is a conditional bonus object (not array, not null)
                if (bonusValue && typeof bonusValue === 'object' && !Array.isArray(bonusValue) && bonusValue !== null && bonusValue.type) {
                    let conditionText = '';
                    if (bonusValue.type === 'lowHP') {
                        conditionText = `+${bonusValue.bonus} AC when HP ‚â§ ${bonusValue.threshold}`;
                    } else if (bonusValue.type === 'percentHP') {
                        const percent = Math.round(bonusValue.threshold * 100);
                        conditionText = `+${bonusValue.bonus} AC when HP ‚â§ ${percent}%`;
                    } else if (bonusValue.type === 'highHP') {
                        conditionText = `+${bonusValue.bonus} AC when HP ‚â• ${bonusValue.threshold}`;
                    } else if (bonusValue.type === 'coins') {
                        conditionText = `+${bonusValue.bonus} AC when gold ‚â• ${bonusValue.threshold}`;
                    } else if (bonusValue.type === 'boss') {
                        conditionText = `+${bonusValue.bonus} AC when fighting bosses`;
                    } else if (bonusValue.type === 'miniBoss') {
                        conditionText = `+${bonusValue.bonus} AC when fighting mini-bosses/bosses`;
                    } else if (bonusValue.type === 'floorParity') {
                        if (bonusValue.evenBonus > 0 && bonusValue.oddBonus > 0) {
                            conditionText = `+${bonusValue.evenBonus} AC on even floors, +${bonusValue.oddBonus} on odd`;
                        } else if (bonusValue.evenBonus > 0) {
                            conditionText = `+${bonusValue.evenBonus} AC on even floors`;
                        } else {
                            conditionText = `+${bonusValue.oddBonus} AC on odd floors`;
                        }
                    }
                    if (conditionText) {
                        html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Special Effect: <span style="color:#10b981;font-weight:bold;">${conditionText}</span></div>`;
                        const maxBonus = bonusValue.type === 'floorParity' ? Math.max(bonusValue.evenBonus || 0, bonusValue.oddBonus || 0) : bonusValue.bonus;
                        html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Max AC (when condition met): <span style="color:#fbbf24;font-weight:bold;">${baseAC + maxBonus}</span></div>`;
                        html += '<div style="font-size:0.85rem;color:#94a3b8;margin-top:1rem;font-style:italic;">Conditional bonus! This armor provides extra protection when specific conditions are met. The bonus activates automatically during combat.</div>';
                    } else {
                        html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Total AC: <span style="color:#fbbf24;font-weight:bold;">${baseAC}</span></div>`;
                        html += '<div style="font-size:0.85rem;color:#94a3b8;margin-top:1rem;font-style:italic;">Permanently increases your Armor Class. Makes you harder to hit.</div>';
                    }
                } else if (typeof bonusValue === 'number' && bonusValue > 0) {
                    html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">AC Bonus: <span style="color:#10b981;font-weight:bold;">+${bonusValue} AC</span></div>`;
                    html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Total AC: <span style="color:#fbbf24;font-weight:bold;">${baseAC + bonusValue}</span></div>`;
                    html += '<div style="font-size:0.85rem;color:#94a3b8;margin-top:1rem;font-style:italic;">Permanently increases your Armor Class. Makes you harder to hit.</div>';
                } else {
                    // Always show at least base AC
                    html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Total AC: <span style="color:#fbbf24;font-weight:bold;">${baseAC}</span></div>`;
                    html += '<div style="font-size:0.85rem;color:#94a3b8;margin-top:1rem;font-style:italic;">Permanently increases your Armor Class. Makes you harder to hit.</div>';
                }
                html += '</div>'; // Close border-top div
            } else if (itemType === 3) {
                // Unique Potion - ALWAYS show potion information
                html += `<div style="font-size:0.9rem;color:#94a3b8;margin-bottom:1rem;text-align:center;">Unique Potion</div>`;
                html += '<div style="border-top:1px solid #334155;padding-top:1rem;">';
                let effectText = '';
                const val = typeof bonusValue === 'number' ? bonusValue : 0;
                const bonusTypeNum = typeof bonusType === 'number' ? bonusType : parseInt(bonusType) || 0;
                
                if (bonusTypeNum === 1 || bonusTypeNum === 2) {
                    effectText = `+${val} to all rolls for 1 turn`;
                    html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Effect: <span style="color:#10b981;font-weight:bold;">${effectText}</span></div>`;
                    html += '<div style="font-size:0.85rem;color:#94a3b8;margin-top:1rem;font-style:italic;">Use in combat to gain a temporary bonus to all your rolls (attack, defense, skill checks) for one turn.</div>';
                } else if (bonusTypeNum === 3 || bonusTypeNum === 5) {
                    effectText = `+${val} AC for 1 turn`;
                    html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Effect: <span style="color:#10b981;font-weight:bold;">${effectText}</span></div>`;
                    html += '<div style="font-size:0.85rem;color:#94a3b8;margin-top:1rem;font-style:italic;">Use in combat to temporarily increase your Armor Class, making you harder to hit for one turn.</div>';
                } else if (bonusTypeNum === 4 || bonusTypeNum === 6) {
                    effectText = `+${val} attack rolls for 1 turn`;
                    html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Effect: <span style="color:#10b981;font-weight:bold;">${effectText}</span></div>`;
                    html += '<div style="font-size:0.85rem;color:#94a3b8;margin-top:1rem;font-style:italic;">Use in combat to temporarily increase your attack roll chance, making you more likely to hit for one turn.</div>';
                } else if (bonusTypeNum === 7) {
                    effectText = `+${val} to all rolls for 1 turn`;
                    html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Effect: <span style="color:#10b981;font-weight:bold;">${effectText}</span></div>`;
                    html += '<div style="font-size:0.85rem;color:#94a3b8;margin-top:1rem;font-style:italic;">Use in combat to gain a temporary bonus to all your rolls for one turn.</div>';
                } else {
                    html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Effect: <span style="color:#10b981;font-weight:bold;">Special effect potion</span></div>`;
                    html += `<div style="font-size:0.9rem;color:#64748b;margin-bottom:0.5rem;">Bonus Type: ${bonusTypeNum}, Value: ${val}</div>`;
                    html += '<div style="font-size:0.85rem;color:#94a3b8;margin-top:1rem;font-style:italic;">Consumable item. Use in combat for temporary bonuses.</div>';
                }
                html += '</div>'; // Close border-top div
            } else if (itemType === 0 && bonusType === 5) {
                // Checkpoint
                html += `<div style="font-size:0.9rem;color:#94a3b8;margin-bottom:1rem;text-align:center;">Special Item</div>`;
                html += '<div style="border-top:1px solid #334155;padding-top:1rem;">';
                html += '<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Type: <span style="color:#06b6d4;font-weight:bold;">Teleportation Device</span></div>';
                html += '<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Effect: <span style="color:#fbbf24;font-weight:bold;">Set a checkpoint and teleport to it anytime</span></div>';
                html += '<div style="font-size:0.85rem;color:#94a3b8;margin-top:1rem;font-style:italic;">Once purchased, you can place a checkpoint in any dungeon room and teleport back to it whenever you want.</div>';
            } else {
                // Fallback for unknown items - show what we know
                html += `<div style="font-size:0.9rem;color:#94a3b8;margin-bottom:1rem;text-align:center;">Unique Item</div>`;
                html += '<div style="border-top:1px solid #334155;padding-top:1rem;">';
                html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Item Type: ${itemType}</div>`;
                html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Bonus Type: ${bonusType}</div>`;
                html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Bonus Value: ${typeof bonusValue === 'object' ? JSON.stringify(bonusValue) : bonusValue}</div>`;
                html += '<div style="font-size:0.85rem;color:#94a3b8;margin-top:1rem;font-style:italic;">A unique item found only in dungeon merchants.</div>';
            }
            
            html += '</div>';
            html += `<div style="font-size:1.1rem;font-weight:bold;color:#fbbf24;text-align:center;margin-top:1rem;padding-top:1rem;border-top:1px solid #334155;">Price: ${cost} Gold</div>`;
            html += '<button onclick="closeDungeonItemStatsModal()" style="width:100%;padding:0.75rem;background:#64748b;border-radius:6px;font-weight:bold;color:white;font-size:0.95rem;cursor:pointer;border:none;margin-top:1rem;">CLOSE</button>';
            html += '</div>';
            html += '</div>';
            
            modal.innerHTML = html;
            modal.id = 'dungeon-item-stats-modal';
            document.body.appendChild(modal);
        }

        function closeDungeonItemStatsModal() {
            const modal = document.getElementById('dungeon-item-stats-modal');
            if (modal) modal.remove();
        }

        function closeDungeonShop() {
            const modal = document.getElementById('dungeon-shop-modal');
            if (modal) modal.remove();
        }

        function createChestBtn(p, isBig) {
            const chestId = `chest_${currentRoom[0]}_${currentRoom[1]}_${stats.floor}`;
            const b = document.createElement('button');
            b.className = "px-6 py-3 bg-yellow-700 hover:bg-yellow-600 rounded text-sm font-bold uppercase";
            b.innerText = isBig ? "Open Big Chest" : "Open Small Chest";
            
            if(stats.openedChests.has(chestId)) return;

            b.onclick = async () => {
                if (isProcessing) return;
                isProcessing = true;
                
                if (isBig) {
                    addLog("Big Chest! Attempting to unlock with Intelligence...", "text-yellow-400");
                    
                    const statVal = stats.intelligence + stats.temporary_intelligence;
                    await logLoading("Rolling Intelligence", 3, 150);
                    const baseRoll = Math.floor(Math.random()*20)+1;
                    const mod = Math.floor(statVal / 2) - 5;
                    const roll = baseRoll + mod;
                    const need = Math.floor(Math.random()*5)+10;
                    addLog(`Rolled ${baseRoll} + ${mod} = ${roll}. Need ${need}.`);
                    
                    if (roll >= need) {
                        addLog("Success! You cleverly unlock the chest!", "text-green-500 font-bold");
                        const loot = Math.floor(Math.random()*71)+30;  // 30-100 gold
                        stats.coins += loot;
                        addLog(`Found ${loot} coins!`, "text-yellow-500");
                        
                        // 1/3 chance to find a random potion or spell
                        if (Math.floor(Math.random()*3) === 0) {
                            const isPotionNotSpell = Math.random() < 0.5;
                            const potionNames = ["healing potion", "intelligence potion", "speed potion", "strength potion", "protection potion"];
                            const spellNames = ["magic missile spell", "weakness spell", "lightning spell", "freeze spell", "fireball spell"];
                            
                            const itemList = isPotionNotSpell ? potionNames : spellNames;
                            const itemName = itemList[Math.floor(Math.random() * itemList.length)];
                            const itemData = SHOP_DATA[itemName];
                            const rarity = getItemRarity();
                            const rarityInfo = RARITY[rarity];
                            
                            if (isPotionNotSpell) {
                                if(!stats.potions[itemName]) stats.potions[itemName] = [0, itemData[3]];
                                stats.potions[itemName][0]++;
                                addLog(`Found a [${rarityInfo.name}] ${itemName}!`, "text-purple-400 font-bold");
                            } else {
                                if(!stats.spells[itemName]) stats.spells[itemName] = [0, itemData[3]];
                                stats.spells[itemName][0]++;
                                addLog(`Found a [${rarityInfo.name}] ${itemName}!`, "text-purple-400 font-bold");
                            }
                        }
                        
                        const floorKey = `floor_${stats.floor}`;
                        floorMaps[floorKey][currentRoom[0]][currentRoom[1]] -= 10;
                        stats.openedChests.add(chestId);
                    } else {
                        addLog("Failed! The chest remains locked.", "text-red-500");
                        const floorKey = `floor_${stats.floor}`;
                        floorMaps[floorKey][currentRoom[0]][currentRoom[1]] -= 10;
                    }
                    
                    stats.temporary_intelligence = 0;
                    isProcessing = false;
                    checkRoom(false, false);  // After opening chest - do NOT spawn wandering monsters
                    updateUI();
                } else {
                    // Small chest: always give at least some gold (no empty small chests)
                    const loot = Math.floor(Math.random()*36)+5;
                    stats.coins += loot;
                    addLog(`Found ${loot} coins.`, "text-yellow-500");
                    const floorKey = `floor_${stats.floor}`;
                    floorMaps[floorKey][currentRoom[0]][currentRoom[1]] -= 1;
                    stats.openedChests.add(chestId);
                    isProcessing = false;
                    checkRoom(false, false);  // After opening chest - do NOT spawn wandering monsters
                    updateUI();
                }
            };
            p.appendChild(b);
        }

        // --- COMBAT ---
        function showPreCombatSavePrompt(name, type) {
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.9);display:flex;align-items:center;justify-content:center;z-index:10000;';
            
            const monsterIcon = type === 'boss' ? 'üëπ' : type === 'mini' ? 'üòà' : 'üëæ';
            
            let html = '<div style="background:#1e293b;padding:2rem;border-radius:10px;max-width:400px;width:90%;border:3px solid #dc2626;">';
            html += `<div style="text-align:center;font-size:3rem;margin-bottom:1rem;">${monsterIcon}</div>`;
            html += '<h2 style="font-size:1.3rem;font-weight:bold;margin-bottom:1rem;text-align:center;color:#ef4444;">BATTLE AHEAD!</h2>';
            html += '<div style="background:#0f172a;padding:1.5rem;border-radius:8px;margin-bottom:1rem;border:2px solid #7f1d1d;text-align:center;">';
            html += `<div style="font-size:1.1rem;font-weight:bold;color:#fbbf24;text-transform:uppercase;margin-bottom:0.5rem;">${name}</div>`;
            html += `<div style="font-size:0.9rem;color:#94a3b8;">You are about to enter combat!</div>`;
            html += '</div>';
            html += '<div style="font-size:0.85rem;color:#94a3b8;text-align:center;margin-bottom:1.5rem;">Would you like to save your game first?</div>';
            html += '<div style="display:flex;gap:0.75rem;flex-direction:column;">';
            html += `<button onclick="saveBeforeCombat('${name}', '${type}')" style="width:100%;padding:0.75rem;background:#10b981;border-radius:8px;font-weight:bold;color:white;font-size:0.95rem;cursor:pointer;border:none;">SAVE & FIGHT</button>`;
            html += `<button onclick="proceedToCombat('${name}', '${type}')" style="width:100%;padding:0.75rem;background:#dc2626;border-radius:8px;font-weight:bold;color:white;font-size:0.95rem;cursor:pointer;border:none;">FIGHT NOW</button>`;
            if (winMode) {
                html += `<button onclick="autoDefeatMonster('${name}', '${type}')" style="width:100%;padding:0.75rem;background:#f59e0b;border-radius:8px;font-weight:bold;color:white;font-size:0.95rem;cursor:pointer;border:none;">‚ö° DEFEAT ‚ö°</button>`;
            }
            html += '</div>';
            html += '</div>';
            
            modal.innerHTML = html;
            modal.id = 'pre-combat-modal';
            document.body.appendChild(modal);
        }

        async function saveBeforeCombat(name, type) {
            closePreCombatModal();
            // Show loading indicator while fetching slots
            const loadingModal = document.createElement('div');
            loadingModal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.9);display:flex;align-items:center;justify-content:center;z-index:10000;';
            loadingModal.innerHTML = '<div style="text-align:center;color:white;"><div style="font-size:2rem;margin-bottom:1rem;">‚è≥</div><div>Loading save slots...</div></div>';
            loadingModal.id = 'loading-modal';
            document.body.appendChild(loadingModal);
            
            const slots = await getAllSaveSlots();
            
            // Remove loading modal immediately
            const existingLoading = document.getElementById('loading-modal');
            if (existingLoading) existingLoading.remove();
            
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.9);display:flex;align-items:center;justify-content:center;z-index:10000;';
            
            let html = '<div style="background:#1e293b;padding:2rem;border-radius:10px;max-width:500px;width:90%;">';
            html += '<h2 style="font-size:1.5rem;font-weight:bold;margin-bottom:1.5rem;text-align:center;color:white;">QUICK SAVE</h2>';
            html += '<div style="display:flex;flex-direction:column;gap:1rem;">';
            
            for (let i = 1; i <= 3; i++) {
                const slot = slots[`slot${i}`];
                const slotDate = slot ? new Date(slot.savedAt).toLocaleString() : '';
                const currentCharName = stats.characterName || 'Unnamed Hero';
                
                html += `<button onclick="quickSaveAndFight(${i}, '${name}', '${type}')" style="padding:1rem;background:#334155;border-radius:8px;text-align:left;cursor:pointer;border:2px solid #475569;transition:all 0.2s;color:white;" onmouseover="this.style.background='#475569'" onmouseout="this.style.background='#334155'">`;
                html += `<div style="font-weight:bold;font-size:1.1rem;">Slot ${i}</div>`;
                if (slot) {
                    html += `<div style="font-size:0.9rem;color:#fbbf24;">${slot.name}</div>`;
                    html += `<div style="font-size:0.8rem;color:#94a3b8;">${slotDate}</div>`;
                } else {
                    html += `<div style="font-size:0.9rem;color:#64748b;">Empty</div>`;
                }
                html += `<div style="font-size:0.75rem;color:#3b82f6;margin-top:0.25rem;">Will save: ${currentCharName}</div>`;
                html += '</button>';
            }
            
            html += '</div>';
            html += `<button onclick="cancelQuickSave('${name}', '${type}')" style="margin-top:1.5rem;width:100%;padding:0.75rem;background:#64748b;border-radius:8px;font-weight:bold;color:white;">SKIP & FIGHT</button>`;
            html += '</div>';
            
            modal.innerHTML = html;
            modal.id = 'quick-save-modal';
            document.body.appendChild(modal);
        }

        async function quickSaveAndFight(slotNumber, name, type) {
            const saveName = stats.characterName || `Save ${slotNumber}`;
            const success = await saveToCloud(slotNumber, saveName);
            if (success) {
                addLog(`Game saved to Slot ${slotNumber}!`, 'text-green-400');
            } else {
                addLog(`Failed to save to Slot ${slotNumber}.`, 'text-red-400');
            }
            closeQuickSaveModal();
            startCombat(name, type);
        }

        function cancelQuickSave(name, type) {
            closeQuickSaveModal();
            startCombat(name, type);
        }

        function proceedToCombat(name, type) {
            closePreCombatModal();
            startCombat(name, type);
        }

        async function autoDefeatMonster(name, type) {
            closePreCombatModal();
            addLog(`CHEAT: Auto-defeating ${name}...`, 'text-yellow-400 font-bold');
            await sleep(500);
            
            // Award experience based on monster type
            let expGained = 0;
            if (type === 'lichking') {
                expGained = 500;
            } else if (type === 'boss') {
                expGained = 100;
                stats.bossesDefeated++;
                stats.keys++;
                addLog("Found a Key!", "text-blue-400 font-bold");
            } else if (type === 'mini') {
                expGained = 50;
                stats.miniBossesDefeated++;
            } else {
                expGained = 20;
            }
            
            stats.exp += expGained;
            stats.totalExp += expGained;
            stats.kills++;
            addLog(`Gained ${expGained} EXP!`, 'text-green-400');
            
            // Remove monster from map
            const floorKey = `floor_${stats.floor}`;
            if (type === 'boss') {
                floorMaps[floorKey][currentRoom[0]][currentRoom[1]] -= 1000000;
            } else if (type === 'mini') {
                floorMaps[floorKey][currentRoom[0]][currentRoom[1]] -= 100000;
            } else if (type === 'wandering') {
                floorMaps[floorKey][currentRoom[0]][currentRoom[1]] -= 1000;
            } else {
                floorMaps[floorKey][currentRoom[0]][currentRoom[1]] -= 100;
            }
            
            // Check for level up
            const totalExpForNextLevel = 50 * stats.level * (stats.level + 1);
            if (stats.totalExp >= totalExpForNextLevel) {
                await levelUp();
            }
            
            updateUI();
            showView('view-dungeon');
            renderDungeon();
            checkRoom(false, false);
        }

        function closePreCombatModal() {
            const modal = document.getElementById('pre-combat-modal');
            if (modal) modal.remove();
        }

        function closeQuickSaveModal() {
            const modal = document.getElementById('quick-save-modal');
            if (modal) modal.remove();
        }

        async function startCombat(name, type) {
            let mStats = {};
            
            // Special handling for Lich King
            if (type === 'lichking') {
                mStats = monsterData['lichking'];
            } else {
                // Check if this is a pre-generated monster from the map
                const monsterKey = `${currentRoom[0]},${currentRoom[1]},${stats.floor}`;
                if (monsterData[monsterKey]) {
                    // Use pre-generated stats
                    mStats = {...monsterData[monsterKey]};
                } else {
                    // Generate new stats for random wandering monsters
                    mStats = generateMonsterStats(type);
                }
            }

            // Prefer the stored name (for pre-generated monsters). If missing, use the passed name or generate one.
            const combatName = mStats.name || name || (type ? generateMonsterName(type) : 'Monster');

            combatData = { ...mStats, name: combatName, type, maxHP: mStats.maxHP || mStats.HP, turn: 'init' };
            showView('view-combat');

            // Show type indicator for bosses/mini-bosses/lich king
            let typeLabel = '';
            if (type === 'lichking') typeLabel = ' üëë FINAL BOSS üëë';
            else if (type === 'boss') typeLabel = ' (BOSS)';
            else if (type === 'mini') typeLabel = ' (MINI-BOSS)';
            
            document.getElementById('monster-name').innerText = `${combatName}${typeLabel}`;
            document.getElementById('monster-stats-display').innerText = `Dexterity: ${mStats.dexterity}`;
            updateCombatUI();
            addLog(`Encountered ${combatName}${typeLabel}!`, type === 'lichking' ? "text-red-600 font-black text-lg" : "text-red-500 font-bold uppercase");
            
            isProcessing = true;
            await logLoading("Rolling Initiative", 3, 120);
            if (Math.random() < 0.5) {
                addLog("You act first!", "text-blue-400");
                combatData.turn = 'player';
                showCombatSubMenu('main');
                isProcessing = false;
            } else {
                addLog(`${combatName} acts first!`, "text-red-400");
                combatData.turn = 'monster';
                isProcessing = false;
                monsterTurnStart();
            }
            updateCombatUI();
        }

        function retreat() {
            if(isProcessing) return;
            showRetreatDirectionModal();
        }

        function showRetreatDirectionModal() {
            const modal = document.createElement('div');
            modal.id = 'retreat-direction-modal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.9); z-index: 9999;
                display: flex; align-items: center; justify-content: center;
            `;
            
            // Check which directions are valid
            const canGoNorth = currentRoom[0] > 0;
            const canGoSouth = currentRoom[0] < 9;
            const canGoWest = currentRoom[1] > 0;
            const canGoEast = currentRoom[1] < 9;
            
            let buttonsHtml = '<div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; max-width: 300px;">';
            
            // Top row
            buttonsHtml += '<div></div>';
            if (canGoNorth) {
                buttonsHtml += `<button onclick="attemptRetreat(-1, 0)" class="px-6 py-4 bg-yellow-700 hover:bg-yellow-600 rounded text-lg font-bold">‚Üë<br>NORTH</button>`;
            } else {
                buttonsHtml += '<div></div>';
            }
            buttonsHtml += '<div></div>';
            
            // Middle row
            if (canGoWest) {
                buttonsHtml += `<button onclick="attemptRetreat(0, -1)" class="px-6 py-4 bg-yellow-700 hover:bg-yellow-600 rounded text-lg font-bold">‚Üê<br>WEST</button>`;
            } else {
                buttonsHtml += '<div></div>';
            }
            buttonsHtml += '<div style="display: flex; align-items: center; justify-content: center; color: #94a3b8; font-size: 24px;">‚öîÔ∏è</div>';
            if (canGoEast) {
                buttonsHtml += `<button onclick="attemptRetreat(0, 1)" class="px-6 py-4 bg-yellow-700 hover:bg-yellow-600 rounded text-lg font-bold">‚Üí<br>EAST</button>`;
            } else {
                buttonsHtml += '<div></div>';
            }
            
            // Bottom row
            buttonsHtml += '<div></div>';
            if (canGoSouth) {
                buttonsHtml += `<button onclick="attemptRetreat(1, 0)" class="px-6 py-4 bg-yellow-700 hover:bg-yellow-600 rounded text-lg font-bold">‚Üì<br>SOUTH</button>`;
            } else {
                buttonsHtml += '<div></div>';
            }
            buttonsHtml += '<div></div>';
            
            buttonsHtml += '</div>';
            
            modal.innerHTML = `
                <div style="background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%); 
                    border: 3px solid #eab308; border-radius: 12px; padding: 32px; 
                    max-width: 450px; width: 90%; box-shadow: 0 20px 60px rgba(234, 179, 8, 0.4);">
                    <h2 style="font-size: 24px; font-weight: bold; color: #eab308; 
                        text-align: center; margin-bottom: 8px; text-transform: uppercase;">
                        Choose Retreat Direction
                    </h2>
                    <p style="text-align: center; color: #cbd5e1; margin-bottom: 24px; font-size: 14px;">
                        Select which adjacent room to flee to
                    </p>
                    ${buttonsHtml}
                    <button onclick="closeRetreatModal()" 
                        style="width: 100%; margin-top: 16px; padding: 12px; background: #64748b; 
                        border-radius: 8px; font-weight: bold; color: white; cursor: pointer; border: none;">
                        CANCEL
                    </button>
                </div>
            `;
            
            document.body.appendChild(modal);
        }

        async function attemptRetreat(dr, dc) {
            closeRetreatModal();
            
            if(isProcessing) return;
            isProcessing = true;
            
            await logLoading("Attempting Retreat", 3, 150);
            const baseRoll = Math.floor(Math.random()*20)+1;
            const mod = Math.floor((stats.dexterity + stats.temporary_dexterity)/2)-5;
            const allRollsBonus = stats.temporary_allRollsBonus;
            const roll = baseRoll + mod + allRollsBonus;
            stats.temporary_dexterity = 0;
            stats.temporary_allRollsBonus = 0;
            addLog(`Dex Roll: ${baseRoll} + ${mod} = ${roll} vs ${combatData.dexterity}`, "text-yellow-400");
            
            if (roll >= combatData.dexterity) {
                addLog("Retreat Successful!", "text-green-500 font-bold");
                
                // Move to the chosen adjacent room
                currentRoom[0] += dr;
                currentRoom[1] += dc;
                
                // Clear combat data since we've left combat
                combatData = null;
                
                showView('view-dungeon');
                renderDungeon();
                checkRoom(false, true);  // Entering new room via retreat - can spawn wandering monsters
            } else {
                addLog("Retreat Failed!", "text-red-500 font-bold");
                await sleep(500);
                combatData.turn = 'monster';
                monsterTurnStart();
            }
            isProcessing = false;
        }

        function closeRetreatModal() {
            const modal = document.getElementById('retreat-direction-modal');
            if (modal) modal.remove();
        }

        function showCombatSubMenu(menu) {
            document.getElementById('combat-main-menu').classList.toggle('hidden', menu !== 'main');
            document.getElementById('combat-direction-menu').classList.toggle('hidden', menu !== 'attack');
            document.getElementById('combat-items-menu').classList.toggle('hidden', menu !== 'items');
            document.getElementById('combat-defense-menu').classList.toggle('hidden', menu !== 'defense');
            if (menu === 'items') renderCombatInventory();
        }

        function updateCombatUI() {
            const p = Math.max(0, (combatData.HP / combatData.maxHP) * 100);
            document.getElementById('monster-hp-bar').style.width = `${p}%`;
            document.getElementById('turn-indicator').innerText = combatData.turn.toUpperCase() + ' TURN';
        }

        // Calculate total AC including conditional bonuses
        function getTotalAC() {
            let ac = stats.armor + stats.acBonus + stats.temporary_armor + stats.temporary_acBonus;
            const armorData = stats.armors[stats.equippedArmor];
            if (armorData && typeof armorData === 'object' && armorData.unique && armorData.conditionalBonus) {
                const condition = armorData.conditionalBonus;
                if (condition.type === 'lowHP' && stats.HP <= condition.threshold) {
                    ac += condition.bonus;
                } else if (condition.type === 'highHP' && stats.HP >= condition.threshold) {
                    ac += condition.bonus;
                } else if (condition.type === 'percentHP') {
                    const hpPercent = stats.HP / stats.maxHP;
                    // Support both >= and <= percent checks
                    if ((condition.threshold > 1 && hpPercent >= condition.threshold) || 
                        (condition.threshold <= 1 && hpPercent <= condition.threshold)) {
                        ac += condition.bonus;
                    }
                } else if (condition.type === 'coins' && stats.gold >= condition.threshold) {
                    ac += condition.bonus;
                } else if (condition.type === 'boss' && combatData && combatData.type === 'boss') {
                    ac += condition.bonus;
                } else if (condition.type === 'miniBoss' && combatData && (combatData.type === 'mini-boss' || combatData.type === 'boss')) {
                    ac += condition.bonus;
                } else if (condition.type === 'floorParity') {
                    // Even floors get evenBonus, odd floors get oddBonus
                    ac += (stats.floor % 2 === 0) ? condition.evenBonus : condition.oddBonus;
                }
            }
            return ac;
        }

        // Calculate custom damage formula (e.g., "1d6+1d10", "5d4", "2d8+3")
        function calculateCustomDamage(formula) {
            if (!formula || typeof formula !== 'string') return 0;
            
            let total = 0;
            // Split by + and - to handle multiple dice expressions
            const parts = formula.split(/([+-])/);
            let sign = 1;
            
            for (let part of parts) {
                part = part.trim();
                if (part === '+') { sign = 1; continue; }
                if (part === '-') { sign = -1; continue; }
                
                // Check if it's a dice expression (e.g., "2d6", "1d10")
                const diceMatch = part.match(/(\d+)d(\d+)/);
                if (diceMatch) {
                    const numDice = parseInt(diceMatch[1]);
                    const diceSize = parseInt(diceMatch[2]);
                    for (let i = 0; i < numDice; i++) {
                        total += sign * (Math.floor(Math.random() * diceSize) + 1);
                    }
                } else {
                    // It's a flat number
                    const num = parseInt(part);
                    if (!isNaN(num)) {
                        total += sign * num;
                    }
                }
            }
            
            return Math.max(0, total);
        }

        async function combatAction(dir) {
            if (isProcessing) return;
            isProcessing = true;
            
            // Check if player is stunned
            if (stats.stunned) {
                addLog("You are stunned and cannot act!", "text-red-500 font-bold");
                stats.stunned = false;
                await sleep(400);
                if(combatData.HP > 0) {
                    combatData.turn = 'player';
                    isProcessing = false;
                    updateCombatUI();
                    showCombatSubMenu('main');
                }
                return;
            }
            
            showCombatSubMenu('none');
            await logLoading("Rolling Hit", 3, 120);
            const baseRoll = Math.floor(Math.random()*20)+1;
            const mod = Math.floor((stats.strength + stats.temporary_strength)/2)-5;
            const attackBonus = stats.attackBonus + stats.temporary_attackBonus + stats.temporary_allRollsBonus;
            const roll = baseRoll + mod + attackBonus;
            stats.temporary_strength = 0;
            // Clear temporary bonuses after use
            stats.temporary_attackBonus = 0;
            stats.temporary_acBonus = 0;
            stats.temporary_allRollsBonus = 0;
            let bonusText = attackBonus > 0 ? ` + ${attackBonus} (bonus)` : '';
            addLog(`Str Roll: ${baseRoll} + ${mod}${bonusText} = ${roll} vs AC ${combatData.armor}`);
            if (roll >= combatData.armor) {
                addLog("HIT!", "text-green-400 font-bold");
                await logLoading("Damage", 3, 120);
                const weaponData = stats.weapons[stats.equippedWeapon];
                let dmg = 0;
                let conditionalDamageBonus = 0;
                
                if (weaponData && typeof weaponData === 'object' && weaponData.unique) {
                    // Check if it has a custom damage formula
                    if (weaponData.damageFormula) {
                        dmg = calculateCustomDamage(weaponData.damageFormula);
                    } else if (weaponData.conditionalBonus && weaponData.conditionalBonus.baseDamage) {
                        // Has conditional bonus with base damage formula
                        dmg = calculateCustomDamage(weaponData.conditionalBonus.baseDamage);
                    } else {
                        // Fall back to tier-based damage
                        const tier = weaponData.tier || 1;
                        if(tier===1) dmg = Math.floor(Math.random()*3)+1;
                        else if(tier===2) dmg = Math.floor(Math.random()*6)+1;
                        else if(tier===3) dmg = Math.floor(Math.random()*10)+1;
                        else if(tier===4) dmg = Math.floor(Math.random()*6)+1+Math.floor(Math.random()*6)+1+2;
                        else if(tier===5) dmg = Math.floor(Math.random()*6)+1+Math.floor(Math.random()*6)+1+Math.floor(Math.random()*6)+1+3;
                        else if(tier===6) dmg = Math.floor(Math.random()*6)+1+Math.floor(Math.random()*6)+1+Math.floor(Math.random()*6)+1+Math.floor(Math.random()*6)+1+4;
                        else dmg = Math.floor(Math.random()*6)+1;
                    }
                    
                    // Check for conditional damage bonuses
                    if (weaponData.conditionalBonus) {
                        const condition = weaponData.conditionalBonus;
                        if (condition.type === 'lowHP' && stats.HP <= condition.threshold) {
                            conditionalDamageBonus = condition.bonus;
                        } else if (condition.type === 'boss' && combatData.type === 'boss') {
                            conditionalDamageBonus = condition.bonus;
                        } else if (condition.type === 'miniBoss' && (combatData.type === 'mini-boss' || combatData.type === 'boss')) {
                            conditionalDamageBonus = condition.bonus;
                        } else if (condition.type === 'floor') {
                            conditionalDamageBonus = condition.bonus * stats.floor;
                        } else if (condition.type === 'floorParity') {
                            conditionalDamageBonus = (stats.floor % 2 === 0) ? condition.evenBonus : condition.oddBonus;
                        }
                    }
                } else if (weaponData && typeof weaponData === 'object' && weaponData.tier) {
                    // Tier-based weapon stored as object (new durability format)
                    const tier = weaponData.tier || 1;
                    if(tier===1) dmg = Math.floor(Math.random()*3)+1;
                    else if(tier===2) dmg = Math.floor(Math.random()*6)+1;
                    else if(tier===3) dmg = Math.floor(Math.random()*10)+1;
                    else if(tier===4) dmg = Math.floor(Math.random()*6)+1+Math.floor(Math.random()*6)+1+2;
                    else if(tier===5) dmg = Math.floor(Math.random()*6)+1+Math.floor(Math.random()*6)+1+Math.floor(Math.random()*6)+1+3;
                    else if(tier===6) dmg = Math.floor(Math.random()*6)+1+Math.floor(Math.random()*6)+1+Math.floor(Math.random()*6)+1+Math.floor(Math.random()*6)+1+4;
                    else dmg = Math.floor(Math.random()*6)+1;
                } else if (weaponData) {
                    const tier = typeof weaponData === 'number' ? weaponData : 1;
                    if(tier===1) dmg = Math.floor(Math.random()*3)+1;
                    else if(tier===2) dmg = Math.floor(Math.random()*6)+1;
                    else if(tier===3) dmg = Math.floor(Math.random()*10)+1;
                    else if(tier===4) dmg = Math.floor(Math.random()*6)+1+Math.floor(Math.random()*6)+1+2;
                    else if(tier===5) dmg = Math.floor(Math.random()*6)+1+Math.floor(Math.random()*6)+1+Math.floor(Math.random()*6)+1+3;
                    else if(tier===6) dmg = Math.floor(Math.random()*6)+1+Math.floor(Math.random()*6)+1+Math.floor(Math.random()*6)+1+Math.floor(Math.random()*6)+1+4;
                    else dmg = Math.floor(Math.random()*6)+1;
                } else {
                    dmg = Math.floor(Math.random()*6)+1;  // Fallback
                }
                
                // Apply conditional damage bonus
                dmg += conditionalDamageBonus;
                
                const mDir = Math.floor(Math.random()*3)+1;
                if(mDir === dir) {
                    dmg = Math.floor(dmg/2);
                    addLog(`Monster Blocked! Half damage (${dmg})`, "text-slate-400");
                } else {
                    let damageMsg = `Dealt ${dmg} damage!`;
                    if (conditionalDamageBonus > 0) {
                        damageMsg += ` (+${conditionalDamageBonus} bonus)`;
                    }
                    addLog(damageMsg, "text-green-400");
                }
                combatData.HP -= dmg;
                
                // Reduce weapon durability on successful hit
                damageWeaponDurability(stats.equippedWeapon);
                
                if(combatData.HP <= 0) { await victory(); return; }
            } else addLog("MISS!", "text-red-400");
            // Clear temporary bonuses after turn
            stats.temporary_attackBonus = 0;
            stats.temporary_acBonus = 0;
            stats.temporary_allRollsBonus = 0;
            updateCombatUI();
            await sleep(300);
            if(combatData.HP > 0) {
                combatData.turn = 'monster';
                isProcessing = false;
                monsterTurnStart();
            }
        }

        async function monsterTurnStart() {
            if(combatData.freeze > 0) {
                combatData.freeze--;
                addLog("Monster is Frozen!", "text-cyan-400");
                await sleep(400);
                combatData.turn = 'player';
                updateCombatUI();
                showCombatSubMenu('main');
                return;
            }
            if(combatData.fire) {
                combatData.HP -= 2;
                addLog("Monster took 2 fire damage.", "text-orange-400");
                if(combatData.HP <= 0) { await victory(); return; }
            }
            
            // Check if boss should use an ability
            const hpPercent = combatData.HP / combatData.maxHP;
            const isBoss = combatData.type === 'boss' || combatData.type === 'mini' || combatData.type === 'lichking';
            const useAbility = isBoss && bossShouldUseAbility(combatData.type, hpPercent);
            
            if (useAbility) {
                const availableAbilities = getAvailableAbilities(combatData.type);
                if (availableAbilities.length > 0) {
                    const abilityKey = availableAbilities[Math.floor(Math.random() * availableAbilities.length)];
                    const ability = BOSS_ABILITIES[abilityKey];
                    
                    if (ability) {
                        addLog(`${combatData.name} uses ${ability.name}!`, "text-red-500 font-bold text-lg");
                        const result = await ability.effect();
                        
                        if (result === false) return; // Effect caused death
                        
                        await sleep(300);
                        combatData.turn = 'player';
                        updateCombatUI();
                        showCombatSubMenu('main');
                        return;
                    }
                }
            }
            
            showCombatSubMenu('defense');
        }

        async function resolveMonsterTurn(defDir) {
            if (isProcessing) return;
            isProcessing = true;
            showCombatSubMenu('none');
            await logLoading("Monster Attacking", 3, 120);
            if(combatData.change_strength) {
                combatData.strength += 2;
                combatData.change_strength = false;
                addLog("Monster strength increased!", "text-red-500");
            }
            const roll = Math.floor(Math.random()*20)+1 + combatData.strength;
            const ac = getTotalAC();
            addLog(`Monster Roll: ${roll} vs AC ${ac}`);
            if (roll >= ac) {
                addLog("YOU WERE HIT!", "text-red-600 font-bold");
                let dmg = 0;
                const tier = combatData.attack;
                if(tier<=1) dmg = Math.floor(Math.random()*3)+1;
                else if(tier===2) dmg = Math.floor(Math.random()*6)+1;
                else if(tier===3) dmg = Math.floor(Math.random()*10)+1;
                else if(tier===4) dmg = Math.floor(Math.random()*6)*2+2;
                else if(tier===5) dmg = Math.floor(Math.random()*6)*3+3;
                else dmg = Math.floor(Math.random()*6)*4+4;
                
                // Apply freeze field damage reduction
                if (stats.frozen_field && stats.frozen_field > 0) {
                    dmg = Math.floor(dmg * 0.7); // 30% damage reduction
                    addLog("Freeze field reduces damage!", "text-cyan-400");
                    stats.frozen_field--;
                    if (stats.frozen_field === 0) {
                        addLog("Freeze field dissipates.", "text-cyan-300");
                    }
                }
                
                const atkDir = Math.floor(Math.random()*3)+1;
                if(atkDir === defDir) {
                    dmg = Math.floor(dmg/2);
                    addLog(`Blocked! Half damage (${dmg})`, "text-blue-400");
                } else addLog(`Took ${dmg} damage!`, "text-red-500");
                stats.HP -= dmg;
                updateUI();
                if(stats.HP <= 0) {
                    handleDeath();
                    return;
                }
            } else addLog("Monster Missed!", "text-green-400");
            stats.temporary_armor = 0;
            await sleep(300);
            combatData.turn = 'player';
            isProcessing = false;
            updateCombatUI();
            showCombatSubMenu('main');
        }

        async function handleDeath() {
            addLog("YOU DIED.", "text-red-900 font-black text-2xl");
            isProcessing = true;
            stats.combatWinStreak = 0; // Reset combat streak on death
            
            await sleep(1500);
            
            // Wisdom test difficulty increases with each death
            // Base DC is 10, +2 for each previous death
            const baseDC = 10;
            const deathPenalty = stats.deathCount * 2;
            const targetDC = baseDC + deathPenalty;
            
            addLog("Your spirit lingers between life and death...", "text-purple-400 italic");
            await sleep(1000);
            addLog("Make a Wisdom saving throw to return to the living!", "text-yellow-400 font-bold");
            await logLoading("Rolling", 3, 400);
            
            const roll = Math.floor(Math.random()*20)+1;
            const wisdomMod = Math.floor(stats.wisdom / 2) - 5;
            const total = roll + wisdomMod;
            
            addLog(`Rolled ${roll} + ${wisdomMod} (Wisdom) = ${total}`, "text-slate-300");
            addLog(`Need ${targetDC} or higher to revive`, "text-slate-400");
            
            await sleep(1500);
            
            if (total >= targetDC) {
                // SUCCESS - Revive with 2/3 health in town
                addLog("SUCCESS! Your spirit returns!", "text-green-400 font-black text-xl");
                stats.deathCount++;
                stats.HP = Math.floor(stats.maxHP * 2 / 3);
                stats.coins = Math.floor(stats.coins / 2); // Lose half your gold on death
                
                await sleep(1000);
                addLog(`You awaken in Oakhaven with ${stats.HP} HP and ${stats.coins} gold...`, "text-blue-400");
                addLog(`Death has left its mark. (Deaths: ${stats.deathCount})`, "text-red-400");
                
                // Return to town
                showView('view-town');
                updateUI();
                isProcessing = false;
            } else {
                // FAILURE - Permanent death
                addLog("FAILED... Your spirit fades into darkness.", "text-red-900 font-black text-xl");
                await sleep(2000);
                addLog("Game Over. Reloading...", "text-slate-500");
                await sleep(2000);
                location.reload();
            }
        }

        function calculateMonsterExp(monster) {
            // Base EXP by type
            let baseExp = 0;
            if (monster.type === 'wandering') baseExp = 20;
            else if (monster.type === 'normal') baseExp = 50;
            else if (monster.type === 'mini') baseExp = 150;
            else if (monster.type === 'boss' || monster.type === 'lichking') baseExp = 400;
            
            // Add bonus EXP based on monster stats (difficulty modifiers)
            const hpBonus = Math.floor((monster.maxHP || monster.maxHp || 0) / 10);  // 1 EXP per 10 HP
            const armorBonus = Math.max(0, (monster.armor - 10) * 3);  // 3 EXP per AC above 10
            const attackBonus = monster.attack * 5;  // 5 EXP per attack tier
            const strBonus = Math.max(0, monster.strength) * 4;  // 4 EXP per positive strength
            const dexBonus = Math.max(0, (monster.dexterity - 10) * 2);  // 2 EXP per dex above 10
            
            const totalExp = baseExp + hpBonus + armorBonus + attackBonus + strBonus + dexBonus;
            return Math.floor(totalExp);
        }

        async function victory() {
            // CHECK FOR GAME WIN CONDITION
            if (combatData.type === 'lichking') {
                addLog("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê", "text-yellow-400 font-bold");
                addLog("VICTORY! THE GOBLIN KING IS DEFEATED!", "text-yellow-400 font-black text-2xl");
                addLog("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê", "text-yellow-400 font-bold");
                await sleep(1000);
                addLog("The darkness that plagued Oakhaven has been vanquished.", "text-green-400 font-bold");
                addLog("You are a true hero! The realm is saved!", "text-green-400 font-bold");
                await sleep(2000);
                
                // Award massive rewards for winning
                const winCoins = 1000;
                const winExp = 5000;
                stats.coins += winCoins;
                stats.exp += winExp;
                stats.totalExp += winExp;
                stats.bossesDefeated++;
                stats.keys++;
                addLog(`Looted ${winCoins} legendary gold!`, "text-yellow-400 font-bold");
                addLog(`Gained ${winExp} EXP!`, "text-cyan-400 font-bold");
                
                // Save and show win screen
                updateUI();
                await saveGame();
                
                // Show game won modal
                const modal = document.createElement('div');
                modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.95);display:flex;align-items:center;justify-content:center;z-index:10000;';
                modal.innerHTML = `
                    <div style="background:linear-gradient(135deg, #1e293b 0%, #0f172a 100%);padding:3rem;border-radius:15px;max-width:500px;width:90%;border:3px solid #fbbf24;text-align:center;">
                        <div style="font-size:3rem;margin-bottom:1rem;">üëë</div>
                        <h2 style="font-size:2rem;font-weight:bold;color:#fbbf24;margin-bottom:1rem;">GAME WON!</h2>
                        <p style="color:#e2e8f0;font-size:1.1rem;margin-bottom:2rem;line-height:1.6;">
                            You have defeated the Goblin King and saved Oakhaven from darkness.
                            <br><br>
                            Final Stats:
                            <br>Level: ${stats.level}
                            <br>Gold: ${stats.coins}
                            <br>Total EXP: ${stats.totalExp}
                        </p>
                        <button onclick="location.reload()" style="padding:0.75rem 2rem;background:#fbbf24;color:#1e293b;border:none;border-radius:8px;font-weight:bold;font-size:1rem;cursor:pointer;">
                            NEW GAME
                        </button>
                    </div>
                `;
                document.body.appendChild(modal);
                return;
            }
            
            addLog("VICTORY!", "text-yellow-400 font-black text-xl");
            
            // Better rewards based on monster type
            let coins = 0;
            if (combatData.type === 'wandering') {
                coins = Math.floor(Math.random()*21)+5;  // 5-25 gold
            } else if (combatData.type === 'normal') {
                coins = Math.floor(Math.random()*51)+25;  // 25-75 gold
            } else if (combatData.type === 'mini') {
                coins = Math.floor(Math.random()*101)+100;  // 100-200 gold
            } else if (combatData.type === 'boss') {
                coins = Math.floor(Math.random()*301)+200;  // 200-500 gold
            }
            
            stats.coins += coins;
            addLog(`Looted ${coins} coins.`, "text-yellow-500");
            
            // Award EXP
            const expGained = calculateMonsterExp(combatData);
            stats.exp += expGained;
            stats.totalExp += expGained;
            addLog(`Gained ${expGained} EXP! (${stats.totalExp}/${stats.expToNextLevel})`, "text-cyan-400");
            
            // Check for level up
            if (stats.exp >= stats.expToNextLevel) {
                await sleep(500);
                await levelUp();
            }
            
            // Remove monster from room
            let removeVal = 0;
            if(combatData.type.includes('boss')) removeVal = 1000000;
            else if(combatData.type.includes('mini')) removeVal = 100000;
            else if(combatData.type.includes('wandering')) removeVal = 1000;
            else removeVal = 100;
            const floorKey = `floor_${stats.floor}`;
            floorMaps[floorKey][currentRoom[0]][currentRoom[1]] -= removeVal;
            
            // Track kills and special defeats
            stats.kills++;
            if(combatData.type === 'mini') stats.miniBossesDefeated++;
            if(combatData.type === 'boss') {
                stats.bossesDefeated++;
                stats.keys++;
                addLog("Found a Key!", "text-blue-400 font-bold");
            }
            
            // Mini-boss has chance to drop extra gold
            if(combatData.type === 'mini' && Math.random() < 0.5) {
                const bonus = Math.floor(Math.random()*51)+50;  // 50-100 extra
                stats.coins += bonus;
                addLog(`Found a hidden stash! +${bonus} gold!`, "text-yellow-400 font-bold");
            }
            
            await sleep(1000);
            isProcessing = false;
            updateUI();
            showView('view-dungeon');
            renderDungeon();
            checkRoom(false, false);  // After victory - do NOT spawn wandering monsters
            
            // Update combat streak and check achievements
            stats.lastCombatWon = true;
            stats.combatWinStreak++;
            checkAchievements();
        }

        function checkAchievements() {
            // Easy Achievements
            if (stats.totalExp >= 10 && !stats.achievements.first_kill) unlockAchievement('first_kill');
            if (stats.openedChests.size > 0 && !stats.achievements.open_chest) unlockAchievement('open_chest');
            if (stats.kills >= 10 && !stats.achievements.kill_10) unlockAchievement('kill_10');
            if (stats.coins >= 100 && !stats.achievements.loot_100) unlockAchievement('loot_100');
            if ((stats.equippedWeapon !== 'stick' || stats.equippedArmor !== 'none') && !stats.achievements.equip_item) unlockAchievement('equip_item');
            if (stats.spellsCast >= 1 && !stats.achievements.cast_spell) unlockAchievement('cast_spell');
            
            // Medium Achievements
            if (stats.level >= 5 && !stats.achievements.level_5) unlockAchievement('level_5');
            if (stats.kills >= 50 && !stats.achievements.kill_50) unlockAchievement('kill_50');
            if (stats.coins >= 1000 && !stats.achievements.loot_1000) unlockAchievement('loot_1000');
            if (stats.floor >= 5 && !stats.achievements.floor_5) unlockAchievement('floor_5');
            if (stats.miniBossesDefeated >= 1 && !stats.achievements.defeat_mini) unlockAchievement('defeat_mini');
            if (Object.keys(stats.spells).length >= 3 && !stats.achievements.collect_3_spells) unlockAchievement('collect_3_spells');
            if (stats.combatWinStreak >= 5 && !stats.achievements.combat_streak) unlockAchievement('combat_streak');
            if (stats.level >= 10 && !stats.achievements.level_10) unlockAchievement('level_10');
            if (Object.keys(stats.spells).length >= 5 && !stats.achievements.librarian) unlockAchievement('librarian');
            
            // Hard Achievements
            if (stats.bossesDefeated >= 1 && !stats.achievements.boss_killer) unlockAchievement('boss_killer');
            if (stats.coins >= 5000 && !stats.achievements.hoarder) unlockAchievement('hoarder');
            if (stats.floor >= 10 && !stats.achievements.floor_10) unlockAchievement('floor_10');
            if (stats.level >= 15 && !stats.achievements.level_15) unlockAchievement('level_15');
            if (stats.kills >= 200 && !stats.achievements.kill_200) unlockAchievement('kill_200');
            if (stats.coins >= 10000 && !stats.achievements.wealthy) unlockAchievement('wealthy');
            if (stats.bossesDefeated >= 3 && !stats.achievements.defeat_3_bosses) unlockAchievement('defeat_3_bosses');
            if (stats.combatWinStreak >= 8 && !stats.achievements.combat_streak_8) unlockAchievement('combat_streak_8');
            if (stats.floor >= 15 && !stats.achievements.floor_15) unlockAchievement('floor_15');
            if (stats.coins >= 50000 && !stats.achievements.golden_touch) unlockAchievement('golden_touch');
            if (stats.level >= 20 && !stats.achievements.level_20) unlockAchievement('level_20');
            if (stats.floor >= 25 && !stats.achievements.floor_master) unlockAchievement('floor_master');
            if (stats.kills >= 500 && !stats.achievements.defeat_50_monsters) unlockAchievement('defeat_50_monsters');
        }

        function unlockAchievement(achievementKey) {
            if (!stats.achievements[achievementKey]) {
                const achievement = ACHIEVEMENTS[achievementKey];
                stats.achievements[achievementKey] = true;
                stats.coins += achievement.reward;
                addLog(`üèÜ ACHIEVEMENT UNLOCKED: ${achievement.name}!`, "text-yellow-400 font-bold");
                addLog(`+${achievement.reward} gold reward`, "text-yellow-500");
                updateUI();
            }
        }

        async function levelUp() {
            stats.level++;
            // Calculate EXP needed for next level based on formula: 50 * level * (level + 1)
            const nextLevelExp = 50 * stats.level * (stats.level + 1);
            stats.exp = 0;  // Reset progress for current level
            stats.expToNextLevel = nextLevelExp;
            
            addLog(`LEVEL UP! You are now level ${stats.level}!`, "text-purple-400 font-black text-xl");
            await sleep(1000);
            
            // Increase max HP with scaling dice rolls
            let hpGain = 0;
            let diceType = '';
            if (stats.level <= 3) {
                // Levels 1-3: 1d4 (1-4 HP)
                hpGain = Math.floor(Math.random()*4)+1;
                diceType = '1d4';
            } else if (stats.level <= 6) {
                // Levels 4-6: 1d6 (1-6 HP)
                hpGain = Math.floor(Math.random()*6)+1;
                diceType = '1d6';
            } else if (stats.level <= 9) {
                // Levels 7-9: 1d8 (1-8 HP)
                hpGain = Math.floor(Math.random()*8)+1;
                diceType = '1d8';
            } else if (stats.level <= 12) {
                // Levels 10-12: 1d10 (1-10 HP)
                hpGain = Math.floor(Math.random()*10)+1;
                diceType = '1d10';
            } else {
                // Levels 13+: 1d12 (1-12 HP)
                hpGain = Math.floor(Math.random()*12)+1;
                diceType = '1d12';
            }
            
            // Store HP gain data for later display
            const levelUpData = { hpGain, diceType, oldMaxHP: stats.maxHP };
            stats.maxHP += hpGain;
            stats.HP = stats.maxHP;  // Full heal on level up
            updateUI();
            
            // Calculate number of stat increases based on level
            // Level 1-3: 1 increase, Level 4-6: 2 increases, Level 7-9: 3 increases, etc.
            const numIncreases = Math.floor((stats.level - 1) / 3) + 1;
            
            await sleep(500);
            showStatIncreaseModal(1, numIncreases, levelUpData);  // Start with first increase
        }

        function showStatIncreaseModal(increaseNumber, totalIncreases, levelUpData) {
            const modal = document.createElement('div');
            modal.id = 'stat-increase-modal';
            modal.setAttribute('data-levelup', JSON.stringify(levelUpData));
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.85); z-index: 9999;
                display: flex; align-items: center; justify-content: center;
                backdrop-filter: blur(4px);
            `;
            
            const statNames = [
                { key: 'strength', label: 'STRENGTH', desc: 'Melee damage' },
                { key: 'dexterity', label: 'DEXTERITY', desc: 'Hit chance & defense' },
                { key: 'intelligence', label: 'INTELLIGENCE', desc: 'Spell power & chests' },
                { key: 'wisdom', label: 'WISDOM', desc: 'Spell defense & death saves' }
            ];
            
            let buttonsHtml = '';
            statNames.forEach(stat => {
                const currentValue = stats[stat.key];
                buttonsHtml += `
                    <button onclick="increaseStat('${stat.key}', ${increaseNumber}, ${totalIncreases})" 
                        class="w-full bg-purple-800 hover:bg-purple-700 text-white px-6 py-4 rounded text-lg font-bold transition-colors border-2 border-purple-600">
                        <div class="flex justify-between items-center">
                            <div class="text-left">
                                <div>${stat.label}</div>
                                <div class="text-sm text-purple-300 font-normal">${stat.desc}</div>
                            </div>
                            <div class="text-2xl">${currentValue} ‚Üí ${currentValue + 1}</div>
                        </div>
                    </button>
                `;
            });
            
            modal.innerHTML = `
                <div style="background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%); 
                    border: 3px solid #a855f7; border-radius: 12px; padding: 32px; 
                    max-width: 500px; width: 90%; box-shadow: 0 20px 60px rgba(168, 85, 247, 0.4);">
                    <h2 style="font-size: 28px; font-weight: bold; color: #a855f7; 
                        text-align: center; margin-bottom: 8px; text-transform: uppercase;">
                        üéâ Level Up! üéâ
                    </h2>
                    <p style="text-align: center; color: #cbd5e1; margin-bottom: 24px; font-size: 16px;">
                        Choose a stat to increase by 1 (${increaseNumber}/${totalIncreases}):
                    </p>
                    <div style="display: flex; flex-direction: column; gap: 12px;">
                        ${buttonsHtml}
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }

        async function increaseStat(statName, increaseNumber, totalIncreases) {
            stats[statName]++;
            addLog(`${statName.toUpperCase()} increased to ${stats[statName]}!`, "text-purple-400 font-bold");
            
            const modal = document.getElementById('stat-increase-modal');
            const levelUpData = JSON.parse(modal.getAttribute('data-levelup'));
            
            closeStatIncreaseModal();
            updateUI();
            
            // If there are more increases remaining, show modal for next increase
            if (increaseNumber < totalIncreases) {
                await sleep(500);
                showStatIncreaseModal(increaseNumber + 1, totalIncreases, levelUpData);
            } else {
                // All stat increases complete - show HP completion modal
                await sleep(500);
                showHPCompletionModal(levelUpData);
            }
        }

        function showHPCompletionModal(levelUpData) {
            const modal = document.createElement('div');
            modal.id = 'hp-completion-modal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.85); z-index: 9999;
                display: flex; align-items: center; justify-content: center;
                backdrop-filter: blur(4px);
            `;
            
            modal.innerHTML = `
                <div style="background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%); 
                    border: 3px solid #10b981; border-radius: 12px; padding: 32px; 
                    max-width: 500px; width: 90%; box-shadow: 0 20px 60px rgba(16, 185, 129, 0.4);">
                    <h2 style="font-size: 28px; font-weight: bold; color: #10b981; 
                        text-align: center; margin-bottom: 16px; text-transform: uppercase;">
                        ‚ù§Ô∏è Health Boost! ‚ù§Ô∏è
                    </h2>
                    <div style="background: #0f172a; padding: 20px; border-radius: 8px; margin-bottom: 24px; border: 2px solid #334155;">
                        <div style="text-align: center; color: #cbd5e1; font-size: 16px; margin-bottom: 12px;">
                            Max HP Increased!
                        </div>
                        <div style="text-align: center; font-size: 32px; font-weight: bold; color: #10b981; margin-bottom: 12px;">
                            ${levelUpData.oldMaxHP} ‚Üí ${stats.maxHP}
                        </div>
                        <div style="text-align: center; color: #94a3b8; font-size: 14px;">
                            Rolled ${levelUpData.diceType}: +${levelUpData.hpGain} HP
                        </div>
                    </div>
                    <div style="background: #059669; padding: 16px; border-radius: 8px; margin-bottom: 24px;">
                        <div style="text-align: center; color: white; font-size: 18px; font-weight: bold;">
                            ‚ú® Restored to Full Health! ‚ú®
                        </div>
                        <div style="text-align: center; color: #d1fae5; font-size: 16px; margin-top: 8px;">
                            HP: ${stats.HP}/${stats.maxHP}
                        </div>
                    </div>
                    <button onclick="closeHPCompletionModal()" 
                        style="width: 100%; padding: 16px; background: #10b981; border-radius: 8px; 
                        font-weight: bold; color: white; font-size: 18px; cursor: pointer; border: none;
                        transition: background 0.2s;">
                        CONTINUE
                    </button>
                </div>
            `;
            
            document.body.appendChild(modal);
        }

        function closeHPCompletionModal() {
            const modal = document.getElementById('hp-completion-modal');
            if (modal) modal.remove();
        }

        function closeStatIncreaseModal() {
            const modal = document.getElementById('stat-increase-modal');
            if (modal) modal.remove();
        }

        function closeDungeonShop() {
            const modal = document.getElementById('dungeon-shop-modal');
            if (modal) modal.remove();
        }

        // --- SHOP & SELLING ---
        function setShopMode(mode) {
            shopMode = mode;
            document.getElementById('shop-mode-buy').className = `text-sm ${mode==='buy'?'bg-yellow-600':'bg-slate-800'} px-4 py-2 rounded font-bold`;
            document.getElementById('shop-mode-sell').className = `text-sm ${mode==='sell'?'bg-yellow-600':'bg-slate-800'} px-4 py-2 rounded font-bold`;
            renderShop();
        }

        function showShop() {
            shopMode = "buy";
            setShopMode('buy');
            showView('view-shop');
        }

        function renderShop() {
            const container = document.getElementById('shop-categories');
            container.innerHTML = '';
            
            if (shopMode === 'buy') {
                const types = {1:"Weapons", 2:"Armor", 3:"Potions", 4:"Spells", 5:"Special Items", 6:"Tools", 7:"Map Layers"};
                for(let t=1; t<=7; t++) {
                    const sect = document.createElement('div');
                    sect.innerHTML = `<h3 class="text-sm font-bold text-slate-500 mb-3 uppercase tracking-widest border-b border-slate-800 pb-2">${types[t]}</h3>`;
                    const list = document.createElement('div');
                    list.className = "grid grid-cols-2 gap-2 mb-4";
                    for(const [name, data] of Object.entries(SHOP_DATA)) {
                        if(data[2] !== t) continue;
                        const row = document.createElement('div');
                        row.className = "flex flex-col p-2 bg-slate-800/40 rounded border border-slate-800";
                        
                        let itemInfo = `<span class="uppercase font-bold text-sm text-slate-300">${name}</span>`;
                        itemInfo += `<span class="text-yellow-600 text-sm font-bold block mt-1">${data[0]}G</span>`;
                        
                        // Add durability bar for weapons
                        if (data[2] === 1) {
                            const maxDur = WEAPON_DURABILITY[data[1]] || WEAPON_DURABILITY[1];
                            itemInfo += `<div style="margin-top:0.5rem;position:relative;"><div style="width:100%;height:6px;background:#1e293b;border-radius:3px;overflow:hidden;border:1px solid #334155;cursor:pointer;" title="${maxDur}/${maxDur}"><div style="height:100%;width:100%;background:#10b981;"></div></div><div style="position:absolute;top:-20px;left:50%;transform:translateX(-50%);background:#0f172a;color:#fbbf24;padding:2px 6px;border-radius:3px;font-size:0.65rem;font-weight:bold;white-space:nowrap;border:1px solid #334155;opacity:0;pointer-events:none;transition:opacity 0.2s ease;" class="durability-tooltip">${maxDur}/${maxDur}</div></div>`;
                        }
                        
                        row.innerHTML = itemInfo;
                        
                        // Add buttons container
                        const btnContainer = document.createElement('div');
                        btnContainer.className = "flex gap-2 mt-2";
                        
                        // View Stats button
                        const statsBtn = document.createElement('button');
                        statsBtn.className = "flex-1 px-2 py-2 bg-blue-700 hover:bg-blue-600 rounded text-xs font-bold text-white transition-colors";
                        statsBtn.innerText = "VIEW STATS";
                        statsBtn.onclick = () => showItemStats(name, data);
                        
                        // Buy button
                        const buyBtn = document.createElement('button');
                        buyBtn.className = "flex-1 px-2 py-2 bg-slate-700 hover:bg-yellow-700 rounded text-xs font-bold text-white transition-colors";
                        buyBtn.innerText = "BUY";
                        buyBtn.onclick = () => showPurchaseConfirmation(name, data);
                        
                        btnContainer.appendChild(statsBtn);
                        btnContainer.appendChild(buyBtn);
                        row.appendChild(btnContainer);
                        
                        // Add hover listeners for durability tooltip
                        const durabilityBar = row.querySelector('[title]');
                        if (durabilityBar) {
                            const tooltip = durabilityBar.nextElementSibling;
                            if (tooltip && tooltip.classList.contains('durability-tooltip')) {
                                durabilityBar.addEventListener('mouseenter', () => {
                                    tooltip.style.opacity = '1';
                                });
                                durabilityBar.addEventListener('mouseleave', () => {
                                    tooltip.style.opacity = '0';
                                });
                            }
                        }
                        
                        list.appendChild(row);
                    }
                    sect.appendChild(list);
                    container.appendChild(sect);
                }
            } else {
                // Sell Mode
                const sellList = document.createElement('div');
                sellList.className = "grid grid-cols-1 gap-2";
                
                const processCollection = (collection, label) => {
                    for(let name in collection) {
                        if(name === 'stick' || name === 'none') continue;
                        const itemInfo = SHOP_DATA[name];
                        if(!itemInfo) continue;
                        const sellPrice = Math.floor(itemInfo[0] / 2);
                        const count = Array.isArray(collection[name]) ? collection[name][0] : 1;
                        if (count <= 0) continue;

                        const row = document.createElement('div');
                        row.className = "flex justify-between items-center p-3 bg-slate-800/40 rounded border border-slate-700";
                        row.innerHTML = `
                            <div>
                                <span class="text-xs text-slate-500 uppercase font-bold">${label}</span>
                                <div class="text-base font-bold uppercase text-white">${name} ${count>1?'(x'+count+')':''}</div>
                            </div>
                            <button onclick="sellItem('${name}', '${label}')" class="bg-red-900/40 hover:bg-red-800 border border-red-500/30 px-5 py-2 rounded text-sm font-bold text-red-200">
                                SELL FOR ${sellPrice}G
                            </button>
                        `;
                        sellList.appendChild(row);
                    }
                }
                processCollection(stats.weapons, "Weapon");
                processCollection(stats.armors, "Armor");
                processCollection(stats.potions, "Potion");
                processCollection(stats.spells, "Spell");

                if (sellList.children.length === 0) {
                    sellList.innerHTML = `<div class="text-center text-slate-500 py-10 text-sm uppercase font-bold">Nothing to sell</div>`;
                }
                container.appendChild(sellList);
            }
        }

        function showItemStats(name, data) {
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.9);display:flex;align-items:center;justify-content:center;z-index:10000;';
            
            const itemType = data[2] === 1 ? 'Weapon' : data[2] === 2 ? 'Armor' : data[2] === 3 ? 'Potion' : data[2] === 4 ? 'Spell' : 'Special Item';
            
            let html = '<div style="background:#1e293b;padding:2rem;border-radius:10px;max-width:500px;width:90%;">';
            html += '<h2 style="font-size:1.5rem;font-weight:bold;margin-bottom:1rem;text-align:center;color:white;">ITEM DETAILS</h2>';
            html += '<div style="background:#0f172a;padding:1.5rem;border-radius:8px;margin-bottom:1rem;border:2px solid #334155;">';
            html += `<div style="font-size:1.2rem;font-weight:bold;color:#fbbf24;text-transform:uppercase;margin-bottom:0.5rem;text-align:center;">${name}</div>`;
            html += `<div style="font-size:0.9rem;color:#94a3b8;margin-bottom:1rem;text-align:center;">${itemType}</div>`;
            html += '<div style="border-top:1px solid #334155;padding-top:1rem;">';
            
            // Weapon stats
            if (data[2] === 1) {
                html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Tier: <span style="color:#fbbf24;font-weight:bold;">${data[1]}</span></div>`;
                html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Damage: <span style="color:#10b981;font-weight:bold;">${getWeaponDamageDesc(data[1])}</span></div>`;
                html += '<div style="font-size:0.85rem;color:#94a3b8;margin-top:1rem;font-style:italic;">Used for attacking enemies in combat. Higher tier weapons deal more damage.</div>';
            }
            // Armor stats
            else if (data[2] === 2) {
                html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Armor Class: <span style="color:#3b82f6;font-weight:bold;">${data[1]}</span></div>`;
                html += '<div style="font-size:0.85rem;color:#94a3b8;margin-top:1rem;font-style:italic;">Increases your AC (Armor Class). Higher AC makes you harder to hit in combat.</div>';
            }
            // Potion stats
            else if (data[2] === 3) {
                const potionEffects = {
                    1: {name: "Healing", effect: "Restores 1d4+1d4 HP (2-8 HP)", color: "#10b981"},
                    2: {name: "Intelligence", effect: "Grants +6 temporary Intelligence for one chest opening", color: "#3b82f6"},
                    3: {name: "Speed (Dexterity)", effect: "Grants +6 temporary Dexterity for one retreat attempt", color: "#8b5cf6"},
                    4: {name: "Strength", effect: "Grants +6 temporary Strength for one attack", color: "#ef4444"},
                    5: {name: "Protection", effect: "Grants +3 temporary Armor for one enemy attack", color: "#06b6d4"}
                };
                const effect = potionEffects[data[3]];
                html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Type: <span style="color:${effect.color};font-weight:bold;">${effect.name}</span></div>`;
                html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Effect: <span style="color:#fbbf24;font-weight:bold;">${effect.effect}</span></div>`;
                html += '<div style="font-size:0.85rem;color:#94a3b8;margin-top:1rem;font-style:italic;">Consumable item. Can be used in combat or from inventory (healing only).</div>';
            }
            // Spell stats
            else if (data[2] === 4) {
                const spellEffects = {
                    1: {name: "Magic Missile", effect: "1d8 damage, DC 10 Wisdom", color: "#8b5cf6"},
                    2: {name: "Weakness", effect: "1d8 damage + reduce enemy Str by 2, DC 11 Wisdom", color: "#6366f1"},
                    3: {name: "Lightning", effect: "2d6+1d10+3 damage, DC 12 Wisdom", color: "#eab308"},
                    4: {name: "Freeze", effect: "1d6 damage + freeze enemy for 2 turns, DC 10 Wisdom", color: "#06b6d4"},
                    5: {name: "Fireball", effect: "1d15+5 damage + 2 burn damage per turn, DC 11 Wisdom", color: "#f97316"},
                    6: {name: "Town Portal", effect: "Teleport back to town from dungeon", color: "#10b981"}
                };
                const effect = spellEffects[data[3]];
                html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Spell: <span style="color:${effect.color};font-weight:bold;">${effect.name}</span></div>`;
                html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Effect: <span style="color:#fbbf24;font-weight:bold;">${effect.effect}</span></div>`;
                html += '<div style="font-size:0.85rem;color:#94a3b8;margin-top:1rem;font-style:italic;">Consumable spell. Requires Wisdom check to cast successfully.</div>';
            }
            // Checkpoint special item
            else if (data[2] === 5) {
                html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Type: <span style="color:#06b6d4;font-weight:bold;">Teleportation Device</span></div>`;
                html += '<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Effect: <span style="color:#fbbf24;font-weight:bold;">Set a checkpoint and teleport to it anytime</span></div>';
                html += '<div style="font-size:0.85rem;color:#94a3b8;margin-top:1rem;font-style:italic;">Once purchased, you can place a checkpoint in any dungeon room and teleport back to it whenever you want. Perfect for exploring safely!</div>';
            }
            // Map tool item
            else if (data[2] === 6) {
                html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Type: <span style="color:#10b981;font-weight:bold;">Dungeon Map</span></div>`;
                html += '<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Effect: <span style="color:#fbbf24;font-weight:bold;">Reveals bosses, mini-bosses, and stairs on the map</span></div>';
                html += '<div style="font-size:0.85rem;color:#94a3b8;margin-top:1rem;font-style:italic;">Permanently reveals the locations of important rooms on your dungeon map. Bosses (üëë), mini-bosses (‚öî), and stairs (‚¨á) will be clearly marked!</div>';
            }
            // Map layer items (including detailed map)
            else if (data[2] === 7) {
                const layerNames = ['Chests', 'Monsters', 'Mini-Bosses', 'Merchants', 'Stairs', 'Bosses', 'Detailed Map'];
                const layerIcons = ['üí∞', 'üëπ', '‚öî', 'üì¶', '‚¨á', 'üëë', 'üîç'];
                const layerColors = ['#eab308', '#a855f7', '#ea580c', '#f59e0b', '#16a34a', '#dc2626', '#06b6d4'];
                const layerName = layerNames[data[3]];
                const layerIcon = layerIcons[data[3]];
                const layerColor = layerColors[data[3]];
                
                if (data[3] === 6) {
                    // Detailed map special description
                    html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Type: <span style="color:${layerColor};font-weight:bold;">${layerIcon} ${layerName}</span></div>`;
                    html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Effect: <span style="color:#fbbf24;font-weight:bold;">Click any room to inspect its contents</span></div>`;
                    html += '<div style="font-size:0.85rem;color:#94a3b8;margin-top:1rem;font-style:italic;">Allows you to inspect any room on the map to see what it contains before entering. Perfect for strategic planning!</div>';
                } else {
                    html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Type: <span style="color:${layerColor};font-weight:bold;">${layerIcon} ${layerName} Map Layer</span></div>`;
                    html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Effect: <span style="color:#fbbf24;font-weight:bold;">Reveals all ${layerName.toLowerCase()} on your dungeon map</span></div>`;
                    html += '<div style="font-size:0.85rem;color:#94a3b8;margin-top:1rem;font-style:italic;">Unlocks this map layer permanently. Toggle it on/off from your inventory to customize your map view!</div>';
                }
            }
            
            html += '</div>';
            html += `<div style="font-size:1.1rem;font-weight:bold;color:#fbbf24;text-align:center;margin-top:1rem;padding-top:1rem;border-top:1px solid #334155;">Price: ${data[0]} Gold</div>`;
            html += '</div>';
            html += '<button onclick="closeItemStatsModal()" style="width:100%;padding:0.75rem;background:#64748b;border-radius:8px;font-weight:bold;color:white;font-size:0.95rem;cursor:pointer;border:none;">CLOSE</button>';
            html += '</div>';
            
            modal.innerHTML = html;
            modal.id = 'item-stats-modal';
            document.body.appendChild(modal);
        }

        function closeItemStatsModal() {
            const modal = document.getElementById('item-stats-modal');
            if (modal) modal.remove();
        }

        function showPurchaseConfirmation(name, data) {
            if(stats.coins < data[0]) {
                addLog("Not enough gold!", "text-red-500 font-bold");
                return;
            }

            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.9);display:flex;align-items:center;justify-content:center;z-index:10000;';
            
            const itemType = data[2] === 1 ? 'Weapon' : data[2] === 2 ? 'Armor' : data[2] === 3 ? 'Potion' : 'Spell';
            let itemDetails = '';
            if (data[2] === 1) {
                // Weapon - show tier and damage
                itemDetails = `Tier ${data[1]} - ${getWeaponDamageDesc(data[1])}`;
            } else if (data[2] === 2) {
                // Armor - show AC
                itemDetails = `AC ${data[1]}`;
            }
            
            let html = '<div style="background:#1e293b;padding:2rem;border-radius:10px;max-width:450px;width:90%;">';
            html += '<h2 style="font-size:1.3rem;font-weight:bold;margin-bottom:1rem;text-align:center;color:white;">CONFIRM PURCHASE</h2>';
            html += '<div style="background:#0f172a;padding:1.5rem;border-radius:8px;margin-bottom:1.5rem;border:2px solid #334155;">';
            html += `<div style="font-size:1.1rem;font-weight:bold;color:#fbbf24;text-transform:uppercase;margin-bottom:0.5rem;">${name}</div>`;
            html += `<div style="font-size:0.85rem;color:#94a3b8;margin-bottom:0.75rem;">${itemType}</div>`;
            if (itemDetails) {
                html += `<div style="font-size:0.9rem;color:#10b981;margin-bottom:0.75rem;font-weight:bold;">${itemDetails}</div>`;
            }
            html += `<div style="font-size:1.2rem;font-weight:bold;color:#fbbf24;">Cost: ${data[0]} Gold</div>`;
            html += `<div style="font-size:0.9rem;color:#64748b;margin-top:0.5rem;">You have: ${stats.coins} Gold</div>`;
            html += '</div>';
            html += '<div style="display:flex;gap:0.75rem;">';
            html += `<button onclick="confirmPurchase('${name}', ${JSON.stringify(data).replace(/"/g, '&quot;')})" style="flex:1;padding:0.75rem;background:#10b981;border-radius:8px;font-weight:bold;color:white;font-size:0.95rem;cursor:pointer;border:none;">BUY</button>`;
            html += '<button onclick="closePurchaseModal()" style="flex:1;padding:0.75rem;background:#64748b;border-radius:8px;font-weight:bold;color:white;font-size:0.95rem;cursor:pointer;border:none;">CANCEL</button>';
            html += '</div>';
            html += '</div>';
            
            modal.innerHTML = html;
            modal.id = 'purchase-modal';
            document.body.appendChild(modal);
        }

        function confirmPurchase(name, data) {
            closePurchaseModal();
            
            if(stats.coins >= data[0]) {
                stats.coins -= data[0];
                let itemType = '';
                
                if(data[2] === 1) {
                    // Legacy weapon format - convert to object with durability
                    const weaponData = { tier: data[1] };
                    initializeWeaponDurability(name, weaponData);
                    stats.weapons[name] = weaponData;
                    itemType = 'weapon';
                } else if(data[2] === 2) {
                    stats.armors[name] = data[1];
                    itemType = 'armor';
                } else if(data[2] === 3) {
                    if(!stats.potions[name]) stats.potions[name] = [0, data[3]];
                    stats.potions[name][0]++;
                    itemType = 'consumable';
                } else if(data[2] === 4) {
                    if(!stats.spells[name]) stats.spells[name] = [0, data[3]];
                    stats.spells[name][0]++;
                    itemType = 'consumable';
                } else if(data[2] === 5) {
                    // Special items (checkpoint)
                    if(name === 'checkpoint') {
                        stats.checkpointsPurchased++;
                        addLog(`Checkpoint purchased! You now have ${stats.checkpointsPurchased} checkpoint(s) available.`, "text-cyan-400 font-bold");
                        itemType = 'special';
                    }
                } else if(data[2] === 7) {
                    // Map layer items including detailed map
                    if(name === 'detailed map') {
                        stats.hasDetailedMap = true;
                        stats.hasMap = true; // Enable map if not already enabled
                        addLog(`Detailed Map purchased! You can now inspect any room on the map to see its contents!`, "text-cyan-400 font-bold");
                        itemType = 'special';
                        renderDungeon(); // Refresh the dungeon view
                    } else {
                        const layerKeys = ['chests', 'monsters', 'miniBosses', 'merchants', 'stairs', 'bosses'];
                        const layerNames = ['Chests', 'Monsters', 'Mini-Bosses', 'Merchants', 'Stairs', 'Bosses'];
                        const layerKey = layerKeys[data[3]];
                        const layerName = layerNames[data[3]];
                        
                        stats.hasMap = true; // Enable map if not already enabled
                        stats.ownedMapLayers[layerKey] = true; // Mark layer as owned
                        stats.mapLayers[layerKey] = true; // Enable this specific layer
                        addLog(`${layerName} Map Layer purchased! ${layerName} are now visible on your dungeon map!`, "text-cyan-400 font-bold");
                        itemType = 'special';
                        renderDungeon(); // Refresh the dungeon view to show new markers
                    }
                }
                
                updateUI();
                addLog(`Purchased ${name}!`, "text-green-400");
                renderShop();
                
                // Ask if they want to equip it (only for weapons and armor)
                if(itemType === 'weapon' || itemType === 'armor') {
                    setTimeout(() => showEquipPrompt(name, itemType), 300);
                }
            } else {
                addLog("Not enough gold!", "text-red-500 font-bold");
            }
        }

        function showEquipPrompt(name, itemType) {
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.9);display:flex;align-items:center;justify-content:center;z-index:10000;';
            
            let html = '<div style="background:#1e293b;padding:2rem;border-radius:10px;max-width:400px;width:90%;">';
            html += '<h2 style="font-size:1.3rem;font-weight:bold;margin-bottom:1rem;text-align:center;color:white;">EQUIP ITEM?</h2>';
            html += '<div style="background:#0f172a;padding:1.5rem;border-radius:8px;margin-bottom:1rem;border:2px solid #334155;text-align:center;">';
            html += `<div style="font-size:1.1rem;font-weight:bold;color:#fbbf24;text-transform:uppercase;margin-bottom:0.5rem;">${name}</div>`;
            html += `<div style="font-size:0.9rem;color:#94a3b8;">Would you like to equip this ${itemType} now?</div>`;
            html += '</div>';
            html += `<div style="font-size:0.8rem;color:#64748b;text-align:center;margin-bottom:1.5rem;font-style:italic;">You can always change equipment in your inventory</div>`;
            html += '<div style="display:flex;gap:0.75rem;">';
            html += `<button onclick="equipNewItem('${name}', '${itemType}')" style="flex:1;padding:0.75rem;background:#3b82f6;border-radius:8px;font-weight:bold;color:white;font-size:0.95rem;cursor:pointer;border:none;">EQUIP NOW</button>`;
            html += '<button onclick="closeEquipModal()" style="flex:1;padding:0.75rem;background:#64748b;border-radius:8px;font-weight:bold;color:white;font-size:0.95rem;cursor:pointer;border:none;">LATER</button>';
            html += '</div>';
            html += '</div>';
            
            modal.innerHTML = html;
            modal.id = 'equip-modal';
            document.body.appendChild(modal);
        }

        function equipNewItem(name, itemType) {
            closeEquipModal();
            
            if(itemType === 'weapon') {
                stats.equippedWeapon = name;
                const weaponData = stats.weapons[name];
                if (weaponData && typeof weaponData === 'object' && weaponData.unique) {
                    stats.attackBonus = weaponData.attackBonus || 0;
                    let equipText = `Equipped ${name}!`;
                    if (weaponData.damageFormula) {
                        equipText += ` (${weaponData.damageFormula} damage`;
                        if (weaponData.attackBonus > 0) {
                            equipText += `, +${weaponData.attackBonus} attack rolls`;
                        }
                        equipText += ')';
                    } else if (weaponData.attackBonus > 0) {
                        equipText += ` (+${weaponData.attackBonus} attack rolls)`;
                    }
                    addLog(equipText, "text-blue-400");
                } else {
                    stats.attackBonus = 0;
                    addLog(`Equipped ${name}!`, "text-blue-400");
                }
            } else if(itemType === 'armor') {
                stats.equippedArmor = name;
                const armorData = stats.armors[name];
                if (armorData && typeof armorData === 'object' && armorData.unique) {
                    stats.armor = armorData.ac || 9;
                    stats.acBonus = armorData.acBonus || 0;
                    let equipText = `Equipped ${name}! (AC ${armorData.ac || 9}`;
                    if (armorData.acBonus > 0) {
                        equipText += ` + ${armorData.acBonus}`;
                    }
                    if (armorData.conditionalBonus) {
                        const cond = armorData.conditionalBonus;
                        if (cond.type === 'lowHP') {
                            equipText += `, +${cond.bonus} when HP ‚â§ ${cond.threshold}`;
                        } else if (cond.type === 'percentHP') {
                            const percent = Math.round(cond.threshold * 100);
                            equipText += `, +${cond.bonus} when HP ‚â§ ${percent}%`;
                        } else if (cond.type === 'highHP') {
                            equipText += `, +${cond.bonus} when HP ‚â• ${cond.threshold}`;
                        }
                    }
                    equipText += ')';
                    addLog(equipText, "text-blue-400");
                } else {
                    stats.armor = typeof armorData === 'number' ? armorData : 9;
                    stats.acBonus = 0;
                    addLog(`Equipped ${name}!`, "text-blue-400");
                }
            }
            
            updateUI();
        }

        function closePurchaseModal() {
            const modal = document.getElementById('purchase-modal');
            if (modal) modal.remove();
        }

        function closeEquipModal() {
            const modal = document.getElementById('equip-modal');
            if (modal) modal.remove();
        }

        function buyItem(name, data) {
            // Legacy function kept for compatibility
            showPurchaseConfirmation(name, data);
        }

        function sellItem(name, type) {
            const data = SHOP_DATA[name];
            const price = Math.floor(data[0] / 2);
            stats.coins += price;
            
            if (type === "Weapon") {
                if(stats.equippedWeapon === name) stats.equippedWeapon = "stick";
                delete stats.weapons[name];
            } else if (type === "Armor") {
                if(stats.equippedArmor === name) stats.equippedArmor = "none";
                delete stats.armors[name];
                stats.armor = Math.max(...Object.values(stats.armors));
            } else if (type === "Potion") {
                stats.potions[name][0]--;
                if(stats.potions[name][0] <= 0) delete stats.potions[name];
            } else if (type === "Spell") {
                stats.spells[name][0]--;
                if(stats.spells[name][0] <= 0) delete stats.spells[name];
            }
            
            updateUI();
            addLog(`Sold ${name} for ${price}G`, "text-yellow-500");
            renderShop();
        }

        // --- INVENTORY MANAGEMENT ---
        function renderInventory() {
            // Ensure all weapons have durability initialized
            ensureAllWeaponsInitialized();
            
            const wList = document.getElementById('inv-weapons');
            const aList = document.getElementById('inv-armors');
            const cList = document.getElementById('inv-consumables');
            const tList = document.getElementById('inv-tools');
            wList.innerHTML = ''; aList.innerHTML = ''; cList.innerHTML = ''; tList.innerHTML = '';

            for(let name in stats.weapons) {
                const b = document.createElement('button');
                const isEquipped = stats.equippedWeapon === name;
                const weaponData = stats.weapons[name];
                let tier = 1;
                let attackBonus = 0;
                let damageDesc = '';
                let durabilityText = '';
                let durabilityColor = '';
                let conditionalDamageText = '';
                
                if (weaponData && typeof weaponData === 'object' && weaponData.unique) {
                    if (weaponData.damageFormula) {
                        // Custom damage formula
                        damageDesc = weaponData.damageFormula;
                        attackBonus = weaponData.attackBonus || 0;
                    } else if (weaponData.conditionalBonus && weaponData.conditionalBonus.baseDamage) {
                        // Has conditional bonus with base damage
                        damageDesc = weaponData.conditionalBonus.baseDamage;
                        attackBonus = weaponData.attackBonus || 0;
                    } else {
                        // Standard tier-based
                        tier = weaponData.tier || 1;
                        damageDesc = getWeaponDamageDesc(tier);
                        attackBonus = weaponData.attackBonus || 0;
                    }
                    
                    // Check for conditional damage bonuses
                    if (weaponData.conditionalBonus) {
                        const cond = weaponData.conditionalBonus;
                        if (cond.type === 'lowHP') {
                            conditionalDamageText = `+${cond.bonus} damage when HP ‚â§ ${cond.threshold}`;
                        } else if (cond.type === 'boss') {
                            conditionalDamageText = `+${cond.bonus} damage vs bosses`;
                        } else if (cond.type === 'miniBoss') {
                            conditionalDamageText = `+${cond.bonus} damage vs mini-bosses/bosses`;
                        } else if (cond.type === 'floor') {
                            conditionalDamageText = `+${cond.bonus} damage per floor`;
                        } else if (cond.type === 'floorParity') {
                            if (cond.evenBonus > 0 && cond.oddBonus > 0) {
                                conditionalDamageText = `+${cond.evenBonus} dmg on even floors, +${cond.oddBonus} on odd`;
                            } else if (cond.evenBonus > 0) {
                                conditionalDamageText = `+${cond.evenBonus} damage on even floors`;
                            } else if (cond.oddBonus > 0) {
                                conditionalDamageText = `+${cond.oddBonus} damage on odd floors`;
                            }
                        }
                    }
                } else if (weaponData && typeof weaponData === 'object') {
                    // New format with durability
                    tier = weaponData.tier || 1;
                    damageDesc = getWeaponDamageDesc(tier);
                    attackBonus = weaponData.attackBonus || 0;
                } else if (weaponData) {
                    tier = typeof weaponData === 'number' ? weaponData : 1;
                    damageDesc = getWeaponDamageDesc(tier);
                } else {
                    damageDesc = getWeaponDamageDesc(1);
                }
                
                // Handle durability display
                if (weaponData && typeof weaponData === 'object' && weaponData.durability !== undefined) {
                    const durPercent = (weaponData.durability / weaponData.maxDurability) * 100;
                    let barColor = '#10b981'; // Green by default
                    if (durPercent <= 20) {
                        barColor = '#dc2626'; // Red - critical
                    } else if (durPercent <= 50) {
                        barColor = '#ea580c'; // Orange - damaged
                    }
                    durabilityText = `
                        <div style="margin-top:0.5rem;position:relative;">
                            <div style="width:100%;height:8px;background:#1e293b;border-radius:4px;overflow:hidden;border:1px solid #334155;cursor:pointer;" title="${weaponData.durability}/${weaponData.maxDurability}">
                                <div style="height:100%;width:${durPercent}%;background:${barColor};transition:width 0.3s ease;"></div>
                            </div>
                            <div style="position:absolute;top:-24px;left:50%;transform:translateX(-50%);background:#0f172a;color:#fbbf24;padding:4px 8px;border-radius:4px;font-size:0.75rem;font-weight:bold;white-space:nowrap;border:1px solid #334155;opacity:0;pointer-events:none;transition:opacity 0.2s ease;z-index:100;" class="durability-tooltip">
                                ${weaponData.durability}/${weaponData.maxDurability}
                            </div>
                        </div>
                    `;
                }
                
                b.className = `w-full p-3 text-left border border-slate-700 rounded transition-all ${isEquipped?'equipped':'bg-slate-800/40 hover:bg-slate-700'}`;
                const tierText = weaponData && typeof weaponData === 'object' && weaponData.unique && (weaponData.damageFormula || (weaponData.conditionalBonus && weaponData.conditionalBonus.baseDamage)) ? 'CUSTOM' : `TIER ${tier}`;
                b.innerHTML = `
                    <div class="flex justify-between items-center">
                        <span class="text-base font-bold uppercase">${name}</span>
                        <span class="text-sm text-slate-500 font-bold">${tierText}${attackBonus > 0 ? ` (+${attackBonus})` : ''}</span>
                    </div>
                    <div class="text-sm text-green-400 font-bold mt-1">${damageDesc}</div>
                    ${attackBonus > 0 ? `<div class="text-xs text-blue-400 font-bold mt-1">+${attackBonus} attack rolls</div>` : ''}
                    ${conditionalDamageText ? `<div class="text-xs text-cyan-400 font-bold mt-1">${conditionalDamageText}</div>` : ''}
                    ${durabilityText}
                    ${isEquipped ? '<div class="text-xs text-yellow-500 font-black mt-1 uppercase italic tracking-widest">EQUIPPED</div>' : ''}
                `;
                b.onclick = () => { 
                    stats.equippedWeapon = name;
                    if (weaponData && typeof weaponData === 'object' && weaponData.unique) {
                        stats.attackBonus = weaponData.attackBonus || 0;
                        addLog(`Equipped ${name}! (+${weaponData.attackBonus || 0} attack rolls)`);
                    } else {
                        stats.attackBonus = 0;
                        addLog(`Equipped ${name}!`);
                    }
                    renderInventory(); 
                    updateUI();
                };
                wList.appendChild(b);
                
                // Add hover listeners for durability tooltip
                const durabilityBar = b.querySelector('[style*="background:#1e293b"]');
                if (durabilityBar) {
                    const tooltip = b.querySelector('.durability-tooltip');
                    if (tooltip) {
                        durabilityBar.addEventListener('mouseenter', () => {
                            tooltip.style.opacity = '1';
                        });
                        durabilityBar.addEventListener('mouseleave', () => {
                            tooltip.style.opacity = '0';
                        });
                    }
                }
            }

            for(let name in stats.armors) {
                const b = document.createElement('button');
                const isEquipped = stats.equippedArmor === name;
                const armorData = stats.armors[name];
                let ac = 9;
                let acBonus = 0;
                let conditionalText = '';
                if (armorData && typeof armorData === 'object' && armorData.unique) {
                    ac = armorData.ac || 9;
                    acBonus = armorData.acBonus || 0;
                    // Check for conditional bonus
                    if (armorData.conditionalBonus) {
                        const cond = armorData.conditionalBonus;
                        if (cond.type === 'lowHP') {
                            conditionalText = `+${cond.bonus} AC when HP ‚â§ ${cond.threshold}`;
                        } else if (cond.type === 'percentHP') {
                            const percent = Math.round(cond.threshold * 100);
                            conditionalText = `+${cond.bonus} AC when HP ‚â§ ${percent}%`;
                        } else if (cond.type === 'highHP') {
                            conditionalText = `+${cond.bonus} AC when HP ‚â• ${cond.threshold}`;
                        } else if (cond.type === 'coins') {
                            conditionalText = `+${cond.bonus} AC when coins ‚â• ${cond.threshold}`;
                        } else if (cond.type === 'boss') {
                            conditionalText = `+${cond.bonus} AC vs bosses`;
                        } else if (cond.type === 'miniBoss') {
                            conditionalText = `+${cond.bonus} AC vs mini-bosses/bosses`;
                        } else if (cond.type === 'floorParity') {
                            if (cond.evenBonus > 0 && cond.oddBonus > 0) {
                                conditionalText = `+${cond.evenBonus} AC on even floors, +${cond.oddBonus} on odd`;
                            } else if (cond.evenBonus > 0) {
                                conditionalText = `+${cond.evenBonus} AC on even floors`;
                            } else if (cond.oddBonus > 0) {
                                conditionalText = `+${cond.oddBonus} AC on odd floors`;
                            }
                        }
                    }
                } else if (armorData) {
                    ac = typeof armorData === 'number' ? armorData : 9;
                }
                b.className = `w-full p-3 text-left border border-slate-700 rounded transition-all ${isEquipped?'equipped':'bg-slate-800/40 hover:bg-slate-700'}`;
                const maxAC = ac + acBonus + (armorData && typeof armorData === 'object' && armorData.unique && armorData.conditionalBonus ? armorData.conditionalBonus.bonus : 0);
                b.innerHTML = `
                    <div class="flex justify-between items-center">
                        <span class="text-base font-bold uppercase">${name}</span>
                        <span class="text-sm text-slate-500 font-bold">AC ${ac}${acBonus > 0 ? ` (+${acBonus})` : ''}${conditionalText ? ` (max ${maxAC})` : ''}</span>
                    </div>
                    ${acBonus > 0 ? `<div class="text-xs text-blue-400 font-bold mt-1">+${acBonus} AC bonus</div>` : ''}
                    ${conditionalText ? `<div class="text-xs text-cyan-400 font-bold mt-1">${conditionalText}</div>` : ''}
                    ${isEquipped ? '<div class="text-xs text-yellow-500 font-black mt-1 uppercase italic tracking-widest">EQUIPPED</div>' : ''}
                `;
                b.onclick = () => { 
                    stats.equippedArmor = name;
                    if (armorData && typeof armorData === 'object' && armorData.unique) {
                        stats.armor = armorData.ac || 9;
                        stats.acBonus = armorData.acBonus || 0;
                        const condBonus = armorData.conditionalBonus ? ` (conditional: ${conditionalText})` : '';
                        addLog(`Equipped ${name}! (AC ${armorData.ac || 9}${armorData.acBonus ? ` + ${armorData.acBonus}` : ''}${condBonus})`);
                    } else {
                        stats.armor = typeof armorData === 'number' ? armorData : 9;
                        stats.acBonus = 0;
                        addLog(`Equipped ${name}!`);
                    }
                    renderInventory(); 
                    updateUI();
                };
                aList.appendChild(b);
            }

            const consumables = {...stats.potions, ...stats.spells};
            for(let name in consumables) {
                const count = consumables[name][0];
                if(count <= 0) continue;
                
                // Check if this is a healing potion - only healing potions can be used outside combat
                const isHealingPotion = name === 'healing potion';
                const canUse = isHealingPotion && stats.HP < stats.maxHP;
                
                const div = document.createElement('div');
                div.className = `p-3 bg-slate-900 border border-slate-800 rounded ${canUse ? 'cursor-pointer hover:bg-slate-800 transition-colors' : ''}`;
                
                const content = `
                    <div class="flex justify-between items-center">
                        <span class="text-base font-bold uppercase text-slate-300">${name}</span>
                        <div class="flex items-center gap-2">
                            <span class="bg-blue-900/40 px-3 py-1 rounded text-blue-400 font-bold text-sm">x${count}</span>
                            ${canUse ? '<button class="bg-green-700 hover:bg-green-600 px-4 py-2 rounded text-sm font-bold text-white">USE</button>' : ''}
                        </div>
                    </div>
                `;
                
                div.innerHTML = content;
                
                if(canUse) {
                    div.onclick = () => useItemFromInventory(name);
                }
                
                cList.appendChild(div);
            }
            if(cList.innerHTML === '') cList.innerHTML = '<div class="text-sm text-slate-600 uppercase font-bold text-center py-4">No Consumables</div>';
            
            // Tools section - show map if owned
            if (stats.hasMap) {
                const mapDiv = document.createElement('div');
                mapDiv.className = 'p-4 bg-slate-900 border-2 border-emerald-700 rounded';
                
                // Map layers header
                let mapHTML = '<div class="mb-3">';
                mapHTML += '<div class="text-lg font-bold uppercase text-emerald-400 mb-2 flex items-center gap-2">';
                mapHTML += '<span>üó∫Ô∏è Dungeon Map Layers</span>';
                mapHTML += '</div>';
                mapHTML += '<div class="text-xs text-slate-400 mb-3">Toggle which room types are visible on your map</div>';
                mapHTML += '</div>';
                
                // Map layer toggles
                mapHTML += '<div class="grid grid-cols-2 gap-2 mb-3">';
                
                const layers = [
                    {key: 'chests', name: 'Chests', icon: 'üí∞', color: 'yellow'},
                    {key: 'monsters', name: 'Monsters', icon: 'üëπ', color: 'purple'},
                    {key: 'miniBosses', name: 'Mini-Bosses', icon: '‚öî', color: 'orange'},
                    {key: 'merchants', name: 'Merchants', icon: 'üì¶', color: 'amber'},
                    {key: 'stairs', name: 'Stairs', icon: '‚¨á', color: 'green'},
                    {key: 'bosses', name: 'Bosses', icon: 'üëë', color: 'red'}
                ];
                
                // Only show layers that have been purchased
                for (const layer of layers) {
                    // Skip if not owned
                    if (!stats.ownedMapLayers[layer.key]) continue;
                    
                    const isEnabled = stats.mapLayers[layer.key];
                    const bgColor = isEnabled ? `bg-${layer.color}-900/50` : 'bg-slate-800';
                    const borderColor = isEnabled ? `border-${layer.color}-600` : 'border-slate-700';
                    const textColor = isEnabled ? `text-${layer.color}-400` : 'text-slate-500';
                    
                    mapHTML += `<button 
                        onclick="toggleMapLayer('${layer.key}')"
                        class="p-2 ${bgColor} border ${borderColor} rounded hover:opacity-80 transition-all">
                        <div class="text-lg mb-1">${layer.icon}</div>
                        <div class="text-xs font-bold ${textColor}">${layer.name}</div>
                        <div class="text-xs ${isEnabled ? 'text-emerald-400' : 'text-slate-600'} font-bold mt-1">
                            ${isEnabled ? 'ON' : 'OFF'}
                        </div>
                    </button>`;
                }
                
                mapHTML += '</div>';
                mapHTML += '<button onclick="showMapLegend()" class="w-full bg-blue-700 hover:bg-blue-600 px-4 py-2 rounded text-sm font-bold text-white">VIEW LEGEND</button>';
                
                mapDiv.innerHTML = mapHTML;
                tList.appendChild(mapDiv);
            }
            
            if(tList.innerHTML === '') tList.innerHTML = '<div class="text-sm text-slate-600 uppercase font-bold text-center py-4">No Tools</div>';
        }
        
        function showMapLegend() {
            const modal = document.createElement('div');
            modal.id = 'map-legend-modal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.9); z-index: 9999;
                display: flex; align-items: center; justify-content: center;
            `;
            
            modal.innerHTML = `
                <div style="background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%); 
                    border: 3px solid #10b981; border-radius: 12px; padding: 32px; 
                    max-width: 500px; width: 90%; box-shadow: 0 20px 60px rgba(16, 185, 129, 0.4);">
                    <h2 style="font-size: 24px; font-weight: bold; color: #10b981; 
                        text-align: center; margin-bottom: 16px; text-transform: uppercase;">
                        üó∫Ô∏è Dungeon Map Legend
                    </h2>
                    <p style="text-align: center; color: #cbd5e1; margin-bottom: 24px; font-size: 14px;">
                        Map symbols and their meanings
                    </p>
                    <div style="background: #0f172a; padding: 20px; border-radius: 8px; margin-bottom: 16px; border: 2px solid #334155;">
                        <div style="display: flex; flex-direction: column; gap: 12px;">
                            <div style="display: flex; align-items: center; gap: 12px;">
                                <div style="width: 32px; height: 32px; background: #3b82f6; border-radius: 4px; display: flex; align-items: center; justify-content: center; box-shadow: 0 0 10px rgba(59, 130, 246, 0.5);"></div>
                                <div style="flex: 1;">
                                    <div style="color: #3b82f6; font-weight: bold; font-size: 14px;">Your Position</div>
                                    <div style="color: #94a3b8; font-size: 12px;">Where you are currently located</div>
                                </div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 12px;">
                                <div style="width: 32px; height: 32px; background: #dc2626; border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 18px;">üëë</div>
                                <div style="flex: 1;">
                                    <div style="color: #dc2626; font-weight: bold; font-size: 14px;">Boss</div>
                                    <div style="color: #94a3b8; font-size: 12px;">Powerful enemy, drops key</div>
                                </div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 12px;">
                                <div style="width: 32px; height: 32px; background: #ea580c; border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 18px;">‚öî</div>
                                <div style="flex: 1;">
                                    <div style="color: #ea580c; font-weight: bold; font-size: 14px;">Mini-Boss</div>
                                    <div style="color: #94a3b8; font-size: 12px;">Tough enemy, good rewards</div>
                                </div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 12px;">
                                <div style="width: 32px; height: 32px; background: #15803d; border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 18px;">‚¨á</div>
                                <div style="flex: 1;">
                                    <div style="color: #15803d; font-weight: bold; font-size: 14px;">Stairs Down</div>
                                    <div style="color: #94a3b8; font-size: 12px;">Descend to next floor</div>
                                </div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 12px;">
                                <div style="width: 32px; height: 32px; background: #b45309; border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 18px;">üì¶</div>
                                <div style="flex: 1;">
                                    <div style="color: #b45309; font-weight: bold; font-size: 14px;">Merchant</div>
                                    <div style="color: #94a3b8; font-size: 12px;">Dungeon shopkeeper</div>
                                </div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 12px;">
                                <div style="width: 32px; height: 32px; background: #1e293b; border: 2px solid #475569; border-radius: 4px;"></div>
                                <div style="flex: 1;">
                                    <div style="color: #94a3b8; font-weight: bold; font-size: 14px;">Empty Room</div>
                                    <div style="color: #64748b; font-size: 12px;">May contain chests or monsters</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <button onclick="closeMapLegend()" 
                        style="width: 100%; padding: 12px; background: #10b981; border-radius: 8px; 
                        font-weight: bold; color: white; cursor: pointer; border: none; font-size: 16px;">
                        CLOSE
                    </button>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        function closeMapLegend() {
            const modal = document.getElementById('map-legend-modal');
            if (modal) modal.remove();
        }
        
        function toggleMapLayer(layerKey) {
            stats.mapLayers[layerKey] = !stats.mapLayers[layerKey];
            renderInventory(); // Refresh inventory to show updated toggle states
            // Always refresh dungeon map if it exists (even if currently hidden by inventory)
            renderDungeon(); // This will update the map for when inventory closes
        }

        // --- USE ITEMS FROM INVENTORY (OUTSIDE COMBAT) ---
        function useItemFromInventory(name) {
            if (name === 'healing potion') {
                if (stats.HP >= stats.maxHP) {
                    addLog("Already at full health!", "text-slate-400");
                    return;
                }
                
                if (!stats.potions[name] || stats.potions[name][0] <= 0) {
                    addLog("No healing potions left!", "text-red-400");
                    return;
                }
                
                stats.potions[name][0]--;
                const heal = (Math.floor(Math.random()*4)+1) + (Math.floor(Math.random()*4)+1);
                stats.HP = Math.min(stats.maxHP, stats.HP + heal);
                addLog(`Drank healing potion - Healed ${heal} HP`, "text-green-400");
                
                if(stats.potions[name][0] <= 0) {
                    delete stats.potions[name];
                }
                
                updateUI();
                renderInventory();
            }
        }

        // --- ITEMS IN COMBAT ---
        function renderCombatInventory() {
            const list = document.getElementById('combat-inventory-list');
            list.innerHTML = '';
            const items = {...stats.potions, ...stats.spells};
            for (const [name, data] of Object.entries(items)) {
                if (data[0] > 0) {
                    const b = document.createElement('button');
                    b.className = "w-full p-3 bg-slate-800 text-sm text-left flex justify-between rounded px-4 border border-slate-700 hover:bg-slate-700";
                    b.innerHTML = `<span class="uppercase font-bold text-white">${name}</span><span class="text-yellow-500 font-bold">x${data[0]}</span>`;
                    b.onclick = () => useItem(name);
                    list.appendChild(b);
                }
            }
        }

        function renderAchievements() {
            const list = document.getElementById('achievements-list');
            list.innerHTML = '';
            
            let totalEarned = Object.keys(stats.achievements).length;
            const totalAchievements = Object.keys(ACHIEVEMENTS).length;
            
            // Progress bar
            const progressDiv = document.createElement('div');
            progressDiv.className = 'mb-6 p-4 bg-slate-900 rounded border border-slate-800';
            const progress = Math.round((totalEarned / totalAchievements) * 100);
            progressDiv.innerHTML = `
                <div class="flex justify-between items-center mb-2">
                    <span class="text-lg font-bold">Progress: ${totalEarned}/${totalAchievements}</span>
                    <span class="text-yellow-500 font-bold">${progress}%</span>
                </div>
                <div class="w-full h-3 bg-slate-800 rounded overflow-hidden">
                    <div class="h-full bg-yellow-500 transition-all" style="width: ${progress}%"></div>
                </div>
            `;
            list.appendChild(progressDiv);
            
            // Difficulty color mapping
            const difficultyColors = {
                easy: 'text-green-400',
                medium: 'text-blue-400',
                hard: 'text-red-400'
            };
            
            const difficultyEmoji = {
                easy: '‚≠ê',
                medium: '‚≠ê‚≠ê',
                hard: '‚≠ê‚≠ê‚≠ê'
            };
            
            // Achievement items
            for (const [key, achievement] of Object.entries(ACHIEVEMENTS)) {
                const isEarned = stats.achievements[key];
                const div = document.createElement('div');
                div.className = `p-4 rounded border-2 transition-all ${isEarned ? 'bg-slate-900 border-yellow-500' : 'bg-slate-950 border-slate-800 opacity-60'}`;
                
                const diffColor = difficultyColors[achievement.difficulty] || 'text-slate-400';
                const diffEmoji = difficultyEmoji[achievement.difficulty] || '';
                
                div.innerHTML = `
                    <div class="flex items-start gap-4">
                        <div class="text-3xl">${isEarned ? 'üèÜ' : 'üîí'}</div>
                        <div class="flex-1">
                            <div class="flex items-center justify-between mb-1">
                                <h3 class="text-lg font-bold ${isEarned ? 'text-yellow-400' : 'text-slate-400'}">${achievement.name}</h3>
                                <span class="${diffColor} font-bold text-sm">${diffEmoji}</span>
                            </div>
                            <p class="text-sm text-slate-500 mt-1">${achievement.desc}</p>
                            <div class="flex justify-between items-center mt-2">
                                <div class="text-xs ${diffColor} font-bold">Reward: +${achievement.reward} Gold</div>
                                ${isEarned ? '<div class="text-green-400 font-bold text-xs">UNLOCKED ‚úì</div>' : ''}
                            </div>
                        </div>
                    </div>
                `;
                list.appendChild(div);
            }
        }

        async function useItem(name) {
            if (isProcessing) return;
            isProcessing = true;
            const isPotion = stats.potions[name];
            const itemData = isPotion || stats.spells[name];
            if(isPotion) {
                stats.potions[name][0]--;
                const typeId = itemData[1];
                const effectValue = itemData[2] || 0;
                addLog(`Drank ${name}`, "text-blue-300");
                
                // Check if it's a unique merchant potion (has effectValue)
                if (effectValue > 0) {
                    if(typeId === 1 || typeId === 2) {
                        stats.temporary_allRollsBonus = effectValue;
                        addLog(`+${effectValue} to all rolls for this turn!`, "text-cyan-400 font-bold");
                    } else if(typeId === 3 || typeId === 5) {
                        stats.temporary_acBonus = effectValue;
                        addLog(`+${effectValue} AC for this turn!`, "text-blue-400 font-bold");
                    } else if(typeId === 4 || typeId === 6) {
                        stats.temporary_attackBonus = effectValue;
                        addLog(`+${effectValue} attack rolls for this turn!`, "text-purple-400 font-bold");
                    } else if(typeId === 7) {
                        stats.temporary_allRollsBonus = effectValue;
                        addLog(`+${effectValue} to all rolls for this turn!`, "text-cyan-400 font-bold");
                    }
                } else {
                    // Regular potions
                    if(typeId === 1) {
                        const heal = (Math.floor(Math.random()*4)+1) + (Math.floor(Math.random()*4)+1);
                        stats.HP = Math.min(stats.maxHP, stats.HP + heal);
                        addLog(`Healed ${heal} HP`, "text-green-400");
                    } else if(typeId === 2) stats.temporary_intelligence = 6;
                    else if(typeId === 3) stats.temporary_dexterity = 6;
                    else if(typeId === 4) stats.temporary_strength = 6;
                    else if(typeId === 5) stats.temporary_armor = 3;
                }
                
                if(stats.potions[name][0] <= 0) delete stats.potions[name];
                isProcessing = false;
                monsterTurnStart();
            } else {
                stats.spells[name][0]--;
                const typeId = itemData[1];
                const need = typeId===1?10 : typeId===2?11 : typeId===3?12 : typeId===4?10 : 11;
                await logLoading("Casting...", 3, 120);
                const roll = Math.floor(Math.random()*20)+1 + Math.floor(stats.wisdom/2)-5;
                addLog(`Wis Roll: ${roll} vs ${need}`);
                if(roll >= need) {
                    stats.spellsCast++;
                    addLog("Spell Success!", "text-purple-400 font-bold");
                    if(typeId===2) { combatData.strength -= 2; combatData.change_strength = true; }
                    if(typeId===4) combatData.freeze = 2;
                    if(typeId===5) combatData.fire = true;
                    let dmg = 0;
                    if(typeId===1 || typeId===2) dmg = Math.floor(Math.random()*8)+1;
                    else if(typeId===3) dmg = Math.floor(Math.random()*6)+Math.floor(Math.random()*6)+Math.floor(Math.random()*10)+3;
                    else if(typeId===4) dmg = Math.floor(Math.random()*6)+1;
                    else if(typeId===5) dmg = Math.floor(Math.random()*15)+5;
                    addLog(`Spell dealt ${dmg} damage`, "text-purple-300");
                    combatData.HP -= dmg;
                    if(combatData.HP <= 0) { 
                        isProcessing = false;
                        await victory(); 
                        return; 
                    }
                } else addLog("Spell Fizzled!", "text-slate-500");
                if(stats.spells[name][0] <= 0) delete stats.spells[name];
                isProcessing = false;
                updateUI();
                monsterTurnStart();
                return;
            }
            updateUI();
        }

        addLog("Welcome to Oakhaven.", "text-slate-500 italic");
        
        // Check authentication on page load
        checkAuth().then(authenticated => {
            if (authenticated) {
                console.log('User authenticated for Dungeon Game');
            }
        });
        
        // Cheat codes: Type "coins" to get 5000 gold, "best" for best gear, "win" for auto-win mode
        let cheatBuffer = '';
        let winMode = false; // Auto-defeat monsters when true
        document.addEventListener('keydown', function(event) {
            // Skip if typing in an input field
            if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
                return;
            }
            
            // Add the key to the buffer
            cheatBuffer += event.key.toLowerCase();
            
            // Keep only the last 10 characters (to catch "best" and "coins")
            if (cheatBuffer.length > 10) {
                cheatBuffer = cheatBuffer.slice(-10);
            }
            
            // Check if buffer ends with "coins"
            if (cheatBuffer.endsWith('coins')) {
                stats.coins += 5000;
                addLog('CHEAT: +5000 Gold!', 'text-yellow-400 font-bold');
                updateUI();
                cheatBuffer = ''; // Reset buffer
            }
            // Check if buffer ends with "win"
            else if (cheatBuffer.endsWith('win')) {
                winMode = true;
                addLog('CHEAT: Win mode activated! You can now auto-defeat monsters.', 'text-yellow-400 font-bold');
                cheatBuffer = ''; // Reset buffer
            }
            // Check if buffer ends with "fight"
            else if (cheatBuffer.endsWith('fight')) {
                winMode = false;
                addLog('CHEAT: Win mode deactivated.', 'text-yellow-400 font-bold');
                cheatBuffer = ''; // Reset buffer
            }
            // Check if buffer ends with "best"
            else if (cheatBuffer.endsWith('best')) {
                // Set all stats to 20
                stats.strength = 20;
                stats.dexterity = 20;
                stats.intelligence = 20;
                stats.wisdom = 20;
                
                // Give great sword (tier 6) and equip it
                const greatSwordData = { tier: 6 };
                initializeWeaponDurability('great sword', greatSwordData);
                stats.weapons['great sword'] = greatSwordData;
                stats.equippedWeapon = 'great sword';
                stats.attackBonus = 0;
                
                // Give platemail (AC 15) and equip it
                stats.armors['platemail'] = 15;
                stats.equippedArmor = 'platemail';
                stats.armor = 15;
                stats.acBonus = 0;
                
                // Give 10 checkpoints
                stats.checkpointsPurchased += 10;
                
                // Give all map layers
                stats.hasMap = true;
                stats.ownedMapLayers.chests = true;
                stats.ownedMapLayers.monsters = true;
                stats.ownedMapLayers.miniBosses = true;
                stats.ownedMapLayers.merchants = true;
                stats.ownedMapLayers.stairs = true;
                stats.ownedMapLayers.bosses = true;
                stats.mapLayers.chests = true;
                stats.mapLayers.monsters = true;
                stats.mapLayers.miniBosses = true;
                stats.mapLayers.merchants = true;
                stats.mapLayers.stairs = true;
                stats.mapLayers.bosses = true;
                
                addLog('CHEAT: Best gear activated! All stats set to 20!', 'text-yellow-400 font-bold');
                addLog('Equipped Great Sword (Tier 6) and Platemail (AC 15)!', 'text-blue-400');
                addLog(`Gained 10 checkpoints (Total: ${stats.checkpointsPurchased}) and unlocked all map layers!`, 'text-cyan-400');
                
                updateUI();
                if (stats.location === 'dungeon') {
                    renderDungeon(); // Refresh dungeon view to show map markers
                }
                cheatBuffer = ''; // Reset buffer
            }
        });
    </script>

        </main>
        <div class="push"></div>
    </div>

    <footer>
        <p>&copy; 2025 Ahrens Labs. All rights reserved.</p>
    </footer>
</body>
</html>
