z`<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dungeon Game - Ahrens Labs</title>
    
    <!-- Google Fonts Links -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Orbitron&family=Roboto+Mono&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="css/style.css">
    <link rel="icon" type="image/x-icon" href="/img/favicon.ico">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    
    <style>
        :root {
            --bg-primary: #020617;
            --bg-secondary: #0f172a;
            --bg-tertiary: #1e293b;
            --text-primary: #e2e8f0;
            --text-secondary: #94a3b8;
            --text-muted: #64748b;
            --border-color: #334155;
            --border-light: #475569;
            --bg-log: #0f172a;
            --text-log: #e2e8f0;
        }

        body.light-theme {
            --bg-primary: #f8fafc;
            --bg-secondary: #f1f5f9;
            --bg-tertiary: #e2e8f0;
            --text-primary: #1e293b;
            --text-secondary: #475569;
            --text-muted: #64748b;
            --border-color: #cbd5e1;
            --border-light: #e2e8f0;
            --bg-log: #f1f5f9;
            --text-log: #1e293b;
        }

        body { 
            font-family: 'JetBrains+Mono', monospace; 
            overflow-x: hidden;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            transition: background-color 0.3s, color 0.3s;
        }
        
        .custom-scrollbar::-webkit-scrollbar { width: 4px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: var(--bg-secondary); }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 10px; }
        .combat-active { animation: pulse-red 2s infinite; }
        @keyframes pulse-red { 0%, 100% { background-color: rgba(220, 38, 38, 0.05); } 50% { background-color: rgba(220, 38, 38, 0.15); } }
        .equipped { border-color: #fbbf24 !important; background-color: rgba(251, 191, 36, 0.1) !important; }
        
        /* Game wrapper styles */
        .game-wrapper {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            min-height: calc(100vh - 200px);
            padding: 2rem 1rem;
            transition: background-color 0.3s, color 0.3s;
        }

        /* Theme toggle button */
        #theme-toggle-btn {
            padding: 8px 16px;
            background: #6366f1;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9em;
            transition: all 0.3s;
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #theme-toggle-btn:hover {
            background: #4f46e5;
        }

        /* Combat menu boxes styling */
        #combat-main-menu button,
        #combat-direction-menu button,
        #combat-defense-menu button,
        #combat-items-menu button {
            border: 2px solid #334155 !important;
            transition: all 0.2s !important;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.5) !important;
        }
        
        #combat-main-menu button:hover,
        #combat-direction-menu button:hover,
        #combat-defense-menu button:hover,
        #combat-items-menu button:hover {
            border-color: #475569 !important;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.5), 0 0 8px rgba(255,255,255,0.1) !important;
            transform: translateY(-1px) !important;
        }
        
        #combat-main-menu button:active,
        #combat-direction-menu button:active,
        #combat-defense-menu button:active,
        #combat-items-menu button:active {
            transform: translateY(0) !important;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.8) !important;
        }

        /* Game UI Elements - Log Panel */
        #game-log {
            background-color: var(--bg-log) !important;
            color: var(--text-log) !important;
        }

        /* Board/Viewport */
        #viewport {
            background-color: var(--bg-secondary) !important;
            border-color: var(--border-color) !important;
        }

        /* Stats header boxes */
        .bg-slate-900 { 
            background-color: var(--bg-tertiary) !important;
            color: var(--text-primary) !important;
        }
        .bg-slate-800 { 
            background-color: var(--bg-secondary) !important;
            color: var(--text-primary) !important;
        }
        .border-slate-800 { border-color: var(--border-color) !important; }
        .text-slate-400, .text-slate-500 { color: var(--text-secondary) !important; }
        .text-slate-600 { color: var(--text-muted) !important; }
        .text-white { color: var(--text-primary) !important; }

        /* Buttons and interactive elements */
        .hover\:bg-slate-700:hover {
            background-color: var(--bg-secondary) !important;
        }

        /* Footer styling - match rest of site */
        footer {
            background-color: #2c3e50;
            color: #bbb;
            transition: background-color 0.3s, color 0.3s;
        }

        /* Header - match rest of site */
        header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 50%, #2c3e50 100%) !important;
        }

        header h1, header nav a, header nav ul li a {
            color: white !important;
        }
    </style>
</head>
<body>
    <script>
        // Initialize theme immediately to prevent flash
        (function() {
            const savedTheme = localStorage.getItem('dungeon-game-theme') || 'dark';
            if (savedTheme === 'light') {
                document.body.classList.add('light-theme');
            }
        })();
    </script>
    <div class="wrapper">
        <header>
            <div class="header-content">
                <a href="index.html" class="logo-link">
                    <img src="img/EagleLogo.png" alt="Ahrens Labs logo" class="header-logo">
                </a>
                <h1>Ahrens Labs</h1>
                <nav>
                    <ul>
                        <li><a href="index.html">Home</a></li>
                        <li><a href="labs.html">Labs & Projects</a></li>
                        <li><a href="contact.html">Contact</a></li>
                        <li><a href="chess_engine.html">Chess Engine</a></li>
                    </ul>
                </nav>
                <div id="header-auth-buttons" style="position: absolute; top: 10px; right: 10px; display: flex; gap: 8px; align-items: center; z-index: 1000;">
                    <button id="header-login-btn" onclick="window.location.href='account.html'" style="padding: 6px 14px; background: #3498db; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 0.85em; transition: all 0.3s; white-space: nowrap;">Login</button>
                    <button id="header-signup-btn" onclick="window.location.href='account.html'" style="padding: 6px 14px; background: #2ecc71; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 0.85em; transition: all 0.3s; white-space: nowrap;">Sign Up</button>
                    <button id="header-logout-btn" onclick="handleLogout()" style="display: none; padding: 6px 14px; background: #e74c3c; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 0.85em; transition: all 0.3s; white-space: nowrap;">Logout</button>
                    <span id="header-username" style="display: none; padding: 6px 14px; color: white; font-weight: 600; font-size: 0.9em; white-space: nowrap;"></span>
                </div>
            </div>
        </header>

        <main class="game-wrapper flex flex-col items-center">

    <!-- Header Stats -->
    <div id="stats-header" class="w-full max-w-4xl grid grid-cols-2 md:grid-cols-5 gap-3 mb-4 hidden">
        <div class="bg-slate-900 border border-slate-800 p-3 rounded flex items-center gap-3">
            <i class="fas fa-heart text-red-500 text-lg"></i>
            <div>
                <div class="text-xs text-slate-500 font-bold uppercase">Health</div>
                <div id="stat-hp" class="text-white text-base font-bold">--/--</div>
            </div>
        </div>
        <div class="bg-slate-900 border border-slate-800 p-3 rounded flex items-center gap-3">
            <i class="fas fa-coins text-yellow-500 text-lg"></i>
            <div>
                <div class="text-xs text-slate-500 font-bold uppercase">Gold</div>
                <div id="stat-gold" class="text-white text-base font-bold">0</div>
            </div>
        </div>
        <div class="bg-slate-900 border border-slate-800 p-3 rounded flex items-center gap-3">
            <i class="fas fa-key text-blue-400 text-lg"></i>
            <div>
                <div class="text-xs text-slate-500 font-bold uppercase">Keys</div>
                <div id="stat-keys" class="text-white text-base font-bold">0</div>
            </div>
        </div>
        <div class="bg-slate-900 border border-slate-800 p-3 rounded flex items-center gap-3">
            <i class="fas fa-shield-alt text-slate-400 text-lg"></i>
            <div>
                <div class="text-xs text-slate-500 font-bold uppercase">Armor</div>
                <div id="stat-armor" class="text-white text-base font-bold">--</div>
            </div>
        </div>
        <div class="bg-slate-900 border border-slate-800 p-4 rounded">
            <div class="flex items-center justify-between gap-4 mb-3 pb-3 border-b border-slate-800">
                <div id="stat-floor" class="text-base text-blue-400 font-black">FLOOR 1</div>
                <div id="stat-level" class="text-base text-purple-400 font-black">LVL 1</div>
            </div>
            <div id="stat-exp" class="text-sm text-cyan-400 font-bold mb-2">EXP: 0/100</div>
            <div id="stat-attributes" class="text-sm text-slate-400 font-semibold">S:0 D:0 I:0 W:0</div>
        </div>
    </div>

    <!-- Main Game Container -->
    <div class="w-full max-w-5xl grid grid-cols-1 lg:grid-cols-4 gap-4 flex-1">
        <!-- Log Panel -->
        <div class="lg:col-span-1 bg-black border border-slate-800 rounded flex flex-col h-[300px] lg:h-[600px] overflow-hidden">
            <div class="bg-slate-900 p-3 text-sm font-bold border-b border-slate-800 text-slate-500 flex justify-between items-center">
                <span>ADVENTURE LOG</span>
                <button id="theme-toggle-btn" onclick="toggleTheme()" title="Toggle Light/Dark Theme" style="padding: 4px 8px; background: #6366f1; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; font-size: 0.75em; transition: all 0.3s; display: flex; align-items: center; gap: 4px;">
                    <i class="fas fa-moon"></i>
                    <span id="theme-text" style="font-size: 0.9em;">Dark</span>
                </button>
            </div>
            <div id="game-log" class="flex-1 overflow-y-auto p-4 text-[13px] space-y-2 custom-scrollbar bg-slate-950/50"></div>
            <div id="combat-streak-indicator" class="hidden p-2 text-center bg-orange-900/30 border-t border-orange-700 text-orange-400 font-bold text-sm">
                üî• <span id="streak-count">0</span> Win Streak!
            </div>
            <div id="global-actions" class="p-3 border-t border-slate-800 bg-slate-900 hidden">
                <button onclick="toggleInventory()" class="w-full py-3 bg-slate-800 hover:bg-slate-700 text-sm font-bold rounded uppercase flex items-center justify-center gap-2">
                    <i class="fas fa-backpack text-base"></i> Inventory
                </button>
            </div>
        </div>

        <!-- Viewport -->
        <div id="viewport" class="lg:col-span-3 bg-slate-900 border border-slate-800 rounded p-6 relative flex flex-col items-center justify-center min-h-[500px] shadow-2xl transition-all duration-500">
            
            <div id="view-menu" class="text-center space-y-8">
                <h1 class="text-6xl font-black text-white italic tracking-tighter">DUNGEON<br>GAME</h1>
                <div class="flex flex-col gap-3">
                    <button onclick="initCharacterCreation()" class="bg-white text-black px-12 py-4 rounded font-bold text-lg hover:bg-yellow-400 transition-all shadow-xl">NEW GAME</button>
                    <button onclick="loadGame()" class="bg-slate-800 text-white px-12 py-4 rounded font-bold text-lg hover:bg-slate-700 transition-all shadow-xl border border-slate-700">LOAD GAME</button>
                </div>
            </div>

            <div id="view-creation" class="hidden w-full max-w-sm space-y-4">
                <div id="char-name-input" class="space-y-4">
                    <h2 class="text-lg font-bold text-center text-slate-400 uppercase tracking-widest">Create Your Character</h2>
                    <div class="space-y-2">
                        <label class="text-sm font-bold text-slate-400 uppercase">Character Name</label>
                        <input id="character-name" type="text" maxlength="20" placeholder="Enter name..." class="w-full p-4 bg-slate-800 border border-slate-700 rounded text-white text-base focus:border-blue-500 focus:outline-none">
                    </div>
                    <button onclick="confirmCharacterName()" class="w-full py-4 bg-blue-600 hover:bg-blue-700 rounded font-bold uppercase text-base">Continue</button>
                </div>
                <div id="attr-assignment" class="hidden space-y-4">
                    <h2 class="text-lg font-bold text-center text-slate-400 uppercase tracking-widest">Assign Attributes</h2>
                    <div id="rolls-container" class="flex justify-center gap-2"></div>
                    <div id="attr-selection" class="space-y-1"></div>
                </div>
            </div>

            <div id="view-town" class="hidden text-center space-y-6 w-full max-w-lg">
                <h2 class="text-4xl font-black text-white italic">OAKHAVEN</h2>
                <div class="bg-slate-800/50 border border-slate-700 p-4 rounded text-sm text-slate-300 font-mono">
                    <p class="mb-2">‚öîÔ∏è An ancient evil awakens...</p>
                    <p>The Goblin King sleeps deep within the cursed dungeons beneath Oakhaven. Only a true hero can venture through the 10 treacherous floors and defeat the darkness that threatens our world.</p>
                </div>
                <div class="grid grid-cols-2 gap-4">
                    <button onclick="showShop()" class="p-10 bg-slate-800 rounded hover:bg-slate-700 border border-slate-700 flex flex-col items-center gap-3">
                        <i class="fas fa-store text-4xl text-yellow-500"></i>
                        <span class="font-bold text-lg">SHOP</span>
                    </button>
                    <button onclick="enterDungeon()" class="p-10 bg-slate-800 rounded hover:bg-slate-700 border border-slate-700 flex flex-col items-center gap-3">
                        <i class="fas fa-dungeon text-4xl text-red-500"></i>
                        <span class="font-bold text-lg">DUNGEON</span>
                    </button>
                </div>
                <div class="flex gap-4 justify-center">
                    <button onclick="saveGame()" class="text-sm text-slate-500 hover:text-white underline font-bold">SAVE GAME</button>
                    <button onclick="showChangeNameModal()" class="text-sm text-slate-500 hover:text-white underline font-bold">CHANGE NAME</button>
                </div>
            </div>

            <div id="view-dungeon" class="hidden w-full flex flex-col items-center gap-6">
                <div id="mini-map" class="grid grid-cols-10 gap-2 bg-slate-950 p-6 rounded border-2 border-slate-800"></div>
                <div id="room-actions" class="flex flex-wrap justify-center gap-3 min-h-[40px]"></div>
                <div class="grid grid-cols-3 gap-2 w-48">
                    <div></div><button onclick="movePlayer(-1, 0)" class="h-14 w-14 bg-slate-800 rounded hover:bg-slate-700 flex items-center justify-center text-xl">&#9650;</button><div></div>
                    <button onclick="movePlayer(0, -1)" class="h-14 w-14 bg-slate-800 rounded hover:bg-slate-700 flex items-center justify-center text-xl">&#9664;</button>
                    <button onclick="movePlayer(1, 0)" class="h-14 w-14 bg-slate-800 rounded hover:bg-slate-700 flex items-center justify-center text-xl">&#9660;</button>
                    <button onclick="movePlayer(0, 1)" class="h-14 w-14 bg-slate-800 rounded hover:bg-slate-700 flex items-center justify-center text-xl">&#9654;</button>
                </div>
                <div class="flex gap-4">
                    <button id="btn-return-town" onclick="showView('view-town')" class="hidden text-sm text-slate-500 hover:text-white uppercase font-bold mt-4 flex items-center gap-2">
                        <i class="fas fa-door-open"></i> Return to Town
                    </button>
                    <button onclick="saveGame()" class="text-sm text-slate-500 hover:text-white uppercase font-bold mt-4 flex items-center gap-2">
                        <i class="fas fa-save"></i> Save
                    </button>
                </div>
            </div>

            <!-- COMBAT VIEW -->
            <div id="view-combat" class="hidden w-full flex flex-col items-center gap-6">
                <div class="text-center w-full">
                    <div id="monster-name" class="text-red-500 font-black text-3xl uppercase italic tracking-widest">MONSTER</div>
                    <div class="w-full max-w-sm mx-auto h-3 bg-slate-950 rounded mt-3 overflow-hidden border border-slate-800">
                        <div id="monster-hp-bar" class="h-full bg-red-600 transition-all duration-500" style="width: 100%"></div>
                    </div>
                    <div id="monster-stats-display" class="text-sm text-slate-500 mt-2"></div>
                </div>

                <div id="combat-main-menu" class="hidden grid grid-cols-1 gap-3 w-full max-w-xs">
                    <button onclick="showCombatSubMenu('attack')" class="p-4 bg-slate-800 hover:bg-slate-700 rounded font-bold text-base text-left px-6 flex justify-between items-center">
                        <span>ATTACK</span><i class="fas fa-sword text-slate-600 text-lg"></i>
                    </button>
                    <button onclick="showCombatSubMenu('items')" class="p-4 bg-slate-800 hover:bg-slate-700 rounded font-bold text-base text-left px-6 flex justify-between items-center">
                        <span>ITEMS</span><i class="fas fa-flask text-slate-600 text-lg"></i>
                    </button>
                    <button onclick="retreat()" class="p-4 bg-slate-900 border border-blue-900/40 text-blue-400 hover:bg-blue-950/20 rounded font-bold text-base text-left px-6 flex justify-between items-center">
                        <span>RETREAT (Roll)</span><i class="fas fa-person-running text-lg"></i>
                    </button>
                </div>

                <div id="combat-direction-menu" class="hidden grid grid-cols-3 gap-3 w-full max-w-md">
                    <div class="col-span-3 text-center text-sm font-bold text-yellow-500 mb-2 uppercase italic">Target Strike Area</div>
                    <button onclick="combatAction(1)" class="p-5 bg-slate-800 hover:bg-red-900/50 rounded flex flex-col items-center text-sm font-bold">HIGH</button>
                    <button onclick="combatAction(3)" class="p-5 bg-slate-800 hover:bg-red-900/50 rounded flex flex-col items-center text-sm font-bold">MID</button>
                    <button onclick="combatAction(2)" class="p-5 bg-slate-800 hover:bg-red-900/50 rounded flex flex-col items-center text-sm font-bold">LOW</button>
                    <button onclick="showCombatSubMenu('main')" class="col-span-3 text-sm text-slate-500 font-bold text-center mt-2">BACK</button>
                </div>

                <div id="combat-defense-menu" class="hidden grid grid-cols-3 gap-3 w-full max-w-md">
                    <div class="col-span-3 text-center text-sm font-bold text-blue-400 mb-2 uppercase italic">Guard Position!</div>
                    <button onclick="resolveMonsterTurn(1)" class="p-5 bg-blue-900/20 hover:bg-blue-800/40 rounded border border-blue-500/30 flex flex-col items-center text-sm font-bold">HIGH</button>
                    <button onclick="resolveMonsterTurn(3)" class="p-5 bg-blue-900/20 hover:bg-blue-800/40 rounded border border-blue-500/30 flex flex-col items-center text-sm font-bold">MID</button>
                    <button onclick="resolveMonsterTurn(2)" class="p-5 bg-blue-900/20 hover:bg-blue-800/40 rounded border border-blue-500/30 flex flex-col items-center text-sm font-bold">LOW</button>
                </div>

                <div id="combat-items-menu" class="hidden w-full max-w-xs space-y-2">
                    <div id="combat-inventory-list" class="space-y-2 max-h-48 overflow-y-auto custom-scrollbar"></div>
                    <button onclick="showCombatSubMenu('main')" class="w-full p-3 bg-slate-800 text-sm text-slate-500 rounded font-bold">BACK</button>
                </div>

                <div id="turn-indicator" class="text-sm font-black tracking-widest text-yellow-600 bg-black/40 px-6 py-2 rounded italic uppercase">...</div>
            </div>

            <!-- SHOP VIEW -->
            <div id="view-shop" class="hidden w-full h-full overflow-y-auto custom-scrollbar p-2">
                <div class="flex justify-between items-center mb-6 sticky top-0 bg-slate-900 py-3 border-b border-slate-800">
                    <h2 class="font-black text-2xl italic">TOWN MERCHANT</h2>
                    <div class="flex gap-2">
                        <button id="shop-mode-buy" onclick="setShopMode('buy')" class="text-sm bg-yellow-600 px-4 py-2 rounded font-bold">BUY</button>
                        <button id="shop-mode-sell" onclick="setShopMode('sell')" class="text-sm bg-slate-800 px-4 py-2 rounded font-bold">SELL</button>
                        <button onclick="showView('view-town')" class="text-sm bg-slate-800 px-4 py-2 rounded font-bold">EXIT</button>
                    </div>
                </div>
                <div id="shop-categories" class="space-y-6"></div>
            </div>

            <!-- INVENTORY VIEW -->
            <div id="view-inventory" class="hidden w-full h-full overflow-y-auto custom-scrollbar p-2">
                <div class="flex justify-between items-center mb-6 sticky top-0 bg-slate-900 py-3 border-b border-slate-800 z-10">
                    <h2 class="font-black text-2xl italic">INVENTORY</h2>
                    <div class="flex gap-2">
                        <button onclick="showView('view-achievements')" class="text-sm bg-blue-800 hover:bg-blue-700 px-4 py-2 rounded font-bold">ACHIEVEMENTS</button>
                        <button onclick="inventoryClose()" class="text-sm bg-slate-800 px-4 py-2 rounded font-bold">CLOSE</button>
                    </div>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div class="space-y-4">
                        <h3 class="text-sm font-bold text-slate-500 uppercase tracking-widest border-b border-slate-800 pb-2">Weapons</h3>
                        <div id="inv-weapons" class="space-y-2"></div>
                        <h3 class="text-sm font-bold text-slate-500 uppercase tracking-widest border-b border-slate-800 pb-2">Armor</h3>
                        <div id="inv-armors" class="space-y-2"></div>
                    </div>
                    <div class="space-y-4">
                        <h3 class="text-sm font-bold text-slate-500 uppercase tracking-widest border-b border-slate-800 pb-2">Consumables</h3>
                        <div id="inv-consumables" class="space-y-2"></div>
                        <h3 class="text-sm font-bold text-slate-500 uppercase tracking-widest border-b border-slate-800 pb-2">Tools</h3>
                        <div id="inv-tools" class="space-y-2"></div>
                    </div>
                </div>
            </div>

            <!-- ACHIEVEMENTS VIEW -->
            <div id="view-achievements" class="hidden w-full h-full overflow-y-auto custom-scrollbar p-4">
                <div class="flex justify-between items-center mb-6 sticky top-0 bg-slate-900 py-3 border-b border-slate-800 z-10">
                    <h2 class="font-black text-2xl italic">üèÜ ACHIEVEMENTS</h2>
                    <button onclick="showView('view-inventory')" class="text-sm bg-slate-800 px-4 py-2 rounded font-bold">BACK</button>
                </div>
                <div id="achievements-list" class="space-y-3 max-w-2xl"></div>
            </div>

        </div>
    </div>

    <script src="js/script.js"></script>
    <script>
        // ===============================================
        // THEME TOGGLE SYSTEM
        // ===============================================
        function initTheme() {
            const savedTheme = localStorage.getItem('dungeon-game-theme') || 'dark';
            applyTheme(savedTheme);
        }

        function applyTheme(theme) {
            const body = document.body;
            const themeBtn = document.getElementById('theme-toggle-btn');
            const themeText = document.getElementById('theme-text');
            const themeIcon = themeBtn.querySelector('i');

            if (theme === 'light') {
                body.classList.add('light-theme');
                themeText.textContent = 'Light';
                themeIcon.className = 'fas fa-sun';
            } else {
                body.classList.remove('light-theme');
                themeText.textContent = 'Dark';
                themeIcon.className = 'fas fa-moon';
            }
            
            localStorage.setItem('dungeon-game-theme', theme);
        }

        function toggleTheme() {
            const currentTheme = document.body.classList.contains('light-theme') ? 'light' : 'dark';
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            applyTheme(newTheme);
        }

        // Initialize theme on page load
        initTheme();
        // CLOUD SAVE SYSTEM
        // ===============================================
        const API_BASE_URL = 'https://chess-accounts.matthewahrens.workers.dev';
        let currentSaveSlot = null;
        let isLoggedIn = false;
        let sessionId = null;

        // Check authentication on page load
        async function checkAuth() {
            sessionId = localStorage.getItem('ahrenslabs_sessionId');
            if (!sessionId) {
                // Redirect to account page with return URL
                window.location.href = 'account.html?return=dungeon_game.html';
                return false;
            }

            // Verify session is valid
            try {
                const response = await fetch(`${API_BASE_URL}/api/user`, {
                    headers: {
                        'Authorization': `Bearer ${sessionId}`
                    }
                });
                
                if (!response.ok) {
                    window.location.href = 'account.html?return=dungeon_game.html';
                    return false;
                }
                
                isLoggedIn = true;
                return true;
            } catch (error) {
                console.error('Auth check failed:', error);
                window.location.href = 'account.html?return=dungeon_game.html';
                return false;
            }
        }

        // Save game to cloud slot
        async function saveToCloud(slotNumber, saveName) {
            if (!isLoggedIn || !sessionId) return false;

            const slot = `slot${slotNumber}`;
            
            // Determine current location (in town or in dungeon)
            const currentView = document.querySelector('#viewport > div:not(.hidden)')?.id;
            const inTown = currentView === 'view-town';
            
            const saveData = {
                stats: stats,
                map: floorMaps,
                monsters: monsterData,
                room: currentRoom,
                openedChests: Array.from(stats.openedChests),
                inTown: inTown
            };

            try {
                const response = await fetch(`${API_BASE_URL}/api/dungeon/save`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${sessionId}`
                    },
                    body: JSON.stringify({
                        slot: slot,
                        data: saveData,
                        name: saveName || stats.characterName || `Save ${slotNumber}`
                    })
                });

                const result = await response.json();
                if (result.success) {
                    currentSaveSlot = slotNumber;
                    return true;
                }
                return false;
            } catch (error) {
                console.error('Save to cloud failed:', error);
                return false;
            }
        }

        // Load game from cloud slot
        async function loadFromCloud(slotNumber) {
            if (!isLoggedIn || !sessionId) return null;

            const slot = `slot${slotNumber}`;

            try {
                const response = await fetch(`${API_BASE_URL}/api/dungeon/load`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${sessionId}`
                    },
                    body: JSON.stringify({ slot })
                });

                const result = await response.json();
                if (result && result.data) {
                    currentSaveSlot = slotNumber;
                    return result.data;
                }
                return null;
            } catch (error) {
                console.error('Load from cloud failed:', error);
                return null;
            }
        }

        // Get all save slots (with caching to avoid repeated requests)
        let cachedSlots = null;
        let slotsCacheTime = 0;
        async function getAllSaveSlots() {
            if (!isLoggedIn || !sessionId) return {};
            
            // Return cached slots if fresher than 500ms
            const now = Date.now();
            if (cachedSlots && (now - slotsCacheTime) < 500) {
                return cachedSlots;
            }

            try {
                const response = await fetch(`${API_BASE_URL}/api/dungeon/slots`, {
                    headers: {
                        'Authorization': `Bearer ${sessionId}`
                    }
                });

                const slots = await response.json();
                cachedSlots = slots;
                slotsCacheTime = now;
                return slots;
            } catch (error) {
                console.error('Get save slots failed:', error);
                return cachedSlots || {};
            }
        }

        // Delete save slot
        async function deleteSaveSlot(slotNumber) {
            if (!isLoggedIn || !sessionId) return false;

            const slot = `slot${slotNumber}`;

            try {
                const response = await fetch(`${API_BASE_URL}/api/dungeon/delete`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${sessionId}`
                    },
                    body: JSON.stringify({ slot })
                });

                const result = await response.json();
                return result.success;
            } catch (error) {
                console.error('Delete save slot failed:', error);
                return false;
            }
        }

        // Auto-save (debounced)
        let autoSaveTimeout;
        function triggerAutoSave() {
            if (!currentSaveSlot) return;
            
            clearTimeout(autoSaveTimeout);
            autoSaveTimeout = setTimeout(async () => {
                await saveToCloud(currentSaveSlot, `Auto-save ${currentSaveSlot}`);
                addLog('Game auto-saved', 'text-green-400');
            }, 3000); // Auto-save 3 seconds after last action
        }

        // ===============================================
        // ORIGINAL GAME DATA
        // ===============================================
        
        // Helper function to get weapon damage description
        function getWeaponDamageDesc(tier) {
            const damages = {
                1: "1d3 (1-3 damage)",
                2: "1d6 (1-6 damage)",
                3: "1d10 (1-10 damage)",
                4: "2d6+2 (4-14 damage)",
                5: "3d6+3 (6-21 damage)",
                6: "4d6+4 (8-28 damage)"
            };
            return damages[tier] || "Unknown";
        }
        
        // --- DATA MATCHING PYTHON EXACTLY ---
        // [Cost, Value, Type(1=Wep,2=Arm,3=Pot,4=Spl), Effect/Uses]
        const SHOP_DATA = {
            "dagger": [30, 2, 1],
            "short sword": [50, 3, 1],
            "long sword": [100, 4, 1],
            "axe": [200, 5, 1],
            "great sword": [500, 6, 1],
            "paded armor": [125, 10, 2],
            "leather armor": [200, 11, 2],
            "studded leather": [400, 12, 2],
            "scale mail": [700, 13, 2],
            "chainmail": [1000, 14, 2],
            "platemail": [1500, 15, 2],
            "healing potion": [25, 3, 3, 1],
            "intelligence potion": [70, 2, 3, 2],
            "speed potion": [100, 2, 3, 3],
            "strength potion": [130, 2, 3, 4],
            "protection potion": [150, 2, 3, 5],
            "magic missile spell": [50, 3, 4, 1],
            "weakness spell": [70, 2, 4, 2],
            "lightning spell": [100, 2, 4, 3],
            "freeze spell": [130, 2, 4, 4],
            "fireball spell": [150, 2, 4, 5],
            "town spell": [200, 2, 4, 6],
            "checkpoint": [500, 0, 5],
            "map": [150, 0, 6]
        };

        // --- ACHIEVEMENTS SYSTEM ---
        const ACHIEVEMENTS = {
            // Easy Achievements (10-20 coins)
            first_kill: { name: "First Blood", desc: "Defeat your first monster", reward: 10, difficulty: "easy" },
            open_chest: { name: "Treasure Seeker", desc: "Open your first chest", reward: 15, difficulty: "easy" },
            kill_10: { name: "Monster Slayer", desc: "Defeat 10 monsters", reward: 15, difficulty: "easy" },
            loot_100: { name: "Coin Collector", desc: "Collect 100 gold", reward: 20, difficulty: "easy" },
            equip_item: { name: "Geared Up", desc: "Equip a weapon or armor", reward: 10, difficulty: "easy" },
            cast_spell: { name: "Apprentice Mage", desc: "Cast your first spell", reward: 12, difficulty: "easy" },
            
            // Medium Achievements (25-50 coins)
            level_5: { name: "Rising Power", desc: "Reach Level 5", reward: 25, difficulty: "medium" },
            kill_50: { name: "Monster Hunter", desc: "Defeat 50 monsters", reward: 30, difficulty: "medium" },
            loot_1000: { name: "Gold Digger", desc: "Collect 1,000 gold", reward: 35, difficulty: "medium" },
            floor_5: { name: "Deep Explorer", desc: "Reach Floor 5", reward: 40, difficulty: "medium" },
            defeat_mini: { name: "Mini Boss Bane", desc: "Defeat a Mini Boss", reward: 45, difficulty: "medium" },
            collect_3_spells: { name: "Spellcaster", desc: "Collect 3 different spells", reward: 30, difficulty: "medium" },
            combat_streak: { name: "On A Roll", desc: "Win 5 combats in a row", reward: 35, difficulty: "medium" },
            level_10: { name: "Veteran Adventurer", desc: "Reach Level 10", reward: 40, difficulty: "medium" },
            librarian: { name: "Spell Master", desc: "Collect all 5 spell types", reward: 50, difficulty: "medium" },
            
            // Hard Achievements (75-150 coins)
            boss_killer: { name: "Boss Slayer", desc: "Defeat a Boss", reward: 75, difficulty: "hard" },
            hoarder: { name: "Treasure Hoarder", desc: "Collect 5,000 gold", reward: 80, difficulty: "hard" },
            floor_10: { name: "Dungeon Delver", desc: "Reach Floor 10", reward: 100, difficulty: "hard" },
            level_15: { name: "Master Fighter", desc: "Reach Level 15", reward: 90, difficulty: "hard" },
            kill_200: { name: "Exterminator", desc: "Defeat 200 monsters", reward: 85, difficulty: "hard" },
            wealthy: { name: "Wealthy Noble", desc: "Collect 10,000 gold", reward: 110, difficulty: "hard" },
            defeat_3_bosses: { name: "Boss Hunter", desc: "Defeat 3 Bosses", reward: 120, difficulty: "hard" },
            combat_streak_8: { name: "Unstoppable Force", desc: "Win 8 combats in a row", reward: 95, difficulty: "hard" },
            floor_15: { name: "Abyss Walker", desc: "Reach Floor 15", reward: 125, difficulty: "hard" },
            golden_touch: { name: "Golden Touch", desc: "Collect 50,000 gold", reward: 150, difficulty: "hard" },
            level_20: { name: "Legendary Warrior", desc: "Reach Level 20", reward: 130, difficulty: "hard" },
            floor_master: { name: "Floor Master", desc: "Reach Floor 25", reward: 140, difficulty: "hard" },
            defeat_50_monsters: { name: "Monster Apocalypse", desc: "Defeat 500 monsters", reward: 115, difficulty: "hard" }
        };

        // --- ITEM RARITY SYSTEM ---
        const RARITY = {
            common: { color: "#a0a0a0", name: "Common" },
            uncommon: { color: "#00ff00", name: "Uncommon" },
            rare: { color: "#3b82f6", name: "Rare" },
            epic: { color: "#a855f7", name: "Epic" },
            legendary: { color: "#fbbf24", name: "Legendary" }
        };

        function getItemRarity() {
            const roll = Math.random();
            if (roll < 0.6) return 'common';
            if (roll < 0.85) return 'uncommon';
            if (roll < 0.95) return 'rare';
            if (roll < 0.99) return 'epic';
            return 'legendary';
        }

        // --- GAME STATE ---
        let stats = {
            characterName: "",
            HP: 15, maxHP: 15, coins: 0, armor: 9, keys: 0, floor: 1,
            exp: 0, level: 1, totalExp: 0, expToNextLevel: 100,
            strength: 0, dexterity: 0, intelligence: 0, wisdom: 0,
            temporary_strength: 0, temporary_dexterity: 0, temporary_intelligence: 0, temporary_armor: 0,
            weapons: { "stick": 1 }, 
            armors: { "none": 9 }, 
            potions: {}, 
            spells: {},
            equippedWeapon: "stick",
            equippedArmor: "none",
            openedChests: new Set(),
            deathCount: 0,
            achievements: {},
            combatWinStreak: 0,
            lastCombatWon: false,
            activeBuff: null,
            activeBuffTurns: 0,
            kills: 0,
            miniBossesDefeated: 0,
            bossesDefeated: 0,
            spellsCast: 0,
            checkpointsPurchased: 0,  // Total checkpoints bought
            checkpoints: {},  // Named checkpoints: {name: {floor, row, col}, ...}
            hasMap: false  // Whether player owns the map item
        };
        let floorMaps = {}; // Store maps per floor
        let monsterData = {}; // Store pre-generated monster stats by room
        let currentRoom = [9, 9];
        let pendingRolls = [];
        let combatData = null;
        let isProcessing = false;
        let previousView = "view-town";
        let shopMode = "buy";

        // --- CORE UTILS ---
        function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

        async function logLoading(text, dots = 3, speed = 250) {
            const log = document.getElementById('game-log');
            const entry = document.createElement('div');
            entry.className = "text-slate-500 italic";
            log.appendChild(entry);
            for(let i=0; i<3; i++) {
                for(let d=1; d<=dots; d++) {
                    entry.innerText = `${text}${'.'.repeat(d)}`;
                    log.scrollTop = log.scrollHeight;
                    await sleep(speed);
                }
            }
            entry.remove();
        }

        function addLog(msg, color="text-slate-400") {
            const log = document.getElementById('game-log');
            const d = document.createElement('div');
            d.className = `${color} leading-snug`;
            d.innerText = msg;
            log.appendChild(d);
            log.scrollTop = log.scrollHeight;
        }

        function updateUI() {
            document.getElementById('stat-hp').innerText = `${stats.HP}/${stats.maxHP}`;
            document.getElementById('stat-gold').innerText = stats.coins;
            document.getElementById('stat-keys').innerText = stats.keys;
            document.getElementById('stat-armor').innerText = stats.armor + stats.temporary_armor;
            document.getElementById('stat-floor').innerText = `FLOOR ${stats.floor}`;
            document.getElementById('stat-level').innerText = `LVL ${stats.level}`;
            
            // Calculate total EXP needed for next level: 50 * level * (level + 1)
            const totalExpForNextLevel = 50 * stats.level * (stats.level + 1);
            
            document.getElementById('stat-exp').innerText = `EXP: ${stats.totalExp}/${totalExpForNextLevel}`;
            document.getElementById('stat-attributes').innerText = `S:${stats.strength} D:${stats.dexterity} I:${stats.intelligence} W:${stats.wisdom}`;
            
            // Update combat streak indicator
            const streakEl = document.getElementById('combat-streak-indicator');
            if (stats.combatWinStreak >= 2) {
                streakEl.classList.remove('hidden');
                document.getElementById('streak-count').innerText = stats.combatWinStreak;
            } else {
                streakEl.classList.add('hidden');
            }
            
            const btn = document.getElementById('btn-return-town');
            if (currentRoom[0] === 9 && currentRoom[1] === 9 && stats.floor === 1) {
                btn.classList.remove('hidden');
            } else {
                btn.classList.add('hidden');
            }
        }

        function showView(viewId) {
            // Store the current view BEFORE hiding everything
            const currentView = document.querySelector('#viewport > div:not(.hidden)')?.id;
            
            // Only update previousView when opening inventory (to remember where to return)
            // Do NOT overwrite previousView when returning to inventory from the achievements view
            if (viewId === "view-inventory" && currentView && currentView !== "view-inventory" && currentView !== 'view-achievements') {
                previousView = currentView;
            }
            // When closing inventory or doing any other transition, DON'T update previousView
            
            ['view-menu','view-creation','view-town','view-dungeon','view-combat','view-shop','view-inventory','view-achievements'].forEach(v => 
                document.getElementById(v).classList.add('hidden')
            );
            
            document.getElementById('viewport').classList.toggle('combat-active', viewId === 'view-combat');
            document.getElementById(viewId).classList.remove('hidden');
            
            if(viewId !== 'view-menu') {
                document.getElementById('stats-header').classList.remove('hidden');
                document.getElementById('global-actions').classList.remove('hidden');
            }
            if(viewId === 'view-dungeon') updateUI();
            if(viewId === 'view-achievements') renderAchievements();
        }

        function toggleInventory() {
            if (!document.getElementById('view-inventory').classList.contains('hidden')) {
                closeInventory();
            } else {
                renderInventory();
                showView('view-inventory');
            }
        }

        function closeInventory() {
            // If we're returning to combat, make sure combat state is still valid
            if (previousView === 'view-combat') {
                if (combatData && combatData.HP > 0) {
                    // Combat is still active, restore it
                    showView('view-combat');
                    updateCombatUI();
                    // Restore the appropriate menu based on whose turn it is
                    if (combatData.turn === 'player') {
                        showCombatSubMenu('main');
                    } else if (combatData.turn === 'monster') {
                        showCombatSubMenu('defense');
                    }
                } else {
                    // Combat ended while in inventory, go back to dungeon
                    showView('view-dungeon');
                    renderDungeon();
                    checkRoom(true);
                }
            } else {
                showView(previousView);
            }
        }

        // Robust UI handler for the inventory close button (fallbacks and safety)
        function inventoryClose() {
            try {
                // Prefer the existing closeInventory logic (handles combat)
                if (typeof closeInventory === 'function') closeInventory();
            } catch (e) {
                console.error('closeInventory failed:', e);
            }

            // Ensure inventory is hidden and we show a sensible view
            const inv = document.getElementById('view-inventory');
            if (inv && !inv.classList.contains('hidden')) inv.classList.add('hidden');

            const target = previousView || 'view-town';
            if (document.getElementById(target)) {
                // Use showView to properly render headers/UI
                showView(target);
            } else {
                showView('view-town');
            }

            // Reset previousView to avoid unexpected back-navigation
            previousView = 'view-town';
        }

        async function saveGame() {
            // Show save slot selection modal
            showSaveSlotModal();
        }

        async function loadGame() {
            // Check authentication before loading
            if (!isLoggedIn) {
                addLog('Please log in to load your game!', 'text-red-400');
                window.location.href = 'account.html?return=dungeon_game.html';
                return;
            }
            // Show loading indicator while fetching slots
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.9);display:flex;align-items:center;justify-content:center;z-index:10000;';
            modal.innerHTML = '<div style="text-align:center;color:white;"><div style="font-size:2rem;margin-bottom:1rem;">‚è≥</div><div>Loading save slots...</div></div>';
            modal.id = 'loading-modal';
            document.body.appendChild(modal);
            
            // Show load slot selection modal
            await showLoadSlotModal();
            
            const loadingModal = document.getElementById('loading-modal');
            if (loadingModal) loadingModal.remove();
        }

        // Show save slot selection modal
        async function showSaveSlotModal() {
            // Show loading indicator while fetching slots
            const loadingModal = document.createElement('div');
            loadingModal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.9);display:flex;align-items:center;justify-content:center;z-index:10000;';
            loadingModal.innerHTML = '<div style="text-align:center;color:white;"><div style="font-size:2rem;margin-bottom:1rem;">‚è≥</div><div>Loading save slots...</div></div>';
            loadingModal.id = 'loading-modal';
            document.body.appendChild(loadingModal);
            
            const slots = await getAllSaveSlots();
            
            // Remove loading modal immediately
            const existingLoading = document.getElementById('loading-modal');
            if (existingLoading) existingLoading.remove();
            
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.9);display:flex;align-items:center;justify-content:center;z-index:10000;';
            
            let html = '<div style="background:#1e293b;padding:2rem;border-radius:10px;max-width:500px;width:90%;">';
            html += '<h2 style="font-size:1.5rem;font-weight:bold;margin-bottom:1.5rem;text-align:center;color:white;">SAVE TO SLOT</h2>';
            html += '<div style="display:flex;flex-direction:column;gap:1rem;">';
            
            for (let i = 1; i <= 3; i++) {
                const slot = slots[`slot${i}`];
                const slotName = slot ? slot.name : `Empty Slot ${i}`;
                const slotDate = slot ? new Date(slot.savedAt).toLocaleString() : '';
                const currentCharName = stats.characterName || 'Unnamed Hero';
                
                html += `<button onclick="saveToSlotAndClose(${i})" style="padding:1rem;background:#334155;border-radius:8px;text-align:left;cursor:pointer;border:2px solid #475569;transition:all 0.2s;color:white;" onmouseover="this.style.background='#475569'" onmouseout="this.style.background='#334155'">`;
                html += `<div style="font-weight:bold;font-size:1.1rem;">Slot ${i}</div>`;
                if (slot) {
                    html += `<div style="font-size:0.9rem;color:#fbbf24;">${slotName}</div>`;
                    html += `<div style="font-size:0.8rem;color:#94a3b8;">${slotDate}</div>`;
                } else {
                    html += `<div style="font-size:0.9rem;color:#64748b;">Empty</div>`;
                }
                html += `<div style="font-size:0.75rem;color:#3b82f6;margin-top:0.25rem;">Will save: ${currentCharName}</div>`;
                html += '</button>';
            }
            
            html += '</div>';
            html += '<button onclick="closeSaveModal()" style="margin-top:1.5rem;width:100%;padding:0.75rem;background:#64748b;border-radius:8px;font-weight:bold;color:white;">CANCEL</button>';
            html += '</div>';
            
            modal.innerHTML = html;
            modal.id = 'save-modal';
            document.body.appendChild(modal);
        }

        // Show load slot selection modal
        async function showLoadSlotModal() {
            const slots = await getAllSaveSlots();
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.9);display:flex;align-items:center;justify-content:center;z-index:10000;';
            
            let html = '<div style="background:#1e293b;padding:2rem;border-radius:10px;max-width:500px;width:90%;">';
            html += '<h2 style="font-size:1.5rem;font-weight:bold;margin-bottom:1.5rem;text-align:center;color:white;">LOAD FROM SLOT</h2>';
            html += '<div style="display:flex;flex-direction:column;gap:1rem;">';
            
            for (let i = 1; i <= 3; i++) {
                const slot = slots[`slot${i}`];
                const slotDate = slot ? new Date(slot.savedAt).toLocaleString() : '';
                
                if (slot) {
                    const characterName = slot.name || `Save ${i}`;
                    html += `<div style="padding:1rem;background:#334155;border-radius:8px;border:2px solid #475569;display:flex;justify-content:space-between;align-items:center;">`;
                    html += `<div style="flex:1;cursor:pointer;color:white;" onclick="loadFromSlotAndClose(${i})">`;
                    html += `<div style="font-weight:bold;font-size:1.1rem;">Slot ${i}</div>`;
                    html += `<div style="font-size:1rem;color:#fbbf24;">${characterName}</div>`;
                    html += `<div style="font-size:0.8rem;color:#94a3b8;">${slotDate}</div>`;
                    html += `</div>`;
                    html += `<button onclick="deleteSlotAndRefresh(${i})" style="padding:0.5rem 1rem;background:#ef4444;border-radius:6px;font-size:0.8rem;font-weight:bold;color:white;cursor:pointer;">DELETE</button>`;
                    html += '</div>';
                } else {
                    html += `<div style="padding:1rem;background:#1e293b;border-radius:8px;border:2px solid #334155;color:#64748b;">`;
                    html += `<div style="font-weight:bold;">Slot ${i}: Empty</div>`;
                    html += '</div>';
                }
            }
            
            html += '</div>';
            html += '<button onclick="closeLoadModal()" style="margin-top:1.5rem;width:100%;padding:0.75rem;background:#64748b;border-radius:8px;font-weight:bold;color:white;">CANCEL</button>';
            html += '</div>';
            
            modal.innerHTML = html;
            modal.id = 'load-modal';
            document.body.appendChild(modal);
        }

        async function saveToSlotAndClose(slotNumber) {
            const saveName = stats.characterName || `Save ${slotNumber}`;
            const success = await saveToCloud(slotNumber, saveName);
            if (success) {
                addLog(`Game saved to Slot ${slotNumber}!`, 'text-green-400');
                closeSaveModal();
            } else {
                addLog('Failed to save game', 'text-red-400');
            }
        }

        async function loadFromSlotAndClose(slotNumber) {
            const saveData = await loadFromCloud(slotNumber);
            if (saveData) {
                stats = saveData.stats;
                
                // Ensure new properties exist (backward compatibility with old saves)
                if (!stats.kills) stats.kills = 0;
                if (!stats.miniBossesDefeated) stats.miniBossesDefeated = 0;
                if (!stats.bossesDefeated) stats.bossesDefeated = 0;
                if (!stats.spellsCast) stats.spellsCast = 0;
                if (!stats.achievements) stats.achievements = {};
                
                floorMaps = saveData.map || {};
                monsterData = saveData.monsters || {};
                currentRoom = saveData.room;
                stats.openedChests = new Set(saveData.openedChests);
                
                // Check if player was in town when they saved
                const wasInTown = saveData.inTown === true;
                
                if (wasInTown) {
                    // Load into town
                    showView('view-town');
                    addLog(`Game loaded from Slot ${slotNumber}!`, 'text-yellow-400');
                    addLog(`Welcome back to Oakhaven, ${stats.characterName || 'adventurer'}!`, 'text-slate-400');
                } else {
                    // Load into dungeon
                    showView('view-dungeon');
                    renderDungeon();
                    addLog(`Game loaded from Slot ${slotNumber}!`, 'text-yellow-400');
                    // Check room for events (including battles) - don't suppress
                    checkRoom(false);
                }
                
                updateUI();
                closeLoadModal();
            } else {
                addLog('Failed to load game', 'text-red-400');
            }
        }

        function deleteSlotAndRefresh(slotNumber) {
            showDeleteConfirmation(slotNumber);
        }

        function showDeleteConfirmation(slotNumber) {
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.95);display:flex;align-items:center;justify-content:center;z-index:11000;';
            
            let html = '<div style="background:#1e293b;padding:2rem;border-radius:10px;max-width:400px;width:90%;border:3px solid #ef4444;">';
            html += '<div style="text-align:center;font-size:3rem;margin-bottom:1rem;">‚ö†Ô∏è</div>';
            html += '<h2 style="font-size:1.3rem;font-weight:bold;margin-bottom:1rem;text-align:center;color:#ef4444;">DELETE SAVE?</h2>';
            html += '<div style="background:#0f172a;padding:1.5rem;border-radius:8px;margin-bottom:1.5rem;border:2px solid #7f1d1d;text-align:center;">';
            html += `<div style="font-size:1.1rem;font-weight:bold;color:#fbbf24;margin-bottom:0.5rem;">Save Slot ${slotNumber}</div>`;
            html += '<div style="font-size:0.9rem;color:#ef4444;font-weight:bold;margin-top:1rem;">This action cannot be undone!</div>';
            html += '</div>';
            html += '<div style="display:flex;gap:0.75rem;flex-direction:column;">';
            html += `<button onclick="confirmDelete(${slotNumber})" style="width:100%;padding:0.75rem;background:#ef4444;border-radius:8px;font-weight:bold;color:white;font-size:0.95rem;cursor:pointer;border:none;">DELETE SAVE</button>`;
            html += '<button onclick="closeDeleteModal()" style="width:100%;padding:0.75rem;background:#64748b;border-radius:8px;font-weight:bold;color:white;font-size:0.95rem;cursor:pointer;border:none;">CANCEL</button>';
            html += '</div>';
            html += '</div>';
            
            modal.innerHTML = html;
            modal.id = 'delete-modal';
            document.body.appendChild(modal);
        }

        async function confirmDelete(slotNumber) {
            closeDeleteModal();
            const success = await deleteSaveSlot(slotNumber);
            if (success) {
                addLog(`Deleted save slot ${slotNumber}`, 'text-red-400');
                closeLoadModal();
                setTimeout(() => showLoadSlotModal(), 100);
            } else {
                addLog('Failed to delete save', 'text-red-400');
            }
        }

        function closeDeleteModal() {
            const modal = document.getElementById('delete-modal');
            if (modal) modal.remove();
        }

        function closeSaveModal() {
            const modal = document.getElementById('save-modal');
            if (modal) modal.remove();
        }

        function closeLoadModal() {
            const modal = document.getElementById('load-modal');
            if (modal) modal.remove();
        }

        // --- CHANGE CHARACTER NAME ---
        function showChangeNameModal() {
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.9);display:flex;align-items:center;justify-content:center;z-index:10000;';
            
            let html = '<div style="background:#1e293b;padding:2rem;border-radius:10px;max-width:450px;width:90%;">';
            html += '<h2 style="font-size:1.5rem;font-weight:bold;margin-bottom:1.5rem;text-align:center;color:white;">CHANGE CHARACTER NAME</h2>';
            html += '<div style="background:#0f172a;padding:1.5rem;border-radius:8px;margin-bottom:1rem;border:2px solid #334155;">';
            html += `<div style="font-size:0.9rem;color:#94a3b8;margin-bottom:0.5rem;">Current Name:</div>`;
            html += `<div style="font-size:1.2rem;font-weight:bold;color:#fbbf24;margin-bottom:1rem;">${stats.characterName || 'Unnamed'}</div>`;
            html += '<div style="font-size:0.9rem;color:#94a3b8;margin-bottom:0.5rem;">New Name:</div>';
            html += '<input id="new-character-name" type="text" maxlength="20" placeholder="Enter new name..." style="width:100%;padding:0.75rem;background:#1e293b;border:2px solid #475569;border-radius:6px;color:white;font-size:1rem;outline:none;" />';
            html += '</div>';
            html += '<div style="display:flex;gap:0.75rem;">';
            html += '<button onclick="confirmNameChange()" style="flex:1;padding:0.75rem;background:#3b82f6;border-radius:8px;font-weight:bold;color:white;font-size:0.95rem;cursor:pointer;border:none;">CHANGE NAME</button>';
            html += '<button onclick="closeChangeNameModal()" style="flex:1;padding:0.75rem;background:#64748b;border-radius:8px;font-weight:bold;color:white;font-size:0.95rem;cursor:pointer;border:none;">CANCEL</button>';
            html += '</div>';
            html += '</div>';
            
            modal.innerHTML = html;
            modal.id = 'change-name-modal';
            document.body.appendChild(modal);
            
            // Focus the input field
            setTimeout(() => {
                document.getElementById('new-character-name').focus();
            }, 100);
        }

        function confirmNameChange() {
            const newName = document.getElementById('new-character-name').value.trim();
            
            if (newName === '') {
                addLog('Please enter a valid name!', 'text-red-400');
                return;
            }
            
            const oldName = stats.characterName || 'Unnamed';
            stats.characterName = newName;
            
            closeChangeNameModal();
            addLog(`Character name changed from "${oldName}" to "${newName}"`, 'text-blue-400');
            addLog('Remember to save your game to keep the new name!', 'text-yellow-400');
        }

        function closeChangeNameModal() {
            const modal = document.getElementById('change-name-modal');
            if (modal) modal.remove();
        }

        // --- CHARACTER CREATION ---
        function create_value() {
            const rolls = Array.from({length:4}, () => Math.floor(Math.random()*6)+1);
            return rolls.reduce((a,b)=>a+b,0) - Math.min(...rolls);
        }

        function initCharacterCreation() {
            // Show character name input first
            document.getElementById('char-name-input').classList.remove('hidden');
            document.getElementById('attr-assignment').classList.add('hidden');
            document.getElementById('character-name').value = '';
            showView('view-creation');
        }
        
        function confirmCharacterName() {
            const nameInput = document.getElementById('character-name').value.trim();
            if (nameInput === '') {
                addLog('Please enter a character name!', 'text-red-400');
                return;
            }
            stats.characterName = nameInput;
            
            // Now proceed to attribute assignment
            pendingRolls = [create_value(), create_value(), create_value(), create_value()];
            stats.coins = 0;
            for(let i=0; i<20; i++) stats.coins += Math.floor(Math.random()*6)+1;
            
            document.getElementById('char-name-input').classList.add('hidden');
            document.getElementById('attr-assignment').classList.remove('hidden');
            renderCreation();
        }

        function renderCreation() {
            const rc = document.getElementById('rolls-container');
            rc.innerHTML = '';
            pendingRolls.forEach(r => {
                const b = document.createElement('div');
                b.className = "w-10 h-10 bg-slate-800 border border-slate-700 flex items-center justify-center font-bold text-yellow-500 rounded";
                b.innerText = r;
                rc.appendChild(b);
            });

            const ac = document.getElementById('attr-selection');
            ac.innerHTML = '';
            ['strength', 'wisdom', 'dexterity', 'intelligence'].forEach(attr => {
                const row = document.createElement('div');
                row.className = "flex justify-between items-center p-2 bg-slate-800/30 rounded";
                row.innerHTML = `<span class="capitalize text-sm font-bold text-slate-400">${attr}</span>`;
                const group = document.createElement('div');
                group.className = "flex gap-1";
                if(stats[attr] === 0 || stats[attr] === null) {
                    pendingRolls.forEach((r, i) => {
                        const btn = document.createElement('button');
                        btn.className = "w-10 h-10 bg-blue-600 rounded text-sm font-bold";
                        btn.innerText = r;
                        btn.onclick = () => {
                            stats[attr] = r;
                            pendingRolls.splice(i, 1);
                            if(pendingRolls.length === 0) {
                                showView('view-town');
                                updateUI();
                            } else renderCreation();
                        };
                        group.appendChild(btn);
                    });
                } else {
                    group.innerHTML = `<span class="text-green-500 font-bold text-sm">${stats[attr]}</span>`;
                }
                row.appendChild(group);
                ac.appendChild(row);
            });
        }

        // --- DUNGEON SHOPKEEPER SYSTEM ---
        const DUNGEON_SHOPS = {
            // Floor-specific shopkeepers with unique items and prices
            1: {
                name: "Goblin Merchant Gruk",
                greeting: "Welcome to my humble stall, adventurer! I have goods fresh from the surface.",
                inventory: {
                    "healing potion": [15, 3, 3, 1],
                    "rusty dagger": [20, 1, 1],
                    "wooden shield": [25, 10, 2],
                    "torch": [5, 0, 3]
                }
            },
            2: {
                name: "Rat King's Quartermaster",
                greeting: "Ssssss... you wish to buy from my master's stores? Prices are fair!",
                inventory: {
                    "healing potion": [20, 3, 3, 1],
                    "strength potion": [80, 2, 3, 4],
                    "leather armor": [150, 11, 2],
                    "antidote": [30, 0, 3]
                }
            },
            3: {
                name: "Stone Golem Keeper",
                greeting: "GOODS... FOR SALE... DURABLE... QUALITY...",
                inventory: {
                    "studded leather": [300, 12, 2],
                    "short sword": [40, 3, 1],
                    "intelligence potion": [50, 2, 3, 2],
                    "stone charm": [60, 0, 3]
                }
            },
            4: {
                name: "Ember Trader",
                greeting: "Feel the heat of my wares, traveler! Hottest deals around!",
                inventory: {
                    "fireball spell": [100, 2, 4, 5],
                    "protection potion": [120, 2, 3, 5],
                    "long sword": [80, 4, 1],
                    "flame ring": [150, 0, 3]
                }
            },
            5: {
                name: "Frost Merchant Elara",
                greeting: "Welcome to my frozen emporium. Warm goods for a cold world.",
                inventory: {
                    "freeze spell": [90, 2, 4, 4],
                    "speed potion": [70, 2, 3, 3],
                    "scale mail": [500, 13, 2],
                    "ice shard": [140, 0, 3]
                }
            },
            6: {
                name: "Corrupted Sage",
                greeting: "Ah, another seeker of forbidden knowledge... I have just the thing.",
                inventory: {
                    "weakness spell": [60, 2, 4, 2],
                    "magic missile spell": [40, 3, 4, 1],
                    "chainmail": [750, 14, 2],
                    "cursed tome": [200, 0, 3]
                }
            },
            7: {
                name: "Void Merchant",
                greeting: "Reality bends around my wares... interested?",
                inventory: {
                    "great sword": [400, 6, 1],
                    "town spell": [150, 2, 4, 6],
                    "platemail": [1200, 15, 2],
                    "void essence": [300, 0, 3]
                }
            },
            8: {
                name: "Abyssal Trader",
                greeting: "The abyss offers many wonders... at suitable prices.",
                inventory: {
                    "legendary healing potion": [200, 3, 3, 1],
                    "great sword": [350, 6, 1],
                    "ancient armor": [1500, 16, 2],
                    "abyssal pearl": [500, 0, 3]
                }
            },
            9: {
                name: "Shadow Lord's Merchant",
                greeting: "Few reach this level... you have excellent taste in shopping!",
                inventory: {
                    "artifact sword": [800, 7, 1],
                    "legendary armor": [2000, 17, 2],
                    "master's potion": [300, 2, 3, 5],
                    "shadow crown": [1000, 0, 3]
                }
            }
        };

        // --- FLOOR THEMES SYSTEM ---
        const FLOOR_THEMES = {
            1: {
                name: "The Goblin Warrens",
                description: "Small green creatures scurry through damp tunnels.",
                color: "#10b981",
                enemies: ["goblin", "goblin", "goblin", "bandit", "cultist"],
                specialty: "weak but numerous"
            },
            2: {
                name: "The Rat King's Domain",
                description: "Oversized rodents and vermin infest this level.",
                color: "#8b5a00",
                enemies: ["rat", "rat", "zombie", "beast", "troll"],
                specialty: "disease and poison"
            },
            3: {
                name: "Petrified Stone Halls",
                description: "Ancient golems guard chambers of carved stone.",
                color: "#6b7280",
                enemies: ["golem", "skeleton", "guardian", "golem", "knight"],
                specialty: "high armor"
            },
            4: {
                name: "The Infernal Furnace",
                description: "Scorching heat radiates from walls of lava and ash.",
                color: "#ef4444",
                enemies: ["imp", "elemental", "imp", "mage", "wraith"],
                specialty: "fire damage"
            },
            5: {
                name: "Frozen Catacombs",
                description: "Shards of ice pierce through arctic winds.",
                color: "#06b6d4",
                enemies: ["spirit", "elemental", "wraith", "creature", "guardian"],
                specialty: "slowing attacks"
            },
            6: {
                name: "The Corrupted Grove",
                description: "Twisted flora and foul magic permeate the air.",
                color: "#8b5cf6",
                enemies: ["creature", "cultist", "mage", "beast", "knight"],
                specialty: "curse abilities"
            },
            7: {
                name: "Void Rift Chambers",
                description: "Reality warps and bends around swirling darkness.",
                color: "#3b0764",
                enemies: ["wraith", "creature", "specter", "entity", "horror"],
                specialty: "evasion and chaos"
            },
            8: {
                name: "The Abyssal Depths",
                description: "An endless abyss stretches below. Ancient horrors lurk here.",
                color: "#1e1b4b",
                enemies: ["horror", "entity", "leviathan", "titan", "overlord"],
                specialty: "massive damage"
            },
            9: {
                name: "The Obsidian Throne",
                description: "Dark energy crackles around a massive throne of shadow.",
                color: "#0f172a",
                enemies: ["overlord", "tyrant", "lord", "sovereign", "deity"],
                specialty: "multiple abilities"
            },
            10: {
                name: "The Goblin King's Throne",
                description: "The source of all darkness. The Goblin King awaits.",
                color: "#dc2626",
                enemies: ["GOBLIN KING"],
                specialty: "ultimate power"
            }
        };

        // --- BOSS ABILITIES SYSTEM ---
        const BOSS_ABILITIES = {
            // Ability structure: { name, description, trigger_hp_percent, effect_function }
            phase_shift: {
                name: "Phase Shift",
                description: "Boss phases out and recovers health!",
                effect: function() {
                    const heal = Math.floor(combatData.maxHP * 0.2);
                    combatData.HP = Math.min(combatData.HP + heal, combatData.maxHP);
                    addLog(`The boss phases out and recovers ${heal} HP!`, "text-purple-400 font-bold");
                }
            },
            multi_attack: {
                name: "Multi-Strike",
                description: "Boss attacks multiple times in succession!",
                effect: async function() {
                    addLog("The boss winds up for a devastating combo!", "text-red-500 font-bold");
                    await sleep(400);
                    const numAttacks = 3;
                    for (let i = 0; i < numAttacks; i++) {
                        const roll = Math.floor(Math.random()*20)+1 + combatData.strength;
                        const ac = stats.armor + stats.temporary_armor;
                        if (roll >= ac) {
                            let dmg = Math.floor(Math.random()*8)+2;
                            stats.HP -= dmg;
                            addLog(`[Hit ${i+1}/3] Took ${dmg} damage!`, "text-red-600");
                        } else {
                            addLog(`[Miss ${i+1}/3] Dodged!`, "text-green-400");
                        }
                        await sleep(300);
                    }
                    if (stats.HP <= 0) {
                        updateUI();
                        return false; // Handled by caller
                    }
                    updateUI();
                }
            },
            stun_attack: {
                name: "Stunning Strike",
                description: "Boss stunning attack! You lose a turn!",
                effect: async function() {
                    const roll = Math.floor(Math.random()*20)+1 + combatData.strength;
                    const ac = stats.armor + stats.temporary_armor;
                    addLog("The boss attempts a devastating strike!", "text-orange-500 font-bold");
                    await sleep(300);
                    if (roll >= ac) {
                        let dmg = Math.floor(Math.random()*12)+4;
                        stats.HP -= dmg;
                        addLog(`YOU WERE STUNNED! Took ${dmg} damage!`, "text-red-600 font-black");
                        addLog("Your next attack will be skipped!", "text-yellow-500 font-bold");
                        stats.stunned = true;
                        await sleep(800);
                    } else {
                        addLog("You narrowly avoid the stun!", "text-green-400");
                    }
                    updateUI();
                }
            },
            power_surge: {
                name: "Power Surge",
                description: "Boss gains increased strength!",
                effect: function() {
                    combatData.attack += 2;
                    combatData.strength += 3;
                    addLog("The boss surges with dark energy!", "text-red-500 font-bold");
                    addLog(`Attack increased! (now ${combatData.attack})`, "text-red-400");
                }
            },
            dark_blessing: {
                name: "Dark Blessing",
                description: "Boss gains increased defense!",
                effect: function() {
                    combatData.armor += 3;
                    addLog("The boss gains a protective aura!", "text-purple-400 font-bold");
                    addLog(`Armor increased! (now ${combatData.armor})`, "text-purple-400");
                }
            },
            freeze_field: {
                name: "Freeze Field",
                description: "Boss encases area in ice, reducing your damage!",
                effect: function() {
                    stats.frozen_field = 3; // Lasts 3 of player's turns
                    addLog("The boss creates a freeze field around you!", "text-cyan-400 font-bold");
                    addLog("Your damage will be reduced for the next 3 turns!", "text-cyan-400");
                }
            },
            drain_life: {
                name: "Drain Life",
                description: "Boss steals your health!",
                effect: function() {
                    const damage = Math.floor(Math.random()*10)+5;
                    stats.HP -= damage;
                    combatData.HP = Math.min(combatData.HP + damage, combatData.maxHP);
                    addLog(`The boss drains ${damage} HP from you!`, "text-purple-500 font-bold");
                    addLog(`The boss recovers ${damage} HP!`, "text-red-400");
                    updateUI();
                }
            },
            summon_minion: {
                name: "Summon Minion",
                description: "Boss summons an ally to aid in battle!",
                effect: function() {
                    combatData.minion_hp = Math.floor(Math.random()*20)+10;
                    addLog("The boss summons a dark minion to aid it!", "text-red-500 font-bold");
                    addLog(`Minion HP: ${combatData.minion_hp}`, "text-red-400");
                }
            }
        };

        // Function to determine if boss uses ability
        function bossShouldUseAbility(type, hpPercent) {
            // Boss-type specific abilities
            if (type === 'boss') {
                if (hpPercent < 0.3) return Math.random() < 0.6; // 60% at low health
                if (hpPercent < 0.6) return Math.random() < 0.4; // 40% at mid health
                return Math.random() < 0.2; // 20% at high health
            } else if (type === 'mini') {
                if (hpPercent < 0.4) return Math.random() < 0.4;
                return Math.random() < 0.15;
            } else if (type === 'lichking') {
                if (hpPercent < 0.2) return Math.random() < 0.8; // Very aggressive at low health
                if (hpPercent < 0.5) return Math.random() < 0.6;
                return Math.random() < 0.3;
            }
            return false;
        }

        // Function to get available abilities for a specific boss type
        function getAvailableAbilities(type) {
            const abilityMap = {
                'boss': ['phase_shift', 'multi_attack', 'power_surge', 'dark_blessing'],
                'mini': ['power_surge', 'stun_attack', 'dark_blessing'],
                'lichking': ['phase_shift', 'multi_attack', 'drain_life', 'power_surge', 'dark_blessing', 'freeze_field', 'summon_minion']
            };
            return abilityMap[type] || [];
        }

        // --- DUNGEON ---
        function generateMonsterName(type) {
            const wanderingNames = [
                'Wandering Goblin', 'Wandering Orc', 'Wandering Bandit', 'Wandering Skeleton',
                'Wandering Troll', 'Wandering Zombie', 'Wandering Wraith', 'Wandering Ghoul',
                'Wandering Brigand', 'Wandering Specter', 'Wandering Shadow', 'Wandering Beast'
            ];
            
            const normalNames = [
                'Forest Goblin', 'Stone Golem', 'Giant Rat', 'Dark Knight',
                'Cursed Warrior', 'Shadow Mage', 'Plague Zombie', 'Ice Elemental',
                'Fire Imp', 'Void Creature', 'Twisted Beast', 'Corrupt Cultist',
                'Frostbite Spider', 'Acid Slime', 'Blood Knight', 'Chaos Thrall'
            ];
            
            const miniNames = [
                'Warlord Kex', 'Sorcerer Malach', 'Guardian Vex', 'Dread Knight Thorne',
                'Plague Master', 'Void Caller', 'Storm Tyrant', 'Shadow Lord',
                'Infernal Protector', 'Cursed Champion', 'Abomination King', 'Lich Keeper'
            ];
            
            const bossNames = [
                'ANCIENT DRAGON', 'DARK LORD', 'VOID EMPRESS', 'CHAOS TYRANT',
                'SHADOW SOVEREIGN', 'ABYSSAL OVERLORD', 'CORRUPTED TITAN', 'NIGHTMARE KING',
                'ETERNAL WRAITH', 'INFERNAL DEITY', 'COSMIC HORROR', 'DREAD LEVIATHAN'
            ];
            
            if (type === 'wandering') {
                return wanderingNames[Math.floor(Math.random() * wanderingNames.length)];
            } else if (type === 'normal') {
                return normalNames[Math.floor(Math.random() * normalNames.length)];
            } else if (type === 'mini') {
                return miniNames[Math.floor(Math.random() * miniNames.length)];
            } else if (type === 'boss') {
                return bossNames[Math.floor(Math.random() * bossNames.length)];
            }
            return "Unknown Monster";
        }

        function generateMonsterStats(type) {
            // Scale difficulty with both floor and player level
            let floorMultiplier = 1 + (stats.floor - 1) * 0.20; // Each floor +20%
            
            // Level scaling: Much easier at level 1, gradually increases
            let levelMultiplier;
            if (stats.level === 1) {
                levelMultiplier = 0.6; // Level 1: 60% difficulty (much easier)
            } else if (stats.level === 2) {
                levelMultiplier = 0.75; // Level 2: 75% difficulty
            } else if (stats.level === 3) {
                levelMultiplier = 0.9; // Level 3: 90% difficulty
            } else {
                // Level 4+: 100% + 15% per level above 3
                levelMultiplier = 1.0 + (stats.level - 4) * 0.15;
            }
            
            let diffMultiplier = floorMultiplier * levelMultiplier;
            
            let mStats = {};
            if (type === 'wandering') {
                mStats = {
                    HP: 0, 
                    armor: Math.floor((Math.floor(Math.random()*3)+10) * diffMultiplier),
                    attack: Math.floor((Math.floor(Math.random()*3)+2) * diffMultiplier),
                    strength: Math.floor((Math.floor(Math.random()*3)+1) * diffMultiplier),
                    dexterity: Math.floor((Math.floor(Math.random()*4)+9) * diffMultiplier),
                    change_strength: false, freeze: 0, fire: false
                };
                for(let i=0; i<4; i++) mStats.HP += Math.floor((Math.floor(Math.random()*4)+2) * diffMultiplier);
            } else if (type === 'normal') {
                mStats = {
                    HP: Math.floor((Math.floor(Math.random()*12)+Math.floor(Math.random()*12)+Math.floor(Math.random()*12)+15) * diffMultiplier),
                    armor: Math.floor((Math.floor(Math.random()*3)+13) * diffMultiplier),
                    attack: Math.floor((Math.floor(Math.random()*3)+3) * diffMultiplier),
                    strength: Math.floor((Math.floor(Math.random()*3)+2) * diffMultiplier),
                    dexterity: Math.floor((Math.floor(Math.random()*4)+11) * diffMultiplier),
                    change_strength: false, freeze: 0, fire: false
                };
            } else if (type === 'mini') {
                mStats = {
                    HP: Math.floor((Math.floor(Math.random()*25)+70) * diffMultiplier),
                    armor: Math.floor((Math.floor(Math.random()*3)+16) * diffMultiplier),
                    attack: Math.floor((Math.floor(Math.random()*3)+5) * diffMultiplier),
                    strength: Math.floor((Math.floor(Math.random()*3)+4) * diffMultiplier),
                    dexterity: Math.floor((Math.floor(Math.random()*4)+13) * diffMultiplier),
                    change_strength: false, freeze: 0, fire: false,
                    type: 'mini',
                    maxHP: 0  // Will be set after all stats
                };
                for(let i=0; i<5; i++) mStats.HP += Math.floor((Math.floor(Math.random()*8)+4) * diffMultiplier);
                mStats.maxHP = mStats.HP;
            } else if (type === 'boss') {
                mStats = {
                    HP: 0, 
                    armor: Math.floor((Math.floor(Math.random()*4)+18) * diffMultiplier),
                    attack: Math.floor((Math.floor(Math.random()*3)+6) * diffMultiplier),
                    strength: Math.floor((Math.floor(Math.random()*4)+5) * diffMultiplier),
                    dexterity: Math.floor((Math.floor(Math.random()*5)+15) * diffMultiplier),
                    change_strength: false, freeze: 0, fire: false,
                    type: 'boss',
                    maxHP: 0  // Will be set after all stats
                };
                for(let i=0; i<25; i++) mStats.HP += Math.floor((Math.floor(Math.random()*6)+2) * diffMultiplier);
                mStats.maxHP = mStats.HP;
            }
            return mStats;
        }

        function generateRoom(row, col) {
            let val = 10000000;
            
            // Make starting room (9,9) on floor 1 completely safe
            if (row === 9 && col === 9 && stats.floor === 1) {
                return val; // Empty safe room
            }
            
            const r1 = Math.floor(Math.random()*5)+1; // Reduced chest chance (20%)
            if (r1 === 1) { // Chest
                if(Math.floor(Math.random()*4)+1 === 1) val += 10;
                else val += 1;
            }
            const r2 = Math.floor(Math.random()*5)+1; // Reduced monster chance (20%)
            if (r2 === 1) { // Monster
                if(Math.floor(Math.random()*3)+1 === 1) {
                    val += 1000;
                    const w = generateMonsterStats('wandering');
                    w.name = generateMonsterName('wandering');
                    monsterData[`${row},${col},${stats.floor}`] = w;
                } else {
                    val += 100;
                    const m = generateMonsterStats('normal');
                    m.name = generateMonsterName('normal');
                    monsterData[`${row},${col},${stats.floor}`] = m;
                }
            }
            if (Math.floor(Math.random()*16)+1 === 1) val += 10000; // Reduced from 1/12
            if (Math.floor(Math.random()*25)+1 === 1) { // Boss (reduced from 1/20)
                if(Math.floor(Math.random()*3)+1 === 1) {
                    val += 1000000;
                    const m = generateMonsterStats('boss');
                    m.name = generateMonsterName('boss');
                    monsterData[`${row},${col},${stats.floor}`] = m;
                } else {
                    val += 100000;
                    const mm = generateMonsterStats('mini');
                    mm.name = generateMonsterName('mini');
                    monsterData[`${row},${col},${stats.floor}`] = mm;
                }
            }
            // Shopkeeper chance (10% per room, but only on floors 1-9)
            if (stats.floor <= 9 && Math.floor(Math.random()*10)+1 === 1) {
                val += 100000000; // Shopkeeper marker (highest value to prioritize)
                const shopData = {
                    floor: stats.floor,
                    row: row,
                    col: col
                };
                monsterData[`shop_${row},${col},${stats.floor}`] = shopData;
            }
            return val;
        }

        function generateLichKing() {
            // The final boss scales with player level significantly
            let levelMultiplier = 1 + (stats.level - 1) * 0.2;
            const hp = Math.floor(150 * levelMultiplier);
            return {
                HP: hp,
                maxHP: hp,
                armor: Math.floor(20 * levelMultiplier),
                attack: Math.floor(8 * levelMultiplier),
                strength: Math.floor(8 * levelMultiplier),
                dexterity: Math.floor(16 * levelMultiplier),
                name: 'THE GOBLIN KING',
                type: 'lichking',
                change_strength: false, freeze: 0, fire: false
            };
        }

        function enterDungeon() {
            // Special handling for floor 10 - The Goblin King's throne
            if (stats.floor === 10) {
                const theme = FLOOR_THEMES[10];
                addLog(`===== ${theme.name} =====`, 'text-red-600 font-black text-lg');
                addLog(theme.description, 'text-red-500 italic');
                addLog('You have reached the deepest depths of the dungeon...', 'text-red-500 font-bold');
                addLog('Before you stands THE GOBLIN KING, an ancient evil incarnate!', 'text-red-600 font-black text-lg');
                const lichKing = generateLichKing();
                monsterData['lichking'] = lichKing;
                setTimeout(() => showPreCombatSavePrompt('THE GOBLIN KING', 'lichking'), 500);
                return;
            }
            
            const theme = FLOOR_THEMES[stats.floor] || FLOOR_THEMES[1];
            addLog(`===== FLOOR ${stats.floor}: ${theme.name} =====`, 'text-cyan-400 font-bold text-lg');
            addLog(theme.description, 'text-cyan-300 italic');
            
            const floorKey = `floor_${stats.floor}`;
            if(!floorMaps[floorKey]) {
                floorMaps[floorKey] = Array.from({length:10}, (_, row) => 
                    Array.from({length:10}, (_, col) => generateRoom(row, col))
                );
            }
            // Only reset to [9,9] if entering from town (floor 1 and no current position set)
            if (stats.floor === 1 && (currentRoom[0] !== 9 || currentRoom[1] !== 9)) {
                currentRoom = [9, 9];
            }
            showView('view-dungeon');
            renderDungeon();
            checkRoom();
        }

        function renderDungeon() {
            const mapEl = document.getElementById('mini-map');
            mapEl.innerHTML = '';
            const floorKey = `floor_${stats.floor}`;
            
            for(let r=0; r<10; r++) {
                for(let c=0; c<10; c++) {
                    const isPlayer = r===currentRoom[0] && c===currentRoom[1];
                    const cell = document.createElement('div');
                    
                    // Default styling
                    let bgColor = 'bg-slate-800';
                    let icon = '';
                    
                    // If player has map, show special room markers
                    if (stats.hasMap && floorMaps[floorKey]) {
                        const val = String(floorMaps[floorKey][r][c]).padStart(9, '0');
                        
                        // Priority order: Merchant > Boss > Mini-boss > Stairs
                        // Check for merchant (position 0 - highest priority marker)
                        const shopKey = `shop_${r},${c},${stats.floor}`;
                        if (monsterData[shopKey]) {
                            bgColor = 'bg-amber-700';
                            icon = 'üì¶';
                        }
                        // Check for boss (position 2 in 9-digit string)
                        else if (val[2] === '1') {
                            bgColor = 'bg-red-700';
                            icon = 'üëë';
                        }
                        // Check for mini-boss (position 3 in 9-digit string)
                        else if (val[3] === '1') {
                            bgColor = 'bg-orange-700';
                            icon = '‚öî';
                        }
                        // Check for stairs (position 4 in 9-digit string)
                        else if (val[4] === '1') {
                            bgColor = 'bg-green-700';
                            icon = '‚¨á';
                        }
                    }
                    
                    // Player position overrides everything
                    if (isPlayer) {
                        bgColor = 'bg-blue-400 shadow-[0_0_10px_rgba(96,165,250,0.8)]';
                        icon = '';
                    }
                    
                    cell.className = `w-6 h-6 rounded ${bgColor} flex items-center justify-center text-xs`;
                    if (icon) {
                        cell.innerText = icon;
                    }
                    
                    mapEl.appendChild(cell);
                }
            }
        }

        function movePlayer(dr, dc) {
            if (isProcessing) return;
            // Block movement if any modal is open
            if (document.getElementById('pre-combat-modal') || document.getElementById('quick-save-modal') || document.getElementById('load-modal') || document.getElementById('save-modal')) {
                return;
            }
            const nr = currentRoom[0] + dr, nc = currentRoom[1] + dc;
            if(nr >= 0 && nr < 10 && nc >= 0 && nc < 10) {
                currentRoom = [nr, nc];
                renderDungeon();
                updateUI();
                checkRoom();
            }
        }

        function checkRoom(suppressEvents = false) {
            if(suppressEvents) return;
            const floorKey = `floor_${stats.floor}`;
            const val = String(floorMaps[floorKey][currentRoom[0]][currentRoom[1]]).padStart(9, '0');
            const act = document.getElementById('room-actions');
            act.innerHTML = '';

            // Check for shopkeeper first
            const shopKey = `shop_${currentRoom[0]},${currentRoom[1]},${stats.floor}`;
            if (monsterData[shopKey]) {
                const shopFloor = stats.floor;
                if (DUNGEON_SHOPS[shopFloor]) {
                    const shop = DUNGEON_SHOPS[shopFloor];
                    const b = document.createElement('button');
                    b.className = "px-6 py-3 bg-amber-700 hover:bg-amber-600 rounded text-sm font-bold uppercase";
                    b.innerText = `üì¶ Talk to ${shop.name}`;
                    b.onclick = () => showDungeonShop(shop);
                    act.appendChild(b);
                    
                    const br = document.createElement('br');
                    act.appendChild(br);
                }
            }

            // Check for permanent room encounters
            const monsterKey = `${currentRoom[0]},${currentRoom[1]},${stats.floor}`;
            let hasMonster = false;
            
            if (val[2] === '1') {
                const name = monsterData[monsterKey] && monsterData[monsterKey].name ? monsterData[monsterKey].name : generateMonsterName('boss');
                showPreCombatSavePrompt(name, 'boss');
                hasMonster = true;
            } else if (val[3] === '1') {
                const name = monsterData[monsterKey] && monsterData[monsterKey].name ? monsterData[monsterKey].name : generateMonsterName('mini');
                showPreCombatSavePrompt(name, 'mini');
                hasMonster = true;
            } else if (val[5] === '1') {
                // wandering monsters are typically not pre-generated; generate a wandering name
                const name = monsterData[monsterKey] && monsterData[monsterKey].name ? monsterData[monsterKey].name : generateMonsterName('wandering');
                showPreCombatSavePrompt(name, 'wandering');
                hasMonster = true;
            } else if (val[6] === '1') {
                const name = monsterData[monsterKey] && monsterData[monsterKey].name ? monsterData[monsterKey].name : generateMonsterName('normal');
                showPreCombatSavePrompt(name, 'normal');
                hasMonster = true;
            } else if (Math.random() < 0.25 && !(currentRoom[0] === 9 && currentRoom[1] === 9 && stats.floor === 1)) {
                // Random wandering monster spawn (25% chance in any room)
                // This gives the same likelihood in visited and unvisited rooms
                // But NOT in the starting room (9,9) on floor 1
                const name = generateMonsterName('wandering');
                showPreCombatSavePrompt(name, 'wandering');
                hasMonster = true;
            }
            
            // If there's a monster, don't show other room features yet
            if (hasMonster) return;
            
            // Show chests and other room features
            if (val[7] === '1') createChestBtn(act, true);
            if (val[8] === '1') createChestBtn(act, false);
            
            // Stairs Down
            if (val[4] === '1') {
                const b = document.createElement('button');
                b.className = "px-6 py-3 bg-blue-700 hover:bg-blue-600 rounded text-sm font-bold uppercase";
                b.innerText = "Stairs Down";
                b.onclick = () => {
                    stats.floor++;
                    addLog(`Descending to Floor ${stats.floor}...`, "text-blue-400 font-bold");
                    
                    // Generate floor if needed
                    const floorKey = `floor_${stats.floor}`;
                    if(!floorMaps[floorKey]) {
                        floorMaps[floorKey] = Array.from({length:10}, (_, row) => 
                            Array.from({length:10}, (_, col) => generateRoom(row, col))
                        );
                    }
                    
                    // Stay in same room position
                    showView('view-dungeon');
                    renderDungeon();
                    checkRoom();
                };
                act.appendChild(b);
            }
            
            // Stairs Up (only show if not on floor 1)
            if (stats.floor > 1) {
                const upBtn = document.createElement('button');
                upBtn.className = "px-6 py-3 bg-green-700 hover:bg-green-600 rounded text-sm font-bold uppercase";
                upBtn.innerText = "Stairs Up";
                upBtn.onclick = () => {
                    stats.floor--;
                    addLog(`Ascending to Floor ${stats.floor}...`, "text-green-400 font-bold");
                    
                    // Stay in same room position
                    showView('view-dungeon');
                    renderDungeon();
                    checkRoom();
                };
                act.appendChild(upBtn);
            }
            
            // Checkpoint buttons
            const checkpointBtn = document.createElement('button');
            checkpointBtn.className = "px-6 py-3 bg-cyan-700 hover:bg-cyan-600 rounded text-sm font-bold uppercase";
            
            // Check if there's a checkpoint at current location
            let checkpointAtLocation = null;
            for (let cpName in stats.checkpoints) {
                const cp = stats.checkpoints[cpName];
                if (cp.floor === stats.floor && cp.row === currentRoom[0] && cp.col === currentRoom[1]) {
                    checkpointAtLocation = cpName;
                    break;
                }
            }
            
            if (checkpointAtLocation) {
                checkpointBtn.innerText = `‚úì ${checkpointAtLocation}`;
                checkpointBtn.disabled = true;
                checkpointBtn.className = "px-6 py-3 bg-green-700 rounded text-sm font-bold uppercase opacity-75";
            } else {
                checkpointBtn.innerText = `Set Checkpoint (${Object.keys(stats.checkpoints).length}/${stats.checkpointsPurchased})`;
                if (stats.checkpointsPurchased > Object.keys(stats.checkpoints).length) {
                    checkpointBtn.onclick = () => showCheckpointNamingDialog();
                } else {
                    checkpointBtn.disabled = true;
                    checkpointBtn.className = "px-6 py-3 bg-slate-700 rounded text-sm font-bold uppercase opacity-50 cursor-not-allowed";
                    checkpointBtn.innerText = "No Checkpoints Available (Buy One!)";
                }
            }
            act.appendChild(checkpointBtn);
            
            // Teleport to checkpoint button (if any checkpoints exist)
            if (Object.keys(stats.checkpoints).length > 0) {
                const teleportBtn = document.createElement('button');
                teleportBtn.className = "px-6 py-3 bg-purple-700 hover:bg-purple-600 rounded text-sm font-bold uppercase";
                teleportBtn.innerText = `Teleport to Checkpoint`;
                teleportBtn.onclick = () => showCheckpointTeleportDialog();
                act.appendChild(teleportBtn);
            }
        }

        function showCheckpointNamingDialog() {
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.9);display:flex;align-items:center;justify-content:center;z-index:10000;';
            
            let html = '<div style="background:#1e293b;padding:2rem;border-radius:10px;max-width:400px;width:90%;">';
            html += '<h2 style="font-size:1.3rem;font-weight:bold;margin-bottom:1rem;text-align:center;color:white;">NAME YOUR CHECKPOINT</h2>';
            html += '<div style="background:#0f172a;padding:1.5rem;border-radius:8px;margin-bottom:1rem;border:2px solid #334155;">';
            html += '<div style="font-size:0.9rem;color:#94a3b8;margin-bottom:0.5rem;">Enter a name for this checkpoint:</div>';
            html += '<input id="checkpoint-name-input" type="text" placeholder="e.g., Safe Room, Boss Arena..." style="width:100%;padding:0.75rem;background:#1e293b;border:2px solid #475569;border-radius:6px;color:white;font-size:0.95rem;outline:none;box-sizing:border-box;" />';
            html += '<div style="font-size:0.8rem;color:#64748b;margin-top:0.5rem;">Location: Floor ' + stats.floor + ' [' + currentRoom[0] + ',' + currentRoom[1] + ']</div>';
            html += '</div>';
            html += '<div style="display:flex;gap:0.75rem;">';
            html += '<button onclick="confirmCheckpointName()" style="flex:1;padding:0.75rem;background:#06b6d4;border-radius:8px;font-weight:bold;color:white;font-size:0.95rem;cursor:pointer;border:none;">SET CHECKPOINT</button>';
            html += '<button onclick="closeCheckpointDialog()" style="flex:1;padding:0.75rem;background:#64748b;border-radius:8px;font-weight:bold;color:white;font-size:0.95rem;cursor:pointer;border:none;">CANCEL</button>';
            html += '</div>';
            html += '</div>';
            
            modal.innerHTML = html;
            modal.id = 'checkpoint-naming-modal';
            document.body.appendChild(modal);
            
            setTimeout(() => {
                document.getElementById('checkpoint-name-input').focus();
            }, 100);
        }
        
        function confirmCheckpointName() {
            const name = document.getElementById('checkpoint-name-input').value.trim();
            if (name === '') {
                addLog('Please enter a checkpoint name!', 'text-red-400');
                return;
            }
            
            if (stats.checkpoints[name]) {
                addLog('A checkpoint with that name already exists!', 'text-red-400');
                return;
            }
            
            stats.checkpoints[name] = { floor: stats.floor, row: currentRoom[0], col: currentRoom[1] };
            addLog(`Checkpoint "${name}" set at Floor ${stats.floor} [${currentRoom[0]},${currentRoom[1]}]`, "text-cyan-400 font-bold");
            closeCheckpointDialog();
            checkRoom();
        }
        
        function closeCheckpointDialog() {
            const modal = document.getElementById('checkpoint-naming-modal');
            if (modal) modal.remove();
        }
        
        function showCheckpointTeleportDialog() {
            const checkpoints = Object.keys(stats.checkpoints);
            if (checkpoints.length === 0) {
                addLog('No checkpoints set!', 'text-red-400');
                return;
            }
            
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.9);display:flex;align-items:center;justify-content:center;z-index:10000;';
            
            let html = '<div style="background:#1e293b;padding:2rem;border-radius:10px;max-width:400px;width:90%;max-height:70vh;overflow-y:auto;">';
            html += '<h2 style="font-size:1.3rem;font-weight:bold;margin-bottom:1rem;text-align:center;color:white;">SELECT CHECKPOINT</h2>';
            
            checkpoints.forEach(cpName => {
                const cp = stats.checkpoints[cpName];
                html += `<button onclick="teleportToCheckpoint('${cpName}')" style="width:100%;padding:1rem;margin-bottom:0.75rem;background:#0f172a;border:2px solid #334155;border-radius:8px;color:white;text-align:left;cursor:pointer;transition:all 0.2s;font-weight:bold;font-size:0.95rem;">`;
                html += `<div style="color:#06b6d4;">${cpName}</div>`;
                html += `<div style="color:#94a3b8;font-size:0.85rem;margin-top:0.25rem;">Floor ${cp.floor} [${cp.row},${cp.col}]</div>`;
                html += `</button>`;
            });
            
            html += '<button onclick="closeTeleportDialog()" style="width:100%;padding:0.75rem;background:#64748b;border-radius:8px;font-weight:bold;color:white;font-size:0.95rem;cursor:pointer;border:none;margin-top:1rem;">CANCEL</button>';
            html += '</div>';
            
            modal.innerHTML = html;
            modal.id = 'checkpoint-teleport-modal';
            document.body.appendChild(modal);
        }
        
        function teleportToCheckpoint(cpName) {
            const cp = stats.checkpoints[cpName];
            
            if (cp.floor !== stats.floor) {
                stats.floor = cp.floor;
                addLog(`Teleporting to Floor ${stats.floor}...`, "text-purple-400 font-bold");
                closeTeleportDialog();
                enterDungeon();
            } else {
                currentRoom = [cp.row, cp.col];
                addLog(`Teleported to "${cpName}"!`, "text-purple-400 font-bold");
                closeTeleportDialog();
                renderDungeon();
                checkRoom();
            }
        }
        
        function closeTeleportDialog() {
            const modal = document.getElementById('checkpoint-teleport-modal');
            if (modal) modal.remove();
        }

        function showDungeonShop(shop) {
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.95);display:flex;align-items:center;justify-content:center;z-index:10000;';
            
            let html = '<div style="background:#1e293b;padding:2rem;border-radius:10px;max-width:500px;width:95%;max-height:70vh;overflow-y:auto;">';
            html += `<h2 style="font-size:1.3rem;font-weight:bold;margin-bottom:0.5rem;text-align:center;color:#fbbf24;">üè™ ${shop.name}</h2>`;
            html += `<p style="text-align:center;color:#94a3b8;margin-bottom:1.5rem;font-size:0.9rem;font-style:italic;">"${shop.greeting}"</p>`;
            html += '<div style="background:#0f172a;padding:1rem;border-radius:8px;border:2px solid #334155;margin-bottom:1rem;">';
            html += `<div style="color:#94a3b8;font-size:0.85rem;">Your Gold: <span style="color:#fbbf24;font-weight:bold;">${stats.coins}</span></div>`;
            html += '</div>';
            
            html += '<div style="max-height:350px;overflow-y:auto;">';
            for (let itemName in shop.inventory) {
                const itemData = shop.inventory[itemName];
                const cost = itemData[0];
                const itemValue = itemData[1];
                const itemType = itemData[2]; // 1=weapon, 2=armor, 3=potion, 4=spell
                const effect = itemData[3];
                
                let typeLabel = '';
                let typeColor = '';
                if (itemType === 1) { typeLabel = '‚öîÔ∏è Weapon'; typeColor = '#ef4444'; }
                else if (itemType === 2) { typeLabel = 'üõ°Ô∏è Armor'; typeColor = '#3b82f6'; }
                else if (itemType === 3) { typeLabel = 'üß™ Potion'; typeColor = '#10b981'; }
                else if (itemType === 4) { typeLabel = '‚ú® Spell'; typeColor = '#a855f7'; }
                
                const canAfford = stats.coins >= cost;
                const buttonStyle = canAfford 
                    ? 'background:#06b6d4;cursor:pointer;opacity:1;' 
                    : 'background:#64748b;cursor:not-allowed;opacity:0.5;';
                
                html += `<button onclick="buyDungeonItem('${itemName}', ${cost}, ${itemType}, ${effect})" style="width:100%;padding:1rem;margin-bottom:0.75rem;background:#0f172a;border:2px solid #334155;border-radius:8px;color:white;text-align:left;transition:all 0.2s;" onmouseover="this.style.borderColor='#475569'" onmouseout="this.style.borderColor='#334155'">`;
                html += `<div style="display:flex;justify-content:space-between;align-items:center;">`;
                html += `<div>`;
                html += `<div style="font-weight:bold;margin-bottom:0.25rem;">${itemName}</div>`;
                html += `<div style="color:#94a3b8;font-size:0.85rem;"><span style="color:${typeColor};">${typeLabel}</span></div>`;
                html += `</div>`;
                html += `<div style="text-align:right;">`;
                html += `<div style="color:#fbbf24;font-weight:bold;font-size:1.1rem;">${cost}g</div>`;
                html += `</div>`;
                html += `</div>`;
                html += `<div style="margin-top:0.5rem;padding-top:0.75rem;border-top:1px solid #334155;font-size:0.8rem;color:#64748b;">Click to buy</div>`;
                html += `</button>`;
            }
            html += '</div>';
            
            html += '<button onclick="closeDungeonShop()" style="width:100%;padding:0.75rem;margin-top:1rem;background:#64748b;border-radius:8px;font-weight:bold;color:white;font-size:0.95rem;cursor:pointer;border:none;">LEAVE SHOP</button>';
            html += '</div>';
            
            modal.innerHTML = html;
            modal.id = 'dungeon-shop-modal';
            document.body.appendChild(modal);
        }

        function buyDungeonItem(itemName, cost, itemType, effect) {
            if (stats.coins < cost) {
                addLog('You cannot afford that!', 'text-red-400');
                return;
            }
            
            stats.coins -= cost;
            
            if (itemType === 1) {
                // Weapon
                if (!stats.weapons[itemName]) {
                    stats.weapons[itemName] = effect;
                    addLog(`Purchased ${itemName}!`, 'text-green-400 font-bold');
                } else {
                    stats.coins += cost; // Refund if already have
                    addLog('You already have this weapon!', 'text-yellow-400');
                    return;
                }
            } else if (itemType === 2) {
                // Armor
                if (!stats.armors[itemName]) {
                    stats.armors[itemName] = effect;
                    addLog(`Purchased ${itemName}!`, 'text-green-400 font-bold');
                } else {
                    stats.coins += cost; // Refund if already have
                    addLog('You already have this armor!', 'text-yellow-400');
                    return;
                }
            } else if (itemType === 3) {
                // Potion
                if (!stats.potions[itemName]) {
                    stats.potions[itemName] = [1, effect];
                } else {
                    stats.potions[itemName][0]++;
                }
                addLog(`Purchased ${itemName}!`, 'text-green-400 font-bold');
            } else if (itemType === 4) {
                // Spell
                if (!stats.spells[itemName]) {
                    stats.spells[itemName] = [1, effect];
                } else {
                    stats.spells[itemName][0]++;
                }
                addLog(`Purchased ${itemName}!`, 'text-green-400 font-bold');
            }
            
            updateUI();
            closeDungeonShop();
            showDungeonShop(DUNGEON_SHOPS[stats.floor]); // Reopen to show updated inventory
        }

        function closeDungeonShop() {
            const modal = document.getElementById('dungeon-shop-modal');
            if (modal) modal.remove();
        }

        function createChestBtn(p, isBig) {
            const chestId = `chest_${currentRoom[0]}_${currentRoom[1]}_${stats.floor}`;
            const b = document.createElement('button');
            b.className = "px-6 py-3 bg-yellow-700 hover:bg-yellow-600 rounded text-sm font-bold uppercase";
            b.innerText = isBig ? "Open Big Chest" : "Open Small Chest";
            
            if(stats.openedChests.has(chestId)) return;

            b.onclick = async () => {
                if (isProcessing) return;
                isProcessing = true;
                
                if (isBig) {
                    addLog("Big Chest! Attempting to unlock with Intelligence...", "text-yellow-400");
                    
                    const statVal = stats.intelligence + stats.temporary_intelligence;
                    await logLoading("Rolling Intelligence", 3, 200);
                    const baseRoll = Math.floor(Math.random()*20)+1;
                    const mod = Math.floor(statVal / 2) - 5;
                    const roll = baseRoll + mod;
                    const need = Math.floor(Math.random()*5)+10;
                    addLog(`Rolled ${baseRoll} + ${mod} = ${roll}. Need ${need}.`);
                    
                    if (roll >= need) {
                        addLog("Success! You cleverly unlock the chest!", "text-green-500 font-bold");
                        const loot = Math.floor(Math.random()*71)+30;  // 30-100 gold
                        stats.coins += loot;
                        addLog(`Found ${loot} coins!`, "text-yellow-500");
                        
                        // 1/3 chance to find a random potion or spell
                        if (Math.floor(Math.random()*3) === 0) {
                            const isPotionNotSpell = Math.random() < 0.5;
                            const potionNames = ["healing potion", "intelligence potion", "speed potion", "strength potion", "protection potion"];
                            const spellNames = ["magic missile spell", "weakness spell", "lightning spell", "freeze spell", "fireball spell"];
                            
                            const itemList = isPotionNotSpell ? potionNames : spellNames;
                            const itemName = itemList[Math.floor(Math.random() * itemList.length)];
                            const itemData = SHOP_DATA[itemName];
                            const rarity = getItemRarity();
                            const rarityInfo = RARITY[rarity];
                            
                            if (isPotionNotSpell) {
                                if(!stats.potions[itemName]) stats.potions[itemName] = [0, itemData[3]];
                                stats.potions[itemName][0]++;
                                addLog(`Found a [${rarityInfo.name}] ${itemName}!`, "text-purple-400 font-bold");
                            } else {
                                if(!stats.spells[itemName]) stats.spells[itemName] = [0, itemData[3]];
                                stats.spells[itemName][0]++;
                                addLog(`Found a [${rarityInfo.name}] ${itemName}!`, "text-purple-400 font-bold");
                            }
                        }
                        
                        const floorKey = `floor_${stats.floor}`;
                        floorMaps[floorKey][currentRoom[0]][currentRoom[1]] -= 10;
                        stats.openedChests.add(chestId);
                    } else {
                        addLog("Failed! The chest remains locked.", "text-red-500");
                        const floorKey = `floor_${stats.floor}`;
                        floorMaps[floorKey][currentRoom[0]][currentRoom[1]] -= 10;
                    }
                    
                    stats.temporary_intelligence = 0;
                    isProcessing = false;
                    checkRoom();
                    updateUI();
                } else {
                    if (Math.floor(Math.random()*3)+1 !== 1) {
                        const loot = Math.floor(Math.random()*36)+5;
                        stats.coins += loot;
                        addLog(`Found ${loot} coins.`, "text-yellow-500");
                        const floorKey = `floor_${stats.floor}`;
                        floorMaps[floorKey][currentRoom[0]][currentRoom[1]] -= 1;
                    } else {
                        addLog("The chest was empty.", "text-slate-500");
                    }
                    isProcessing = false;
                    checkRoom();
                    updateUI();
                }
            };
            p.appendChild(b);
        }

        // --- COMBAT ---
        function showPreCombatSavePrompt(name, type) {
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.9);display:flex;align-items:center;justify-content:center;z-index:10000;';
            
            const monsterIcon = type === 'boss' ? 'üëπ' : type === 'mini' ? 'üòà' : 'üëæ';
            
            let html = '<div style="background:#1e293b;padding:2rem;border-radius:10px;max-width:400px;width:90%;border:3px solid #dc2626;">';
            html += `<div style="text-align:center;font-size:3rem;margin-bottom:1rem;">${monsterIcon}</div>`;
            html += '<h2 style="font-size:1.3rem;font-weight:bold;margin-bottom:1rem;text-align:center;color:#ef4444;">BATTLE AHEAD!</h2>';
            html += '<div style="background:#0f172a;padding:1.5rem;border-radius:8px;margin-bottom:1rem;border:2px solid #7f1d1d;text-align:center;">';
            html += `<div style="font-size:1.1rem;font-weight:bold;color:#fbbf24;text-transform:uppercase;margin-bottom:0.5rem;">${name}</div>`;
            html += `<div style="font-size:0.9rem;color:#94a3b8;">You are about to enter combat!</div>`;
            html += '</div>';
            html += '<div style="font-size:0.85rem;color:#94a3b8;text-align:center;margin-bottom:1.5rem;">Would you like to save your game first?</div>';
            html += '<div style="display:flex;gap:0.75rem;flex-direction:column;">';
            html += `<button onclick="saveBeforeCombat('${name}', '${type}')" style="width:100%;padding:0.75rem;background:#10b981;border-radius:8px;font-weight:bold;color:white;font-size:0.95rem;cursor:pointer;border:none;">SAVE & FIGHT</button>`;
            html += `<button onclick="proceedToCombat('${name}', '${type}')" style="width:100%;padding:0.75rem;background:#dc2626;border-radius:8px;font-weight:bold;color:white;font-size:0.95rem;cursor:pointer;border:none;">FIGHT NOW</button>`;
            html += '</div>';
            html += '</div>';
            
            modal.innerHTML = html;
            modal.id = 'pre-combat-modal';
            document.body.appendChild(modal);
        }

        async function saveBeforeCombat(name, type) {
            closePreCombatModal();
            // Show loading indicator while fetching slots
            const loadingModal = document.createElement('div');
            loadingModal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.9);display:flex;align-items:center;justify-content:center;z-index:10000;';
            loadingModal.innerHTML = '<div style="text-align:center;color:white;"><div style="font-size:2rem;margin-bottom:1rem;">‚è≥</div><div>Loading save slots...</div></div>';
            loadingModal.id = 'loading-modal';
            document.body.appendChild(loadingModal);
            
            const slots = await getAllSaveSlots();
            
            // Remove loading modal immediately
            const existingLoading = document.getElementById('loading-modal');
            if (existingLoading) existingLoading.remove();
            
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.9);display:flex;align-items:center;justify-content:center;z-index:10000;';
            
            let html = '<div style="background:#1e293b;padding:2rem;border-radius:10px;max-width:500px;width:90%;">';
            html += '<h2 style="font-size:1.5rem;font-weight:bold;margin-bottom:1.5rem;text-align:center;color:white;">QUICK SAVE</h2>';
            html += '<div style="display:flex;flex-direction:column;gap:1rem;">';
            
            for (let i = 1; i <= 3; i++) {
                const slot = slots[`slot${i}`];
                const slotDate = slot ? new Date(slot.savedAt).toLocaleString() : '';
                const currentCharName = stats.characterName || 'Unnamed Hero';
                
                html += `<button onclick="quickSaveAndFight(${i}, '${name}', '${type}')" style="padding:1rem;background:#334155;border-radius:8px;text-align:left;cursor:pointer;border:2px solid #475569;transition:all 0.2s;color:white;" onmouseover="this.style.background='#475569'" onmouseout="this.style.background='#334155'">`;
                html += `<div style="font-weight:bold;font-size:1.1rem;">Slot ${i}</div>`;
                if (slot) {
                    html += `<div style="font-size:0.9rem;color:#fbbf24;">${slot.name}</div>`;
                    html += `<div style="font-size:0.8rem;color:#94a3b8;">${slotDate}</div>`;
                } else {
                    html += `<div style="font-size:0.9rem;color:#64748b;">Empty</div>`;
                }
                html += `<div style="font-size:0.75rem;color:#3b82f6;margin-top:0.25rem;">Will save: ${currentCharName}</div>`;
                html += '</button>';
            }
            
            html += '</div>';
            html += `<button onclick="cancelQuickSave('${name}', '${type}')" style="margin-top:1.5rem;width:100%;padding:0.75rem;background:#64748b;border-radius:8px;font-weight:bold;color:white;">SKIP & FIGHT</button>`;
            html += '</div>';
            
            modal.innerHTML = html;
            modal.id = 'quick-save-modal';
            document.body.appendChild(modal);
        }

        async function quickSaveAndFight(slotNumber, name, type) {
            const saveName = stats.characterName || `Save ${slotNumber}`;
            const success = await saveToCloud(slotNumber, saveName);
            if (success) {
                addLog(`Game saved to Slot ${slotNumber}!`, 'text-green-400');
            } else {
                addLog(`Failed to save to Slot ${slotNumber}.`, 'text-red-400');
            }
            closeQuickSaveModal();
            startCombat(name, type);
        }

        function cancelQuickSave(name, type) {
            closeQuickSaveModal();
            startCombat(name, type);
        }

        function proceedToCombat(name, type) {
            closePreCombatModal();
            startCombat(name, type);
        }

        function closePreCombatModal() {
            const modal = document.getElementById('pre-combat-modal');
            if (modal) modal.remove();
        }

        function closeQuickSaveModal() {
            const modal = document.getElementById('quick-save-modal');
            if (modal) modal.remove();
        }

        async function startCombat(name, type) {
            let mStats = {};
            
            // Special handling for Lich King
            if (type === 'lichking') {
                mStats = monsterData['lichking'];
            } else {
                // Check if this is a pre-generated monster from the map
                const monsterKey = `${currentRoom[0]},${currentRoom[1]},${stats.floor}`;
                if (monsterData[monsterKey]) {
                    // Use pre-generated stats
                    mStats = {...monsterData[monsterKey]};
                } else {
                    // Generate new stats for random wandering monsters
                    mStats = generateMonsterStats(type);
                }
            }

            // Prefer the stored name (for pre-generated monsters). If missing, use the passed name or generate one.
            const combatName = mStats.name || name || (type ? generateMonsterName(type) : 'Monster');

            combatData = { ...mStats, name: combatName, type, maxHP: mStats.maxHP || mStats.HP, turn: 'init' };
            showView('view-combat');

            // Show type indicator for bosses/mini-bosses/lich king
            let typeLabel = '';
            if (type === 'lichking') typeLabel = ' üëë FINAL BOSS üëë';
            else if (type === 'boss') typeLabel = ' (BOSS)';
            else if (type === 'mini') typeLabel = ' (MINI-BOSS)';
            
            document.getElementById('monster-name').innerText = `${combatName}${typeLabel}`;
            document.getElementById('monster-stats-display').innerText = `Dexterity: ${mStats.dexterity}`;
            updateCombatUI();
            addLog(`Encountered ${combatName}${typeLabel}!`, type === 'lichking' ? "text-red-600 font-black text-lg" : "text-red-500 font-bold uppercase");
            
            isProcessing = true;
            await logLoading("Rolling Initiative", 3, 100);
            if (Math.random() < 0.5) {
                addLog("You act first!", "text-blue-400");
                combatData.turn = 'player';
                showCombatSubMenu('main');
                isProcessing = false;
            } else {
                addLog(`${combatName} acts first!`, "text-red-400");
                combatData.turn = 'monster';
                isProcessing = false;
                monsterTurnStart();
            }
            updateCombatUI();
        }

        function retreat() {
            if(isProcessing) return;
            showRetreatDirectionModal();
        }

        function showRetreatDirectionModal() {
            const modal = document.createElement('div');
            modal.id = 'retreat-direction-modal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.9); z-index: 9999;
                display: flex; align-items: center; justify-content: center;
            `;
            
            // Check which directions are valid
            const canGoNorth = currentRoom[0] > 0;
            const canGoSouth = currentRoom[0] < 9;
            const canGoWest = currentRoom[1] > 0;
            const canGoEast = currentRoom[1] < 9;
            
            let buttonsHtml = '<div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; max-width: 300px;">';
            
            // Top row
            buttonsHtml += '<div></div>';
            if (canGoNorth) {
                buttonsHtml += `<button onclick="attemptRetreat(-1, 0)" class="px-6 py-4 bg-yellow-700 hover:bg-yellow-600 rounded text-lg font-bold">‚Üë<br>NORTH</button>`;
            } else {
                buttonsHtml += '<div></div>';
            }
            buttonsHtml += '<div></div>';
            
            // Middle row
            if (canGoWest) {
                buttonsHtml += `<button onclick="attemptRetreat(0, -1)" class="px-6 py-4 bg-yellow-700 hover:bg-yellow-600 rounded text-lg font-bold">‚Üê<br>WEST</button>`;
            } else {
                buttonsHtml += '<div></div>';
            }
            buttonsHtml += '<div style="display: flex; align-items: center; justify-content: center; color: #94a3b8; font-size: 24px;">‚öîÔ∏è</div>';
            if (canGoEast) {
                buttonsHtml += `<button onclick="attemptRetreat(0, 1)" class="px-6 py-4 bg-yellow-700 hover:bg-yellow-600 rounded text-lg font-bold">‚Üí<br>EAST</button>`;
            } else {
                buttonsHtml += '<div></div>';
            }
            
            // Bottom row
            buttonsHtml += '<div></div>';
            if (canGoSouth) {
                buttonsHtml += `<button onclick="attemptRetreat(1, 0)" class="px-6 py-4 bg-yellow-700 hover:bg-yellow-600 rounded text-lg font-bold">‚Üì<br>SOUTH</button>`;
            } else {
                buttonsHtml += '<div></div>';
            }
            buttonsHtml += '<div></div>';
            
            buttonsHtml += '</div>';
            
            modal.innerHTML = `
                <div style="background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%); 
                    border: 3px solid #eab308; border-radius: 12px; padding: 32px; 
                    max-width: 450px; width: 90%; box-shadow: 0 20px 60px rgba(234, 179, 8, 0.4);">
                    <h2 style="font-size: 24px; font-weight: bold; color: #eab308; 
                        text-align: center; margin-bottom: 8px; text-transform: uppercase;">
                        Choose Retreat Direction
                    </h2>
                    <p style="text-align: center; color: #cbd5e1; margin-bottom: 24px; font-size: 14px;">
                        Select which adjacent room to flee to
                    </p>
                    ${buttonsHtml}
                    <button onclick="closeRetreatModal()" 
                        style="width: 100%; margin-top: 16px; padding: 12px; background: #64748b; 
                        border-radius: 8px; font-weight: bold; color: white; cursor: pointer; border: none;">
                        CANCEL
                    </button>
                </div>
            `;
            
            document.body.appendChild(modal);
        }

        async function attemptRetreat(dr, dc) {
            closeRetreatModal();
            
            if(isProcessing) return;
            isProcessing = true;
            
            await logLoading("Attempting Retreat", 3, 200);
            const baseRoll = Math.floor(Math.random()*20)+1;
            const mod = Math.floor((stats.dexterity + stats.temporary_dexterity)/2)-5;
            const roll = baseRoll + mod;
            stats.temporary_dexterity = 0;
            addLog(`Dex Roll: ${baseRoll} + ${mod} = ${roll} vs ${combatData.dexterity}`, "text-yellow-400");
            
            if (roll >= combatData.dexterity) {
                addLog("Retreat Successful!", "text-green-500 font-bold");
                
                // Move to the chosen adjacent room
                currentRoom[0] += dr;
                currentRoom[1] += dc;
                
                showView('view-dungeon');
                renderDungeon();
                checkRoom(true);
            } else {
                addLog("Retreat Failed!", "text-red-500 font-bold");
                await sleep(500);
                combatData.turn = 'monster';
                monsterTurnStart();
            }
            isProcessing = false;
        }

        function closeRetreatModal() {
            const modal = document.getElementById('retreat-direction-modal');
            if (modal) modal.remove();
        }

        function showCombatSubMenu(menu) {
            document.getElementById('combat-main-menu').classList.toggle('hidden', menu !== 'main');
            document.getElementById('combat-direction-menu').classList.toggle('hidden', menu !== 'attack');
            document.getElementById('combat-items-menu').classList.toggle('hidden', menu !== 'items');
            document.getElementById('combat-defense-menu').classList.toggle('hidden', menu !== 'defense');
            if (menu === 'items') renderCombatInventory();
        }

        function updateCombatUI() {
            const p = Math.max(0, (combatData.HP / combatData.maxHP) * 100);
            document.getElementById('monster-hp-bar').style.width = `${p}%`;
            document.getElementById('turn-indicator').innerText = combatData.turn.toUpperCase() + ' TURN';
        }

        async function combatAction(dir) {
            if (isProcessing) return;
            isProcessing = true;
            
            // Check if player is stunned
            if (stats.stunned) {
                addLog("You are stunned and cannot act!", "text-red-500 font-bold");
                stats.stunned = false;
                await sleep(800);
                if(combatData.HP > 0) {
                    combatData.turn = 'player';
                    isProcessing = false;
                    updateCombatUI();
                    showCombatSubMenu('main');
                }
                return;
            }
            
            showCombatSubMenu('none');
            await logLoading("Rolling Hit", 3, 100);
            const baseRoll = Math.floor(Math.random()*20)+1;
            const mod = Math.floor((stats.strength + stats.temporary_strength)/2)-5;
            const roll = baseRoll + mod;
            stats.temporary_strength = 0;
            addLog(`Str Roll: ${baseRoll} + ${mod} = ${roll} vs AC ${combatData.armor}`);
            if (roll >= combatData.armor) {
                addLog("HIT!", "text-green-400 font-bold");
                await logLoading("Damage", 3, 100);
                const tier = stats.weapons[stats.equippedWeapon] || 1;
                let dmg = 0;
                if(tier===1) dmg = Math.floor(Math.random()*3)+1;  // 1d3: 1-3
                else if(tier===2) dmg = Math.floor(Math.random()*6)+1;  // 1d6: 1-6
                else if(tier===3) dmg = Math.floor(Math.random()*10)+1;  // 1d10: 1-10
                else if(tier===4) dmg = Math.floor(Math.random()*6)+1+Math.floor(Math.random()*6)+1+2;  // 2d6+2: 4-14
                else if(tier===5) dmg = Math.floor(Math.random()*6)+1+Math.floor(Math.random()*6)+1+Math.floor(Math.random()*6)+1+3;  // 3d6+3: 6-21
                else if(tier===6) dmg = Math.floor(Math.random()*6)+1+Math.floor(Math.random()*6)+1+Math.floor(Math.random()*6)+1+Math.floor(Math.random()*6)+1+4;  // 4d6+4: 8-28
                else dmg = Math.floor(Math.random()*6)+1;  // Fallback to 1d6
                const mDir = Math.floor(Math.random()*3)+1;
                if(mDir === dir) {
                    dmg = Math.floor(dmg/2);
                    addLog(`Monster Blocked! Half damage (${dmg})`, "text-slate-400");
                } else addLog(`Dealt ${dmg} damage!`, "text-green-400");
                combatData.HP -= dmg;
                if(combatData.HP <= 0) { await victory(); return; }
            } else addLog("MISS!", "text-red-400");
            updateCombatUI();
            await sleep(500);
            if(combatData.HP > 0) {
                combatData.turn = 'monster';
                isProcessing = false;
                monsterTurnStart();
            }
        }

        async function monsterTurnStart() {
            if(combatData.freeze > 0) {
                combatData.freeze--;
                addLog("Monster is Frozen!", "text-cyan-400");
                await sleep(800);
                combatData.turn = 'player';
                updateCombatUI();
                showCombatSubMenu('main');
                return;
            }
            if(combatData.fire) {
                combatData.HP -= 2;
                addLog("Monster took 2 fire damage.", "text-orange-400");
                if(combatData.HP <= 0) { await victory(); return; }
            }
            
            // Check if boss should use an ability
            const hpPercent = combatData.HP / combatData.maxHP;
            const isBoss = combatData.type === 'boss' || combatData.type === 'mini' || combatData.type === 'lichking';
            const useAbility = isBoss && bossShouldUseAbility(combatData.type, hpPercent);
            
            if (useAbility) {
                const availableAbilities = getAvailableAbilities(combatData.type);
                if (availableAbilities.length > 0) {
                    const abilityKey = availableAbilities[Math.floor(Math.random() * availableAbilities.length)];
                    const ability = BOSS_ABILITIES[abilityKey];
                    
                    if (ability) {
                        addLog(`${combatData.name} uses ${ability.name}!`, "text-red-500 font-bold text-lg");
                        const result = await ability.effect();
                        
                        if (result === false) return; // Effect caused death
                        
                        await sleep(600);
                        combatData.turn = 'player';
                        updateCombatUI();
                        showCombatSubMenu('main');
                        return;
                    }
                }
            }
            
            showCombatSubMenu('defense');
        }

        async function resolveMonsterTurn(defDir) {
            if (isProcessing) return;
            isProcessing = true;
            showCombatSubMenu('none');
            await logLoading("Monster Attacking", 3, 100);
            if(combatData.change_strength) {
                combatData.strength += 2;
                combatData.change_strength = false;
                addLog("Monster strength increased!", "text-red-500");
            }
            const roll = Math.floor(Math.random()*20)+1 + combatData.strength;
            const ac = stats.armor + stats.temporary_armor;
            addLog(`Monster Roll: ${roll} vs AC ${ac}`);
            if (roll >= ac) {
                addLog("YOU WERE HIT!", "text-red-600 font-bold");
                let dmg = 0;
                const tier = combatData.attack;
                if(tier<=1) dmg = Math.floor(Math.random()*3)+1;
                else if(tier===2) dmg = Math.floor(Math.random()*6)+1;
                else if(tier===3) dmg = Math.floor(Math.random()*10)+1;
                else if(tier===4) dmg = Math.floor(Math.random()*6)*2+2;
                else if(tier===5) dmg = Math.floor(Math.random()*6)*3+3;
                else dmg = Math.floor(Math.random()*6)*4+4;
                
                // Apply freeze field damage reduction
                if (stats.frozen_field && stats.frozen_field > 0) {
                    dmg = Math.floor(dmg * 0.7); // 30% damage reduction
                    addLog("Freeze field reduces damage!", "text-cyan-400");
                    stats.frozen_field--;
                    if (stats.frozen_field === 0) {
                        addLog("Freeze field dissipates.", "text-cyan-300");
                    }
                }
                
                const atkDir = Math.floor(Math.random()*3)+1;
                if(atkDir === defDir) {
                    dmg = Math.floor(dmg/2);
                    addLog(`Blocked! Half damage (${dmg})`, "text-blue-400");
                } else addLog(`Took ${dmg} damage!`, "text-red-500");
                stats.HP -= dmg;
                updateUI();
                if(stats.HP <= 0) {
                    handleDeath();
                    return;
                }
            } else addLog("Monster Missed!", "text-green-400");
            stats.temporary_armor = 0;
            await sleep(500);
            combatData.turn = 'player';
            isProcessing = false;
            updateCombatUI();
            showCombatSubMenu('main');
        }

        async function handleDeath() {
            addLog("YOU DIED.", "text-red-900 font-black text-2xl");
            isProcessing = true;
            stats.combatWinStreak = 0; // Reset combat streak on death
            
            await sleep(1500);
            
            // Wisdom test difficulty increases with each death
            // Base DC is 10, +2 for each previous death
            const baseDC = 10;
            const deathPenalty = stats.deathCount * 2;
            const targetDC = baseDC + deathPenalty;
            
            addLog("Your spirit lingers between life and death...", "text-purple-400 italic");
            await sleep(1000);
            addLog("Make a Wisdom saving throw to return to the living!", "text-yellow-400 font-bold");
            await logLoading("Rolling", 3, 300);
            
            const roll = Math.floor(Math.random()*20)+1;
            const wisdomMod = Math.floor(stats.wisdom / 2) - 5;
            const total = roll + wisdomMod;
            
            addLog(`Rolled ${roll} + ${wisdomMod} (Wisdom) = ${total}`, "text-slate-300");
            addLog(`Need ${targetDC} or higher to revive`, "text-slate-400");
            
            await sleep(1500);
            
            if (total >= targetDC) {
                // SUCCESS - Revive with 2/3 health in town
                addLog("SUCCESS! Your spirit returns!", "text-green-400 font-black text-xl");
                stats.deathCount++;
                stats.HP = Math.floor(stats.maxHP * 2 / 3);
                
                await sleep(1000);
                addLog(`You awaken in Oakhaven with ${stats.HP} HP...`, "text-blue-400");
                addLog(`Death has left its mark. (Deaths: ${stats.deathCount})`, "text-red-400");
                
                // Return to town
                showView('view-town');
                updateUI();
                isProcessing = false;
            } else {
                // FAILURE - Permanent death
                addLog("FAILED... Your spirit fades into darkness.", "text-red-900 font-black text-xl");
                await sleep(2000);
                addLog("Game Over. Reloading...", "text-slate-500");
                await sleep(2000);
                location.reload();
            }
        }

        function calculateMonsterExp(monster) {
            // Base EXP by type
            let baseExp = 0;
            if (monster.type === 'wandering') baseExp = 20;
            else if (monster.type === 'normal') baseExp = 50;
            else if (monster.type === 'mini') baseExp = 150;
            else if (monster.type === 'boss' || monster.type === 'lichking') baseExp = 400;
            
            // Add bonus EXP based on monster stats (difficulty modifiers)
            const hpBonus = Math.floor((monster.maxHP || monster.maxHp || 0) / 10);  // 1 EXP per 10 HP
            const armorBonus = Math.max(0, (monster.armor - 10) * 3);  // 3 EXP per AC above 10
            const attackBonus = monster.attack * 5;  // 5 EXP per attack tier
            const strBonus = Math.max(0, monster.strength) * 4;  // 4 EXP per positive strength
            const dexBonus = Math.max(0, (monster.dexterity - 10) * 2);  // 2 EXP per dex above 10
            
            const totalExp = baseExp + hpBonus + armorBonus + attackBonus + strBonus + dexBonus;
            return Math.floor(totalExp);
        }

        async function victory() {
            // CHECK FOR GAME WIN CONDITION
            if (combatData.type === 'lichking') {
                addLog("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê", "text-yellow-400 font-bold");
                addLog("VICTORY! THE GOBLIN KING IS DEFEATED!", "text-yellow-400 font-black text-2xl");
                addLog("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê", "text-yellow-400 font-bold");
                await sleep(1000);
                addLog("The darkness that plagued Oakhaven has been vanquished.", "text-green-400 font-bold");
                addLog("You are a true hero! The realm is saved!", "text-green-400 font-bold");
                await sleep(2000);
                
                // Award massive rewards for winning
                const winCoins = 1000;
                const winExp = 5000;
                stats.coins += winCoins;
                stats.exp += winExp;
                stats.totalExp += winExp;
                stats.bossesDefeated++;
                stats.keys++;
                addLog(`Looted ${winCoins} legendary gold!`, "text-yellow-400 font-bold");
                addLog(`Gained ${winExp} EXP!`, "text-cyan-400 font-bold");
                
                // Save and show win screen
                updateUI();
                await saveGame();
                
                // Show game won modal
                const modal = document.createElement('div');
                modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.95);display:flex;align-items:center;justify-content:center;z-index:10000;';
                modal.innerHTML = `
                    <div style="background:linear-gradient(135deg, #1e293b 0%, #0f172a 100%);padding:3rem;border-radius:15px;max-width:500px;width:90%;border:3px solid #fbbf24;text-align:center;">
                        <div style="font-size:3rem;margin-bottom:1rem;">üëë</div>
                        <h2 style="font-size:2rem;font-weight:bold;color:#fbbf24;margin-bottom:1rem;">GAME WON!</h2>
                        <p style="color:#e2e8f0;font-size:1.1rem;margin-bottom:2rem;line-height:1.6;">
                            You have defeated the Goblin King and saved Oakhaven from darkness.
                            <br><br>
                            Final Stats:
                            <br>Level: ${stats.level}
                            <br>Gold: ${stats.coins}
                            <br>Total EXP: ${stats.totalExp}
                        </p>
                        <button onclick="location.reload()" style="padding:0.75rem 2rem;background:#fbbf24;color:#1e293b;border:none;border-radius:8px;font-weight:bold;font-size:1rem;cursor:pointer;">
                            NEW GAME
                        </button>
                    </div>
                `;
                document.body.appendChild(modal);
                return;
            }
            
            addLog("VICTORY!", "text-yellow-400 font-black text-xl");
            
            // Better rewards based on monster type
            let coins = 0;
            if (combatData.type === 'wandering') {
                coins = Math.floor(Math.random()*21)+5;  // 5-25 gold
            } else if (combatData.type === 'normal') {
                coins = Math.floor(Math.random()*51)+25;  // 25-75 gold
            } else if (combatData.type === 'mini') {
                coins = Math.floor(Math.random()*101)+100;  // 100-200 gold
            } else if (combatData.type === 'boss') {
                coins = Math.floor(Math.random()*301)+200;  // 200-500 gold
            }
            
            stats.coins += coins;
            addLog(`Looted ${coins} coins.`, "text-yellow-500");
            
            // Award EXP
            const expGained = calculateMonsterExp(combatData);
            stats.exp += expGained;
            stats.totalExp += expGained;
            addLog(`Gained ${expGained} EXP! (${stats.totalExp}/${stats.expToNextLevel})`, "text-cyan-400");
            
            // Check for level up
            if (stats.exp >= stats.expToNextLevel) {
                await sleep(500);
                await levelUp();
            }
            
            // Remove monster from room
            let removeVal = 0;
            if(combatData.type.includes('boss')) removeVal = 1000000;
            else if(combatData.type.includes('mini')) removeVal = 100000;
            else if(combatData.type.includes('wandering')) removeVal = 1000;
            else removeVal = 100;
            const floorKey = `floor_${stats.floor}`;
            floorMaps[floorKey][currentRoom[0]][currentRoom[1]] -= removeVal;
            
            // Track kills and special defeats
            stats.kills++;
            if(combatData.type === 'mini') stats.miniBossesDefeated++;
            if(combatData.type === 'boss') {
                stats.bossesDefeated++;
                stats.keys++;
                addLog("Found a Key!", "text-blue-400 font-bold");
            }
            
            // Mini-boss has chance to drop extra gold
            if(combatData.type === 'mini' && Math.random() < 0.5) {
                const bonus = Math.floor(Math.random()*51)+50;  // 50-100 extra
                stats.coins += bonus;
                addLog(`Found a hidden stash! +${bonus} gold!`, "text-yellow-400 font-bold");
            }
            
            await sleep(1000);
            isProcessing = false;
            updateUI();
            showView('view-dungeon');
            renderDungeon();
            checkRoom(false);
            
            // Update combat streak and check achievements
            stats.lastCombatWon = true;
            stats.combatWinStreak++;
            checkAchievements();
        }

        function checkAchievements() {
            // Easy Achievements
            if (stats.totalExp >= 10 && !stats.achievements.first_kill) unlockAchievement('first_kill');
            if (stats.openedChests.size > 0 && !stats.achievements.open_chest) unlockAchievement('open_chest');
            if (stats.kills >= 10 && !stats.achievements.kill_10) unlockAchievement('kill_10');
            if (stats.coins >= 100 && !stats.achievements.loot_100) unlockAchievement('loot_100');
            if ((stats.equippedWeapon !== 'stick' || stats.equippedArmor !== 'none') && !stats.achievements.equip_item) unlockAchievement('equip_item');
            if (stats.spellsCast >= 1 && !stats.achievements.cast_spell) unlockAchievement('cast_spell');
            
            // Medium Achievements
            if (stats.level >= 5 && !stats.achievements.level_5) unlockAchievement('level_5');
            if (stats.kills >= 50 && !stats.achievements.kill_50) unlockAchievement('kill_50');
            if (stats.coins >= 1000 && !stats.achievements.loot_1000) unlockAchievement('loot_1000');
            if (stats.floor >= 5 && !stats.achievements.floor_5) unlockAchievement('floor_5');
            if (stats.miniBossesDefeated >= 1 && !stats.achievements.defeat_mini) unlockAchievement('defeat_mini');
            if (Object.keys(stats.spells).length >= 3 && !stats.achievements.collect_3_spells) unlockAchievement('collect_3_spells');
            if (stats.combatWinStreak >= 5 && !stats.achievements.combat_streak) unlockAchievement('combat_streak');
            if (stats.level >= 10 && !stats.achievements.level_10) unlockAchievement('level_10');
            if (Object.keys(stats.spells).length >= 5 && !stats.achievements.librarian) unlockAchievement('librarian');
            
            // Hard Achievements
            if (stats.bossesDefeated >= 1 && !stats.achievements.boss_killer) unlockAchievement('boss_killer');
            if (stats.coins >= 5000 && !stats.achievements.hoarder) unlockAchievement('hoarder');
            if (stats.floor >= 10 && !stats.achievements.floor_10) unlockAchievement('floor_10');
            if (stats.level >= 15 && !stats.achievements.level_15) unlockAchievement('level_15');
            if (stats.kills >= 200 && !stats.achievements.kill_200) unlockAchievement('kill_200');
            if (stats.coins >= 10000 && !stats.achievements.wealthy) unlockAchievement('wealthy');
            if (stats.bossesDefeated >= 3 && !stats.achievements.defeat_3_bosses) unlockAchievement('defeat_3_bosses');
            if (stats.combatWinStreak >= 8 && !stats.achievements.combat_streak_8) unlockAchievement('combat_streak_8');
            if (stats.floor >= 15 && !stats.achievements.floor_15) unlockAchievement('floor_15');
            if (stats.coins >= 50000 && !stats.achievements.golden_touch) unlockAchievement('golden_touch');
            if (stats.level >= 20 && !stats.achievements.level_20) unlockAchievement('level_20');
            if (stats.floor >= 25 && !stats.achievements.floor_master) unlockAchievement('floor_master');
            if (stats.kills >= 500 && !stats.achievements.defeat_50_monsters) unlockAchievement('defeat_50_monsters');
        }

        function unlockAchievement(achievementKey) {
            if (!stats.achievements[achievementKey]) {
                const achievement = ACHIEVEMENTS[achievementKey];
                stats.achievements[achievementKey] = true;
                stats.coins += achievement.reward;
                addLog(`üèÜ ACHIEVEMENT UNLOCKED: ${achievement.name}!`, "text-yellow-400 font-bold");
                addLog(`+${achievement.reward} gold reward`, "text-yellow-500");
                updateUI();
            }
        }

        async function levelUp() {
            stats.level++;
            // Calculate EXP needed for next level based on formula: 50 * level * (level + 1)
            const nextLevelExp = 50 * stats.level * (stats.level + 1);
            stats.exp = 0;  // Reset progress for current level
            stats.expToNextLevel = nextLevelExp;
            
            addLog(`LEVEL UP! You are now level ${stats.level}!`, "text-purple-400 font-black text-xl");
            await sleep(1000);
            
            // Increase max HP with scaling dice rolls
            let hpGain = 0;
            let diceType = '';
            if (stats.level <= 3) {
                // Levels 1-3: 1d4 (1-4 HP)
                hpGain = Math.floor(Math.random()*4)+1;
                diceType = '1d4';
            } else if (stats.level <= 6) {
                // Levels 4-6: 1d6 (1-6 HP)
                hpGain = Math.floor(Math.random()*6)+1;
                diceType = '1d6';
            } else if (stats.level <= 9) {
                // Levels 7-9: 1d8 (1-8 HP)
                hpGain = Math.floor(Math.random()*8)+1;
                diceType = '1d8';
            } else if (stats.level <= 12) {
                // Levels 10-12: 1d10 (1-10 HP)
                hpGain = Math.floor(Math.random()*10)+1;
                diceType = '1d10';
            } else {
                // Levels 13+: 1d12 (1-12 HP)
                hpGain = Math.floor(Math.random()*12)+1;
                diceType = '1d12';
            }
            
            // Store HP gain data for later display
            const levelUpData = { hpGain, diceType, oldMaxHP: stats.maxHP };
            stats.maxHP += hpGain;
            stats.HP = stats.maxHP;  // Full heal on level up
            updateUI();
            
            // Calculate number of stat increases based on level
            // Level 1-3: 1 increase, Level 4-6: 2 increases, Level 7-9: 3 increases, etc.
            const numIncreases = Math.floor((stats.level - 1) / 3) + 1;
            
            await sleep(500);
            showStatIncreaseModal(1, numIncreases, levelUpData);  // Start with first increase
        }

        function showStatIncreaseModal(increaseNumber, totalIncreases, levelUpData) {
            const modal = document.createElement('div');
            modal.id = 'stat-increase-modal';
            modal.setAttribute('data-levelup', JSON.stringify(levelUpData));
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.85); z-index: 9999;
                display: flex; align-items: center; justify-content: center;
                backdrop-filter: blur(4px);
            `;
            
            const statNames = [
                { key: 'strength', label: 'STRENGTH', desc: 'Melee damage' },
                { key: 'dexterity', label: 'DEXTERITY', desc: 'Hit chance & defense' },
                { key: 'intelligence', label: 'INTELLIGENCE', desc: 'Spell power & chests' },
                { key: 'wisdom', label: 'WISDOM', desc: 'Spell defense & death saves' }
            ];
            
            let buttonsHtml = '';
            statNames.forEach(stat => {
                const currentValue = stats[stat.key];
                buttonsHtml += `
                    <button onclick="increaseStat('${stat.key}', ${increaseNumber}, ${totalIncreases})" 
                        class="w-full bg-purple-800 hover:bg-purple-700 text-white px-6 py-4 rounded text-lg font-bold transition-colors border-2 border-purple-600">
                        <div class="flex justify-between items-center">
                            <div class="text-left">
                                <div>${stat.label}</div>
                                <div class="text-sm text-purple-300 font-normal">${stat.desc}</div>
                            </div>
                            <div class="text-2xl">${currentValue} ‚Üí ${currentValue + 1}</div>
                        </div>
                    </button>
                `;
            });
            
            modal.innerHTML = `
                <div style="background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%); 
                    border: 3px solid #a855f7; border-radius: 12px; padding: 32px; 
                    max-width: 500px; width: 90%; box-shadow: 0 20px 60px rgba(168, 85, 247, 0.4);">
                    <h2 style="font-size: 28px; font-weight: bold; color: #a855f7; 
                        text-align: center; margin-bottom: 8px; text-transform: uppercase;">
                        üéâ Level Up! üéâ
                    </h2>
                    <p style="text-align: center; color: #cbd5e1; margin-bottom: 24px; font-size: 16px;">
                        Choose a stat to increase by 1 (${increaseNumber}/${totalIncreases}):
                    </p>
                    <div style="display: flex; flex-direction: column; gap: 12px;">
                        ${buttonsHtml}
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }

        async function increaseStat(statName, increaseNumber, totalIncreases) {
            stats[statName]++;
            addLog(`${statName.toUpperCase()} increased to ${stats[statName]}!`, "text-purple-400 font-bold");
            
            const modal = document.getElementById('stat-increase-modal');
            const levelUpData = JSON.parse(modal.getAttribute('data-levelup'));
            
            closeStatIncreaseModal();
            updateUI();
            
            // If there are more increases remaining, show modal for next increase
            if (increaseNumber < totalIncreases) {
                await sleep(500);
                showStatIncreaseModal(increaseNumber + 1, totalIncreases, levelUpData);
            } else {
                // All stat increases complete - show HP completion modal
                await sleep(500);
                showHPCompletionModal(levelUpData);
            }
        }

        function showHPCompletionModal(levelUpData) {
            const modal = document.createElement('div');
            modal.id = 'hp-completion-modal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.85); z-index: 9999;
                display: flex; align-items: center; justify-content: center;
                backdrop-filter: blur(4px);
            `;
            
            modal.innerHTML = `
                <div style="background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%); 
                    border: 3px solid #10b981; border-radius: 12px; padding: 32px; 
                    max-width: 500px; width: 90%; box-shadow: 0 20px 60px rgba(16, 185, 129, 0.4);">
                    <h2 style="font-size: 28px; font-weight: bold; color: #10b981; 
                        text-align: center; margin-bottom: 16px; text-transform: uppercase;">
                        ‚ù§Ô∏è Health Boost! ‚ù§Ô∏è
                    </h2>
                    <div style="background: #0f172a; padding: 20px; border-radius: 8px; margin-bottom: 24px; border: 2px solid #334155;">
                        <div style="text-align: center; color: #cbd5e1; font-size: 16px; margin-bottom: 12px;">
                            Max HP Increased!
                        </div>
                        <div style="text-align: center; font-size: 32px; font-weight: bold; color: #10b981; margin-bottom: 12px;">
                            ${levelUpData.oldMaxHP} ‚Üí ${stats.maxHP}
                        </div>
                        <div style="text-align: center; color: #94a3b8; font-size: 14px;">
                            Rolled ${levelUpData.diceType}: +${levelUpData.hpGain} HP
                        </div>
                    </div>
                    <div style="background: #059669; padding: 16px; border-radius: 8px; margin-bottom: 24px;">
                        <div style="text-align: center; color: white; font-size: 18px; font-weight: bold;">
                            ‚ú® Restored to Full Health! ‚ú®
                        </div>
                        <div style="text-align: center; color: #d1fae5; font-size: 16px; margin-top: 8px;">
                            HP: ${stats.HP}/${stats.maxHP}
                        </div>
                    </div>
                    <button onclick="closeHPCompletionModal()" 
                        style="width: 100%; padding: 16px; background: #10b981; border-radius: 8px; 
                        font-weight: bold; color: white; font-size: 18px; cursor: pointer; border: none;
                        transition: background 0.2s;">
                        CONTINUE
                    </button>
                </div>
            `;
            
            document.body.appendChild(modal);
        }

        function closeHPCompletionModal() {
            const modal = document.getElementById('hp-completion-modal');
            if (modal) modal.remove();
        }

        function closeStatIncreaseModal() {
            const modal = document.getElementById('stat-increase-modal');
            if (modal) modal.remove();
        }

        // --- SHOP & SELLING ---
        function setShopMode(mode) {
            shopMode = mode;
            document.getElementById('shop-mode-buy').className = `text-sm ${mode==='buy'?'bg-yellow-600':'bg-slate-800'} px-4 py-2 rounded font-bold`;
            document.getElementById('shop-mode-sell').className = `text-sm ${mode==='sell'?'bg-yellow-600':'bg-slate-800'} px-4 py-2 rounded font-bold`;
            renderShop();
        }

        function showShop() {
            shopMode = "buy";
            setShopMode('buy');
            showView('view-shop');
        }

        function renderShop() {
            const container = document.getElementById('shop-categories');
            container.innerHTML = '';
            
            if (shopMode === 'buy') {
                const types = {1:"Weapons", 2:"Armor", 3:"Potions", 4:"Spells", 5:"Special Items", 6:"Tools"};
                for(let t=1; t<=6; t++) {
                    const sect = document.createElement('div');
                    sect.innerHTML = `<h3 class="text-sm font-bold text-slate-500 mb-3 uppercase tracking-widest border-b border-slate-800 pb-2">${types[t]}</h3>`;
                    const list = document.createElement('div');
                    list.className = "grid grid-cols-2 gap-2 mb-4";
                    for(const [name, data] of Object.entries(SHOP_DATA)) {
                        if(data[2] !== t) continue;
                        const row = document.createElement('div');
                        row.className = "flex flex-col p-2 bg-slate-800/40 rounded border border-slate-800";
                        
                        let itemInfo = `<span class="uppercase font-bold text-sm text-slate-300">${name}</span>`;
                        itemInfo += `<span class="text-yellow-600 text-sm font-bold block mt-1">${data[0]}G</span>`;
                        
                        row.innerHTML = itemInfo;
                        
                        // Add buttons container
                        const btnContainer = document.createElement('div');
                        btnContainer.className = "flex gap-2 mt-2";
                        
                        // View Stats button
                        const statsBtn = document.createElement('button');
                        statsBtn.className = "flex-1 px-2 py-2 bg-blue-700 hover:bg-blue-600 rounded text-xs font-bold text-white transition-colors";
                        statsBtn.innerText = "VIEW STATS";
                        statsBtn.onclick = () => showItemStats(name, data);
                        
                        // Buy button
                        const buyBtn = document.createElement('button');
                        buyBtn.className = "flex-1 px-2 py-2 bg-slate-700 hover:bg-yellow-700 rounded text-xs font-bold text-white transition-colors";
                        buyBtn.innerText = "BUY";
                        buyBtn.onclick = () => showPurchaseConfirmation(name, data);
                        
                        btnContainer.appendChild(statsBtn);
                        btnContainer.appendChild(buyBtn);
                        row.appendChild(btnContainer);
                        list.appendChild(row);
                    }
                    sect.appendChild(list);
                    container.appendChild(sect);
                }
            } else {
                // Sell Mode
                const sellList = document.createElement('div');
                sellList.className = "grid grid-cols-1 gap-2";
                
                const processCollection = (collection, label) => {
                    for(let name in collection) {
                        if(name === 'stick' || name === 'none') continue;
                        const itemInfo = SHOP_DATA[name];
                        if(!itemInfo) continue;
                        const sellPrice = Math.floor(itemInfo[0] / 2);
                        const count = Array.isArray(collection[name]) ? collection[name][0] : 1;
                        if (count <= 0) continue;

                        const row = document.createElement('div');
                        row.className = "flex justify-between items-center p-3 bg-slate-800/40 rounded border border-slate-700";
                        row.innerHTML = `
                            <div>
                                <span class="text-xs text-slate-500 uppercase font-bold">${label}</span>
                                <div class="text-base font-bold uppercase text-white">${name} ${count>1?'(x'+count+')':''}</div>
                            </div>
                            <button onclick="sellItem('${name}', '${label}')" class="bg-red-900/40 hover:bg-red-800 border border-red-500/30 px-5 py-2 rounded text-sm font-bold text-red-200">
                                SELL FOR ${sellPrice}G
                            </button>
                        `;
                        sellList.appendChild(row);
                    }
                }
                processCollection(stats.weapons, "Weapon");
                processCollection(stats.armors, "Armor");
                processCollection(stats.potions, "Potion");
                processCollection(stats.spells, "Spell");

                if (sellList.children.length === 0) {
                    sellList.innerHTML = `<div class="text-center text-slate-500 py-10 text-sm uppercase font-bold">Nothing to sell</div>`;
                }
                container.appendChild(sellList);
            }
        }

        function showItemStats(name, data) {
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.9);display:flex;align-items:center;justify-content:center;z-index:10000;';
            
            const itemType = data[2] === 1 ? 'Weapon' : data[2] === 2 ? 'Armor' : data[2] === 3 ? 'Potion' : data[2] === 4 ? 'Spell' : 'Special Item';
            
            let html = '<div style="background:#1e293b;padding:2rem;border-radius:10px;max-width:500px;width:90%;">';
            html += '<h2 style="font-size:1.5rem;font-weight:bold;margin-bottom:1rem;text-align:center;color:white;">ITEM DETAILS</h2>';
            html += '<div style="background:#0f172a;padding:1.5rem;border-radius:8px;margin-bottom:1rem;border:2px solid #334155;">';
            html += `<div style="font-size:1.2rem;font-weight:bold;color:#fbbf24;text-transform:uppercase;margin-bottom:0.5rem;text-align:center;">${name}</div>`;
            html += `<div style="font-size:0.9rem;color:#94a3b8;margin-bottom:1rem;text-align:center;">${itemType}</div>`;
            html += '<div style="border-top:1px solid #334155;padding-top:1rem;">';
            
            // Weapon stats
            if (data[2] === 1) {
                html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Tier: <span style="color:#fbbf24;font-weight:bold;">${data[1]}</span></div>`;
                html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Damage: <span style="color:#10b981;font-weight:bold;">${getWeaponDamageDesc(data[1])}</span></div>`;
                html += '<div style="font-size:0.85rem;color:#94a3b8;margin-top:1rem;font-style:italic;">Used for attacking enemies in combat. Higher tier weapons deal more damage.</div>';
            }
            // Armor stats
            else if (data[2] === 2) {
                html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Armor Class: <span style="color:#3b82f6;font-weight:bold;">${data[1]}</span></div>`;
                html += '<div style="font-size:0.85rem;color:#94a3b8;margin-top:1rem;font-style:italic;">Increases your AC (Armor Class). Higher AC makes you harder to hit in combat.</div>';
            }
            // Potion stats
            else if (data[2] === 3) {
                const potionEffects = {
                    1: {name: "Healing", effect: "Restores 1d4+1d4 HP (2-8 HP)", color: "#10b981"},
                    2: {name: "Intelligence", effect: "Grants +6 temporary Intelligence for one chest opening", color: "#3b82f6"},
                    3: {name: "Speed (Dexterity)", effect: "Grants +6 temporary Dexterity for one retreat attempt", color: "#8b5cf6"},
                    4: {name: "Strength", effect: "Grants +6 temporary Strength for one attack", color: "#ef4444"},
                    5: {name: "Protection", effect: "Grants +3 temporary Armor for one enemy attack", color: "#06b6d4"}
                };
                const effect = potionEffects[data[3]];
                html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Type: <span style="color:${effect.color};font-weight:bold;">${effect.name}</span></div>`;
                html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Effect: <span style="color:#fbbf24;font-weight:bold;">${effect.effect}</span></div>`;
                html += '<div style="font-size:0.85rem;color:#94a3b8;margin-top:1rem;font-style:italic;">Consumable item. Can be used in combat or from inventory (healing only).</div>';
            }
            // Spell stats
            else if (data[2] === 4) {
                const spellEffects = {
                    1: {name: "Magic Missile", effect: "1d8 damage, DC 10 Wisdom", color: "#8b5cf6"},
                    2: {name: "Weakness", effect: "1d8 damage + reduce enemy Str by 2, DC 11 Wisdom", color: "#6366f1"},
                    3: {name: "Lightning", effect: "2d6+1d10+3 damage, DC 12 Wisdom", color: "#eab308"},
                    4: {name: "Freeze", effect: "1d6 damage + freeze enemy for 2 turns, DC 10 Wisdom", color: "#06b6d4"},
                    5: {name: "Fireball", effect: "1d15+5 damage + 2 burn damage per turn, DC 11 Wisdom", color: "#f97316"},
                    6: {name: "Town Portal", effect: "Teleport back to town from dungeon", color: "#10b981"}
                };
                const effect = spellEffects[data[3]];
                html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Spell: <span style="color:${effect.color};font-weight:bold;">${effect.name}</span></div>`;
                html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Effect: <span style="color:#fbbf24;font-weight:bold;">${effect.effect}</span></div>`;
                html += '<div style="font-size:0.85rem;color:#94a3b8;margin-top:1rem;font-style:italic;">Consumable spell. Requires Wisdom check to cast successfully.</div>';
            }
            // Checkpoint special item
            else if (data[2] === 5) {
                html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Type: <span style="color:#06b6d4;font-weight:bold;">Teleportation Device</span></div>`;
                html += '<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Effect: <span style="color:#fbbf24;font-weight:bold;">Set a checkpoint and teleport to it anytime</span></div>';
                html += '<div style="font-size:0.85rem;color:#94a3b8;margin-top:1rem;font-style:italic;">Once purchased, you can place a checkpoint in any dungeon room and teleport back to it whenever you want. Perfect for exploring safely!</div>';
            }
            // Map tool item
            else if (data[2] === 6) {
                html += `<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Type: <span style="color:#10b981;font-weight:bold;">Dungeon Map</span></div>`;
                html += '<div style="font-size:0.95rem;color:#64748b;margin-bottom:0.5rem;">Effect: <span style="color:#fbbf24;font-weight:bold;">Reveals bosses, mini-bosses, and stairs on the map</span></div>';
                html += '<div style="font-size:0.85rem;color:#94a3b8;margin-top:1rem;font-style:italic;">Permanently reveals the locations of important rooms on your dungeon map. Bosses (üëë), mini-bosses (‚öî), and stairs (‚¨á) will be clearly marked!</div>';
            }
            
            html += '</div>';
            html += `<div style="font-size:1.1rem;font-weight:bold;color:#fbbf24;text-align:center;margin-top:1rem;padding-top:1rem;border-top:1px solid #334155;">Price: ${data[0]} Gold</div>`;
            html += '</div>';
            html += '<button onclick="closeItemStatsModal()" style="width:100%;padding:0.75rem;background:#64748b;border-radius:8px;font-weight:bold;color:white;font-size:0.95rem;cursor:pointer;border:none;">CLOSE</button>';
            html += '</div>';
            
            modal.innerHTML = html;
            modal.id = 'item-stats-modal';
            document.body.appendChild(modal);
        }

        function closeItemStatsModal() {
            const modal = document.getElementById('item-stats-modal');
            if (modal) modal.remove();
        }

        function showPurchaseConfirmation(name, data) {
            if(stats.coins < data[0]) {
                addLog("Not enough gold!", "text-red-500 font-bold");
                return;
            }

            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.9);display:flex;align-items:center;justify-content:center;z-index:10000;';
            
            const itemType = data[2] === 1 ? 'Weapon' : data[2] === 2 ? 'Armor' : data[2] === 3 ? 'Potion' : 'Spell';
            let itemDetails = '';
            if (data[2] === 1) {
                // Weapon - show tier and damage
                itemDetails = `Tier ${data[1]} - ${getWeaponDamageDesc(data[1])}`;
            } else if (data[2] === 2) {
                // Armor - show AC
                itemDetails = `AC ${data[1]}`;
            }
            
            let html = '<div style="background:#1e293b;padding:2rem;border-radius:10px;max-width:450px;width:90%;">';
            html += '<h2 style="font-size:1.3rem;font-weight:bold;margin-bottom:1rem;text-align:center;color:white;">CONFIRM PURCHASE</h2>';
            html += '<div style="background:#0f172a;padding:1.5rem;border-radius:8px;margin-bottom:1.5rem;border:2px solid #334155;">';
            html += `<div style="font-size:1.1rem;font-weight:bold;color:#fbbf24;text-transform:uppercase;margin-bottom:0.5rem;">${name}</div>`;
            html += `<div style="font-size:0.85rem;color:#94a3b8;margin-bottom:0.75rem;">${itemType}</div>`;
            if (itemDetails) {
                html += `<div style="font-size:0.9rem;color:#10b981;margin-bottom:0.75rem;font-weight:bold;">${itemDetails}</div>`;
            }
            html += `<div style="font-size:1.2rem;font-weight:bold;color:#fbbf24;">Cost: ${data[0]} Gold</div>`;
            html += `<div style="font-size:0.9rem;color:#64748b;margin-top:0.5rem;">You have: ${stats.coins} Gold</div>`;
            html += '</div>';
            html += '<div style="display:flex;gap:0.75rem;">';
            html += `<button onclick="confirmPurchase('${name}', ${JSON.stringify(data).replace(/"/g, '&quot;')})" style="flex:1;padding:0.75rem;background:#10b981;border-radius:8px;font-weight:bold;color:white;font-size:0.95rem;cursor:pointer;border:none;">BUY</button>`;
            html += '<button onclick="closePurchaseModal()" style="flex:1;padding:0.75rem;background:#64748b;border-radius:8px;font-weight:bold;color:white;font-size:0.95rem;cursor:pointer;border:none;">CANCEL</button>';
            html += '</div>';
            html += '</div>';
            
            modal.innerHTML = html;
            modal.id = 'purchase-modal';
            document.body.appendChild(modal);
        }

        function confirmPurchase(name, data) {
            closePurchaseModal();
            
            if(stats.coins >= data[0]) {
                stats.coins -= data[0];
                let itemType = '';
                
                if(data[2] === 1) {
                    stats.weapons[name] = data[1];
                    itemType = 'weapon';
                } else if(data[2] === 2) {
                    stats.armors[name] = data[1];
                    itemType = 'armor';
                } else if(data[2] === 3) {
                    if(!stats.potions[name]) stats.potions[name] = [0, data[3]];
                    stats.potions[name][0]++;
                    itemType = 'consumable';
                } else if(data[2] === 4) {
                    if(!stats.spells[name]) stats.spells[name] = [0, data[3]];
                    stats.spells[name][0]++;
                    itemType = 'consumable';
                } else if(data[2] === 5) {
                    // Special items (checkpoint)
                    if(name === 'checkpoint') {
                        stats.checkpointsPurchased++;
                        addLog(`Checkpoint purchased! You now have ${stats.checkpointsPurchased} checkpoint(s) available.`, "text-cyan-400 font-bold");
                        itemType = 'special';
                    }
                } else if(data[2] === 6) {
                    // Map item
                    if(name === 'map') {
                        stats.hasMap = true;
                        addLog(`Map purchased! Bosses, mini-bosses, and stairs are now visible on the dungeon map!`, "text-cyan-400 font-bold");
                        itemType = 'special';
                        renderDungeon(); // Refresh the dungeon view to show new markers
                    }
                }
                
                updateUI();
                addLog(`Purchased ${name}!`, "text-green-400");
                renderShop();
                
                // Ask if they want to equip it (only for weapons and armor)
                if(itemType === 'weapon' || itemType === 'armor') {
                    setTimeout(() => showEquipPrompt(name, itemType), 300);
                }
            } else {
                addLog("Not enough gold!", "text-red-500 font-bold");
            }
        }

        function showEquipPrompt(name, itemType) {
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.9);display:flex;align-items:center;justify-content:center;z-index:10000;';
            
            let html = '<div style="background:#1e293b;padding:2rem;border-radius:10px;max-width:400px;width:90%;">';
            html += '<h2 style="font-size:1.3rem;font-weight:bold;margin-bottom:1rem;text-align:center;color:white;">EQUIP ITEM?</h2>';
            html += '<div style="background:#0f172a;padding:1.5rem;border-radius:8px;margin-bottom:1rem;border:2px solid #334155;text-align:center;">';
            html += `<div style="font-size:1.1rem;font-weight:bold;color:#fbbf24;text-transform:uppercase;margin-bottom:0.5rem;">${name}</div>`;
            html += `<div style="font-size:0.9rem;color:#94a3b8;">Would you like to equip this ${itemType} now?</div>`;
            html += '</div>';
            html += `<div style="font-size:0.8rem;color:#64748b;text-align:center;margin-bottom:1.5rem;font-style:italic;">You can always change equipment in your inventory</div>`;
            html += '<div style="display:flex;gap:0.75rem;">';
            html += `<button onclick="equipNewItem('${name}', '${itemType}')" style="flex:1;padding:0.75rem;background:#3b82f6;border-radius:8px;font-weight:bold;color:white;font-size:0.95rem;cursor:pointer;border:none;">EQUIP NOW</button>`;
            html += '<button onclick="closeEquipModal()" style="flex:1;padding:0.75rem;background:#64748b;border-radius:8px;font-weight:bold;color:white;font-size:0.95rem;cursor:pointer;border:none;">LATER</button>';
            html += '</div>';
            html += '</div>';
            
            modal.innerHTML = html;
            modal.id = 'equip-modal';
            document.body.appendChild(modal);
        }

        function equipNewItem(name, itemType) {
            closeEquipModal();
            
            if(itemType === 'weapon') {
                stats.equippedWeapon = name;
                addLog(`Equipped ${name}!`, "text-blue-400");
            } else if(itemType === 'armor') {
                stats.equippedArmor = name;
                stats.armor = stats.armors[name];
                addLog(`Equipped ${name}!`, "text-blue-400");
            }
            
            updateUI();
        }

        function closePurchaseModal() {
            const modal = document.getElementById('purchase-modal');
            if (modal) modal.remove();
        }

        function closeEquipModal() {
            const modal = document.getElementById('equip-modal');
            if (modal) modal.remove();
        }

        function buyItem(name, data) {
            // Legacy function kept for compatibility
            showPurchaseConfirmation(name, data);
        }

        function sellItem(name, type) {
            const data = SHOP_DATA[name];
            const price = Math.floor(data[0] / 2);
            stats.coins += price;
            
            if (type === "Weapon") {
                if(stats.equippedWeapon === name) stats.equippedWeapon = "stick";
                delete stats.weapons[name];
            } else if (type === "Armor") {
                if(stats.equippedArmor === name) stats.equippedArmor = "none";
                delete stats.armors[name];
                stats.armor = Math.max(...Object.values(stats.armors));
            } else if (type === "Potion") {
                stats.potions[name][0]--;
                if(stats.potions[name][0] <= 0) delete stats.potions[name];
            } else if (type === "Spell") {
                stats.spells[name][0]--;
                if(stats.spells[name][0] <= 0) delete stats.spells[name];
            }
            
            updateUI();
            addLog(`Sold ${name} for ${price}G`, "text-yellow-500");
            renderShop();
        }

        // --- INVENTORY MANAGEMENT ---
        function renderInventory() {
            const wList = document.getElementById('inv-weapons');
            const aList = document.getElementById('inv-armors');
            const cList = document.getElementById('inv-consumables');
            const tList = document.getElementById('inv-tools');
            wList.innerHTML = ''; aList.innerHTML = ''; cList.innerHTML = ''; tList.innerHTML = '';

            for(let name in stats.weapons) {
                const b = document.createElement('button');
                const isEquipped = stats.equippedWeapon === name;
                const tier = stats.weapons[name];
                b.className = `w-full p-3 text-left border border-slate-700 rounded transition-all ${isEquipped?'equipped':'bg-slate-800/40 hover:bg-slate-700'}`;
                b.innerHTML = `
                    <div class="flex justify-between items-center">
                        <span class="text-base font-bold uppercase">${name}</span>
                        <span class="text-sm text-slate-500 font-bold">TIER ${tier}</span>
                    </div>
                    <div class="text-sm text-green-400 font-bold mt-1">${getWeaponDamageDesc(tier)}</div>
                    ${isEquipped ? '<div class="text-xs text-yellow-500 font-black mt-1 uppercase italic tracking-widest">EQUIPPED</div>' : ''}
                `;
                b.onclick = () => { stats.equippedWeapon = name; renderInventory(); addLog(`Equipped ${name}`); };
                wList.appendChild(b);
            }

            for(let name in stats.armors) {
                const b = document.createElement('button');
                const isEquipped = stats.equippedArmor === name;
                b.className = `w-full p-3 text-left border border-slate-700 rounded transition-all ${isEquipped?'equipped':'bg-slate-800/40 hover:bg-slate-700'}`;
                b.innerHTML = `
                    <div class="flex justify-between items-center">
                        <span class="text-base font-bold uppercase">${name}</span>
                        <span class="text-sm text-slate-500 font-bold">AC ${stats.armors[name]}</span>
                    </div>
                    ${isEquipped ? '<div class="text-xs text-yellow-500 font-black mt-1 uppercase italic tracking-widest">EQUIPPED</div>' : ''}
                `;
                b.onclick = () => { 
                    stats.equippedArmor = name; 
                    stats.armor = stats.armors[name];
                    renderInventory(); 
                    updateUI();
                    addLog(`Equipped ${name}`); 
                };
                aList.appendChild(b);
            }

            const consumables = {...stats.potions, ...stats.spells};
            for(let name in consumables) {
                const count = consumables[name][0];
                if(count <= 0) continue;
                
                // Check if this is a healing potion - only healing potions can be used outside combat
                const isHealingPotion = name === 'healing potion';
                const canUse = isHealingPotion && stats.HP < stats.maxHP;
                
                const div = document.createElement('div');
                div.className = `p-3 bg-slate-900 border border-slate-800 rounded ${canUse ? 'cursor-pointer hover:bg-slate-800 transition-colors' : ''}`;
                
                const content = `
                    <div class="flex justify-between items-center">
                        <span class="text-base font-bold uppercase text-slate-300">${name}</span>
                        <div class="flex items-center gap-2">
                            <span class="bg-blue-900/40 px-3 py-1 rounded text-blue-400 font-bold text-sm">x${count}</span>
                            ${canUse ? '<button class="bg-green-700 hover:bg-green-600 px-4 py-2 rounded text-sm font-bold text-white">USE</button>' : ''}
                        </div>
                    </div>
                `;
                
                div.innerHTML = content;
                
                if(canUse) {
                    div.onclick = () => useItemFromInventory(name);
                }
                
                cList.appendChild(div);
            }
            if(cList.innerHTML === '') cList.innerHTML = '<div class="text-sm text-slate-600 uppercase font-bold text-center py-4">No Consumables</div>';
            
            // Tools section - show map if owned
            if (stats.hasMap) {
                const mapDiv = document.createElement('div');
                mapDiv.className = 'p-3 bg-slate-900 border border-slate-800 rounded cursor-pointer hover:bg-slate-800 transition-colors';
                mapDiv.innerHTML = `
                    <div class="flex justify-between items-center">
                        <span class="text-base font-bold uppercase text-slate-300">üó∫Ô∏è Dungeon Map</span>
                        <button class="bg-blue-700 hover:bg-blue-600 px-4 py-2 rounded text-sm font-bold text-white">VIEW</button>
                    </div>
                `;
                mapDiv.onclick = () => showMapLegend();
                tList.appendChild(mapDiv);
            }
            
            if(tList.innerHTML === '') tList.innerHTML = '<div class="text-sm text-slate-600 uppercase font-bold text-center py-4">No Tools</div>';
        }
        
        function showMapLegend() {
            const modal = document.createElement('div');
            modal.id = 'map-legend-modal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.9); z-index: 9999;
                display: flex; align-items: center; justify-content: center;
            `;
            
            modal.innerHTML = `
                <div style="background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%); 
                    border: 3px solid #10b981; border-radius: 12px; padding: 32px; 
                    max-width: 500px; width: 90%; box-shadow: 0 20px 60px rgba(16, 185, 129, 0.4);">
                    <h2 style="font-size: 24px; font-weight: bold; color: #10b981; 
                        text-align: center; margin-bottom: 16px; text-transform: uppercase;">
                        üó∫Ô∏è Dungeon Map Legend
                    </h2>
                    <p style="text-align: center; color: #cbd5e1; margin-bottom: 24px; font-size: 14px;">
                        Map symbols and their meanings
                    </p>
                    <div style="background: #0f172a; padding: 20px; border-radius: 8px; margin-bottom: 16px; border: 2px solid #334155;">
                        <div style="display: flex; flex-direction: column; gap: 12px;">
                            <div style="display: flex; align-items: center; gap: 12px;">
                                <div style="width: 32px; height: 32px; background: #3b82f6; border-radius: 4px; display: flex; align-items: center; justify-content: center; box-shadow: 0 0 10px rgba(59, 130, 246, 0.5);"></div>
                                <div style="flex: 1;">
                                    <div style="color: #3b82f6; font-weight: bold; font-size: 14px;">Your Position</div>
                                    <div style="color: #94a3b8; font-size: 12px;">Where you are currently located</div>
                                </div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 12px;">
                                <div style="width: 32px; height: 32px; background: #dc2626; border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 18px;">üëë</div>
                                <div style="flex: 1;">
                                    <div style="color: #dc2626; font-weight: bold; font-size: 14px;">Boss</div>
                                    <div style="color: #94a3b8; font-size: 12px;">Powerful enemy, drops key</div>
                                </div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 12px;">
                                <div style="width: 32px; height: 32px; background: #ea580c; border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 18px;">‚öî</div>
                                <div style="flex: 1;">
                                    <div style="color: #ea580c; font-weight: bold; font-size: 14px;">Mini-Boss</div>
                                    <div style="color: #94a3b8; font-size: 12px;">Tough enemy, good rewards</div>
                                </div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 12px;">
                                <div style="width: 32px; height: 32px; background: #15803d; border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 18px;">‚¨á</div>
                                <div style="flex: 1;">
                                    <div style="color: #15803d; font-weight: bold; font-size: 14px;">Stairs Down</div>
                                    <div style="color: #94a3b8; font-size: 12px;">Descend to next floor</div>
                                </div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 12px;">
                                <div style="width: 32px; height: 32px; background: #b45309; border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 18px;">üì¶</div>
                                <div style="flex: 1;">
                                    <div style="color: #b45309; font-weight: bold; font-size: 14px;">Merchant</div>
                                    <div style="color: #94a3b8; font-size: 12px;">Dungeon shopkeeper</div>
                                </div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 12px;">
                                <div style="width: 32px; height: 32px; background: #1e293b; border: 2px solid #475569; border-radius: 4px;"></div>
                                <div style="flex: 1;">
                                    <div style="color: #94a3b8; font-weight: bold; font-size: 14px;">Empty Room</div>
                                    <div style="color: #64748b; font-size: 12px;">May contain chests or monsters</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <button onclick="closeMapLegend()" 
                        style="width: 100%; padding: 12px; background: #10b981; border-radius: 8px; 
                        font-weight: bold; color: white; cursor: pointer; border: none; font-size: 16px;">
                        CLOSE
                    </button>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        function closeMapLegend() {
            const modal = document.getElementById('map-legend-modal');
            if (modal) modal.remove();
        }

        // --- USE ITEMS FROM INVENTORY (OUTSIDE COMBAT) ---
        function useItemFromInventory(name) {
            if (name === 'healing potion') {
                if (stats.HP >= stats.maxHP) {
                    addLog("Already at full health!", "text-slate-400");
                    return;
                }
                
                if (!stats.potions[name] || stats.potions[name][0] <= 0) {
                    addLog("No healing potions left!", "text-red-400");
                    return;
                }
                
                stats.potions[name][0]--;
                const heal = (Math.floor(Math.random()*4)+1) + (Math.floor(Math.random()*4)+1);
                stats.HP = Math.min(stats.maxHP, stats.HP + heal);
                addLog(`Drank healing potion - Healed ${heal} HP`, "text-green-400");
                
                if(stats.potions[name][0] <= 0) {
                    delete stats.potions[name];
                }
                
                updateUI();
                renderInventory();
            }
        }

        // --- ITEMS IN COMBAT ---
        function renderCombatInventory() {
            const list = document.getElementById('combat-inventory-list');
            list.innerHTML = '';
            const items = {...stats.potions, ...stats.spells};
            for (const [name, data] of Object.entries(items)) {
                if (data[0] > 0) {
                    const b = document.createElement('button');
                    b.className = "w-full p-3 bg-slate-800 text-sm text-left flex justify-between rounded px-4 border border-slate-700 hover:bg-slate-700";
                    b.innerHTML = `<span class="uppercase font-bold text-white">${name}</span><span class="text-yellow-500 font-bold">x${data[0]}</span>`;
                    b.onclick = () => useItem(name);
                    list.appendChild(b);
                }
            }
        }

        function renderAchievements() {
            const list = document.getElementById('achievements-list');
            list.innerHTML = '';
            
            let totalEarned = Object.keys(stats.achievements).length;
            const totalAchievements = Object.keys(ACHIEVEMENTS).length;
            
            // Progress bar
            const progressDiv = document.createElement('div');
            progressDiv.className = 'mb-6 p-4 bg-slate-900 rounded border border-slate-800';
            const progress = Math.round((totalEarned / totalAchievements) * 100);
            progressDiv.innerHTML = `
                <div class="flex justify-between items-center mb-2">
                    <span class="text-lg font-bold">Progress: ${totalEarned}/${totalAchievements}</span>
                    <span class="text-yellow-500 font-bold">${progress}%</span>
                </div>
                <div class="w-full h-3 bg-slate-800 rounded overflow-hidden">
                    <div class="h-full bg-yellow-500 transition-all" style="width: ${progress}%"></div>
                </div>
            `;
            list.appendChild(progressDiv);
            
            // Difficulty color mapping
            const difficultyColors = {
                easy: 'text-green-400',
                medium: 'text-blue-400',
                hard: 'text-red-400'
            };
            
            const difficultyEmoji = {
                easy: '‚≠ê',
                medium: '‚≠ê‚≠ê',
                hard: '‚≠ê‚≠ê‚≠ê'
            };
            
            // Achievement items
            for (const [key, achievement] of Object.entries(ACHIEVEMENTS)) {
                const isEarned = stats.achievements[key];
                const div = document.createElement('div');
                div.className = `p-4 rounded border-2 transition-all ${isEarned ? 'bg-slate-900 border-yellow-500' : 'bg-slate-950 border-slate-800 opacity-60'}`;
                
                const diffColor = difficultyColors[achievement.difficulty] || 'text-slate-400';
                const diffEmoji = difficultyEmoji[achievement.difficulty] || '';
                
                div.innerHTML = `
                    <div class="flex items-start gap-4">
                        <div class="text-3xl">${isEarned ? 'üèÜ' : 'üîí'}</div>
                        <div class="flex-1">
                            <div class="flex items-center justify-between mb-1">
                                <h3 class="text-lg font-bold ${isEarned ? 'text-yellow-400' : 'text-slate-400'}">${achievement.name}</h3>
                                <span class="${diffColor} font-bold text-sm">${diffEmoji}</span>
                            </div>
                            <p class="text-sm text-slate-500 mt-1">${achievement.desc}</p>
                            <div class="flex justify-between items-center mt-2">
                                <div class="text-xs ${diffColor} font-bold">Reward: +${achievement.reward} Gold</div>
                                ${isEarned ? '<div class="text-green-400 font-bold text-xs">UNLOCKED ‚úì</div>' : ''}
                            </div>
                        </div>
                    </div>
                `;
                list.appendChild(div);
            }
        }

        async function useItem(name) {
            if (isProcessing) return;
            isProcessing = true;
            const isPotion = stats.potions[name];
            const itemData = isPotion || stats.spells[name];
            if(isPotion) {
                stats.potions[name][0]--;
                const typeId = itemData[1];
                addLog(`Drank ${name}`, "text-blue-300");
                if(typeId === 1) {
                    const heal = (Math.floor(Math.random()*4)+1) + (Math.floor(Math.random()*4)+1);
                    stats.HP = Math.min(stats.maxHP, stats.HP + heal);
                    addLog(`Healed ${heal} HP`, "text-green-400");
                } else if(typeId === 2) stats.temporary_intelligence = 6;
                else if(typeId === 3) stats.temporary_dexterity = 6;
                else if(typeId === 4) stats.temporary_strength = 6;
                else if(typeId === 5) stats.temporary_armor = 3;
                if(stats.potions[name][0] <= 0) delete stats.potions[name];
                isProcessing = false;
                monsterTurnStart();
            } else {
                stats.spells[name][0]--;
                const typeId = itemData[1];
                const need = typeId===1?10 : typeId===2?11 : typeId===3?12 : typeId===4?10 : 11;
                await logLoading("Casting...", 3, 100);
                const roll = Math.floor(Math.random()*20)+1 + Math.floor(stats.wisdom/2)-5;
                addLog(`Wis Roll: ${roll} vs ${need}`);
                if(roll >= need) {
                    stats.spellsCast++;
                    addLog("Spell Success!", "text-purple-400 font-bold");
                    if(typeId===2) { combatData.strength -= 2; combatData.change_strength = true; }
                    if(typeId===4) combatData.freeze = 2;
                    if(typeId===5) combatData.fire = true;
                    let dmg = 0;
                    if(typeId===1 || typeId===2) dmg = Math.floor(Math.random()*8)+1;
                    else if(typeId===3) dmg = Math.floor(Math.random()*6)+Math.floor(Math.random()*6)+Math.floor(Math.random()*10)+3;
                    else if(typeId===4) dmg = Math.floor(Math.random()*6)+1;
                    else if(typeId===5) dmg = Math.floor(Math.random()*15)+5;
                    addLog(`Spell dealt ${dmg} damage`, "text-purple-300");
                    combatData.HP -= dmg;
                    if(combatData.HP <= 0) { 
                        isProcessing = false;
                        await victory(); 
                        return; 
                    }
                } else addLog("Spell Fizzled!", "text-slate-500");
                if(stats.spells[name][0] <= 0) delete stats.spells[name];
                isProcessing = false;
                updateUI();
                monsterTurnStart();
                return;
            }
            updateUI();
        }

        addLog("Welcome to Oakhaven.", "text-slate-500 italic");
        
        // Check authentication on page load
        checkAuth().then(authenticated => {
            if (authenticated) {
                console.log('User authenticated for Dungeon Game');
            }
        });
        
        // Cheat code: Type "coins" to get 200 gold
        let cheatBuffer = '';
        document.addEventListener('keydown', function(event) {
            // Add the key to the buffer
            cheatBuffer += event.key.toLowerCase();
            
            // Keep only the last 5 characters
            if (cheatBuffer.length > 5) {
                cheatBuffer = cheatBuffer.slice(-5);
            }
            
            // Check if buffer matches "coins"
            if (cheatBuffer === 'coins') {
                stats.coins += 200;
                addLog('CHEAT: +200 Gold!', 'text-yellow-400 font-bold');
                updateUI();
                cheatBuffer = ''; // Reset buffer
            }
        });
    </script>

        </main>
        <div class="push"></div>
    </div>

    <footer>
        <p>&copy; 2025 Ahrens Labs. All rights reserved.</p>
    </footer>
</body>
</html>
