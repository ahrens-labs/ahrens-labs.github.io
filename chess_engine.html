<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Chess Game against TrifangX</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Orbitron&family=Roboto+Mono&display=swap" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">
    <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <link rel="stylesheet" href="css/style.css">
    <link rel="icon" type="image/x-icon" href="/img/favicon.ico">
    <script src="js/script.js"></script>

  <style>
    /* Chess Engine Page - Enhanced Clean Theme */
    body {
      background: linear-gradient(135deg, #f0f4f8 0%, #e8f2f7 50%, #f0f4f8 100%);
      background-attachment: fixed;
      color: #333;
      min-height: 100vh;
      overflow-x: hidden;
      position: relative;
    }

    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: 
          radial-gradient(circle at 20% 80%, rgba(52, 152, 219, 0.03) 0%, transparent 50%),
          radial-gradient(circle at 80% 20%, rgba(46, 204, 113, 0.02) 0%, transparent 50%);
      background-size: 600px 600px;
      animation: subtleFloat 15s ease-in-out infinite;
      pointer-events: none;
      z-index: -1;
    }

    /* Main content container */
    main {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      max-width: 1200px;
      margin: 0 auto;
    }

    /* Main Title Styling */
    h2 {
      text-align: center;
      font-family: "Inter", sans-serif;
      font-size: 2.5rem;
      font-weight: 700;
      margin-bottom: 2rem;
      color: #2c3e50;
      margin-top: 1rem;
      position: relative;
    }

    h2::after {
      content: '';
      position: absolute;
      bottom: -10px;
      left: 50%;
      transform: translateX(-50%);
      width: 100px;
      height: 3px;
      background: linear-gradient(90deg, #3498db, #2ecc71);
      border-radius: 2px;
    }

    .sharp {
      background: linear-gradient(135deg, #3498db, #2ecc71);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      font-weight: 800;
      animation: shimmer 3s ease-in-out infinite;
    }

    /* Game Controls Container */
    #choose-side {
      background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
      padding: 30px;
      border-radius: 20px;
      box-shadow: 
          0 10px 30px rgba(0, 0, 0, 0.1),
          0 1px 8px rgba(0, 0, 0, 0.1),
          inset 0 1px 0 rgba(255, 255, 255, 0.8);
      max-width: 800px;
      margin: 0 auto 30px auto;
      display: flex;
      flex-direction: column;
      gap: 20px;
      align-items: center;
      text-align: center;
      border: 1px solid rgba(52, 152, 219, 0.1);
      position: relative;
      overflow: hidden;
    }

    #choose-side::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, #3498db, #2ecc71, #3498db);
      background-size: 200% 100%;
      animation: shimmer 3s ease-in-out infinite;
    }

    /* Individual control rows */
    .control-row {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      width: 100%;
      flex-wrap: wrap;
    }

    /* Keep label and select together on same line */
    .control-row label:not([for="blindfold-mode"]):not([for="show-history"]) {
      white-space: nowrap;
    }

    .control-row > label,
    .control-row > select {
      flex-shrink: 0;
    }

    /* Less prominent style options */
    .control-row.style-option {
      font-size: 0.9em;
      opacity: 0.8;
    }

    .control-row.style-option label {
      font-size: 0.95em;
      font-weight: 500;
      color: #5a6c7d;
    }

    .control-row.style-option select {
      font-size: 0.9em;
      min-width: 130px;
      padding: 10px 16px;
    }

    /* Labels */
    label {
      font-family: "Inter", sans-serif;
      color: #2c3e50;
      font-weight: 600;
      margin-right: 10px;
      font-size: 1.1em;
    }

    /* Select Dropdowns */
    select {
      background-color: white;
      color: #333;
      border: 2px solid #3498db;
      border-radius: 20px;
      padding: 12px 18px;
      font-family: "Inter", sans-serif;
      font-size: 1em;
      margin: 0;
      transition: all 0.3s ease;
      box-shadow: 0 2px 8px rgba(52, 152, 219, 0.1);
      min-width: 140px;
      max-width: 160px;
      cursor: pointer;
    }

    /* Engine personality selector - make it stand out */
    #engine-style {
      border: 3px solid #6c757d;
      background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
      font-weight: 600;
      min-width: 180px;
      box-shadow: 0 3px 10px rgba(108, 117, 125, 0.15);
      position: relative;
      transition: all 0.4s ease;
    }

    /* Personality color classes */
    #engine-style.personality-balanced {
      border-color: #6c757d;
      box-shadow: 0 3px 10px rgba(108, 117, 125, 0.3), 0 0 15px rgba(108, 117, 125, 0.2);
      background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
    }

    #engine-style.personality-aggressive {
      border-color: #e74c3c;
      box-shadow: 0 3px 12px rgba(231, 76, 60, 0.4), 0 0 20px rgba(231, 76, 60, 0.3);
      background: linear-gradient(145deg, #ffffff 0%, #fff5f5 100%);
    }

    #engine-style.personality-defensive {
      border-color: #3498db;
      box-shadow: 0 3px 12px rgba(52, 152, 219, 0.4), 0 0 20px rgba(52, 152, 219, 0.3);
      background: linear-gradient(145deg, #ffffff 0%, #f0f8ff 100%);
    }

    #engine-style.personality-positional {
      border-color: #9b59b6;
      box-shadow: 0 3px 12px rgba(155, 89, 182, 0.4), 0 0 20px rgba(155, 89, 182, 0.3);
      background: linear-gradient(145deg, #ffffff 0%, #f8f0ff 100%);
    }

    #engine-style.personality-material {
      border-color: #f39c12;
      box-shadow: 0 3px 12px rgba(243, 156, 18, 0.4), 0 0 20px rgba(243, 156, 18, 0.3);
      background: linear-gradient(145deg, #ffffff 0%, #fffaf0 100%);
    }

    #engine-style.personality-tactical {
      border-color: #1abc9c;
      box-shadow: 0 3px 12px rgba(26, 188, 156, 0.4), 0 0 20px rgba(26, 188, 156, 0.3);
      background: linear-gradient(145deg, #ffffff 0%, #f0fff8 100%);
    }

    #engine-style:hover {
      transform: translateY(-2px) scale(1.02);
      filter: brightness(1.05);
    }

    #engine-style:focus {
      outline: none;
      transform: scale(1.03);
    }

    /* Custom personality class */
    #engine-style.personality-custom {
      border-color: #34495e;
      box-shadow: 0 3px 12px rgba(52, 73, 94, 0.4), 0 0 20px rgba(52, 73, 94, 0.3);
      background: linear-gradient(145deg, #ffffff 0%, #f5f6fa 100%);
    }

    /* Custom modifiers panel */
    #custom-modifiers-panel {
      background: linear-gradient(145deg, #f8f9fa 0%, #ffffff 100%);
      border: 2px solid #34495e;
      border-radius: 15px;
      padding: 20px;
      margin: 15px 0;
      box-shadow: 0 4px 15px rgba(52, 73, 94, 0.15);
      animation: slideDown 0.3s ease;
    }

    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .modifier-input-group {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .modifier-input-group label {
      flex: 1;
      font-size: 0.95em;
      font-weight: 500;
      color: #2c3e50;
      text-align: left;
    }

    .modifier-input-group input[type="number"] {
      width: 80px;
      padding: 8px 12px;
      border: 2px solid #34495e;
      border-radius: 10px;
      font-family: "Roboto Mono", monospace;
      font-size: 0.95em;
      text-align: center;
      transition: all 0.3s ease;
      background: white;
    }

    .modifier-input-group input[type="number"]:hover {
      border-color: #5d6d7e;
      box-shadow: 0 2px 8px rgba(52, 73, 94, 0.2);
    }

    .modifier-input-group input[type="number"]:focus {
      outline: none;
      border-color: #3498db;
      box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.15);
    }

    /* Option elements styling */
    select option {
      background: white;
      color: #333;
      font-family: "Inter", sans-serif;
      padding: 8px;
    }

    select:hover {
      border-color: #2980b9;
      box-shadow: 0 4px 12px rgba(52, 152, 219, 0.2);
      transform: translateY(-1px);
    }

    select:focus {
      outline: none;
      border-color: #3498db;
      box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
    }

    /* Start Game Button */
    button {
      width: 100%;
      padding: 15px 20px;
      font-size: 1.1em;
      background-color: #3498db;
      color: white;
      border: none;
      border-radius: 20px;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      font-family: "Inter", sans-serif;
      font-weight: 600;
      box-shadow: 0 4px 12px rgba(52, 152, 219, 0.2);
      margin: 10px 0;
      max-width: 200px;
    }

    button:hover {
      background-color: #2980b9;
      transform: translateY(-2px) scale(1.02);
      box-shadow: 0 6px 16px rgba(52, 152, 219, 0.3);
    }

    button:active {
      transform: translateY(0) scale(1);
      box-shadow: 0 2px 8px rgba(52, 152, 219, 0.2);
    }

    /* Chess Board Container */
    #board-timers-container {
      display: flex !important;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      height: auto;
      min-height: 450px;
      justify-content: flex-start;
      align-self: flex-start;
    }

    /* Chess Board Styling */
    #board {
      width: 450px;
      height: 450px;
      border-radius: 15px;
      box-shadow: 
          0 15px 35px rgba(0, 0, 0, 0.15),
          0 5px 15px rgba(0, 0, 0, 0.1);
      border: 3px solid #e9ecef;
      overflow: hidden;
      position: relative;
      background-color: white;
      transition: all 0.3s ease;
    }

    #board:hover {
      transform: translateY(-2px);
      box-shadow: 
          0 20px 40px rgba(0, 0, 0, 0.2),
          0 8px 20px rgba(0, 0, 0, 0.1);
    }

    /* Board Color Themes with Enhanced Visual Effects */
    .board-theme-classic .white-1e1d7 { 
      background: linear-gradient(135deg, #f0d9b5 0%, #e8d0a8 100%);
      box-shadow: inset 0 0 20px rgba(181, 136, 99, 0.1);
    }
    .board-theme-classic .black-3c85d { 
      background: linear-gradient(135deg, #b58863 0%, #a67c52 100%);
      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.2);
    }

    .board-theme-blue .white-1e1d7 { 
      background: linear-gradient(135deg, #dee3e6 0%, #d0d8dd 100%);
      box-shadow: inset 0 0 15px rgba(140, 162, 173, 0.15);
    }
    .board-theme-blue .black-3c85d { 
      background: linear-gradient(135deg, #8ca2ad 0%, #7a95a3 100%);
      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.25);
    }

    .board-theme-green .white-1e1d7 { 
      background: linear-gradient(135deg, #ffffdd 0%, #f5f5c8 100%);
      box-shadow: inset 0 0 15px rgba(134, 166, 102, 0.1);
    }
    .board-theme-green .black-3c85d { 
      background: linear-gradient(135deg, #86a666 0%, #75955a 100%);
      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.2);
    }

    .board-theme-gray .white-1e1d7 { 
      background: linear-gradient(135deg, #e8e8e8 0%, #dcdcdc 100%);
      box-shadow: inset 0 0 10px rgba(153, 153, 153, 0.1);
    }
    .board-theme-gray .black-3c85d { 
      background: linear-gradient(135deg, #999999 0%, #888888 100%);
      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.3);
    }

    .board-theme-purple .white-1e1d7 { 
      background: linear-gradient(135deg, #e8d4f2 0%, #dfc5ed 100%);
      box-shadow: inset 0 0 15px rgba(155, 109, 181, 0.15);
    }
    .board-theme-purple .black-3c85d { 
      background: linear-gradient(135deg, #9b6db5 0%, #8a5da0 100%);
      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.25);
    }

    .board-theme-wood .white-1e1d7 { 
      background: 
        linear-gradient(135deg, #f4dec4 0%, #ead4b0 100%),
        repeating-linear-gradient(45deg, transparent, transparent 2px, rgba(139, 90, 43, 0.03) 2px, rgba(139, 90, 43, 0.03) 4px);
      box-shadow: inset 0 0 25px rgba(139, 90, 43, 0.2);
    }
    .board-theme-wood .black-3c85d { 
      background: 
        linear-gradient(135deg, #8b5a2b 0%, #7a4a1f 100%),
        repeating-linear-gradient(45deg, transparent, transparent 2px, rgba(0, 0, 0, 0.1) 2px, rgba(0, 0, 0, 0.1) 4px);
      box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.4);
    }

    .board-theme-coral .white-1e1d7 { 
      background: linear-gradient(135deg, #ffebcd 0%, #ffe0b3 100%);
      box-shadow: inset 0 0 15px rgba(205, 133, 63, 0.15);
    }
    .board-theme-coral .black-3c85d { 
      background: linear-gradient(135deg, #cd853f 0%, #b87333 100%);
      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.25);
    }

    .board-theme-marble .white-1e1d7 { 
      background: 
        linear-gradient(135deg, #f5f5f0 0%, #ecece5 100%),
        repeating-linear-gradient(0deg, transparent, transparent 8px, rgba(139, 134, 128, 0.05) 8px, rgba(139, 134, 128, 0.05) 10px);
      box-shadow: inset 0 0 20px rgba(139, 134, 128, 0.1);
    }
    .board-theme-marble .black-3c85d { 
      background: 
        linear-gradient(135deg, #8b8680 0%, #7d7872 100%),
        repeating-linear-gradient(0deg, transparent, transparent 8px, rgba(0, 0, 0, 0.1) 8px, rgba(0, 0, 0, 0.1) 10px);
      box-shadow: inset 0 0 25px rgba(0, 0, 0, 0.3);
    }

    .board-theme-dark .white-1e1d7 { 
      background: linear-gradient(135deg, #4a5568 0%, #3d4758 100%);
      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.3);
    }
    .board-theme-dark .black-3c85d { 
      background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
      box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.5);
    }

    .board-theme-neon .white-1e1d7 { 
      background: linear-gradient(135deg, #e0f7fa 0%, #b2ebf2 100%);
      box-shadow: inset 0 0 20px rgba(0, 172, 193, 0.3), 0 0 10px rgba(0, 172, 193, 0.2);
    }
    .board-theme-neon .black-3c85d { 
      background: linear-gradient(135deg, #00acc1 0%, #00838f 100%);
      box-shadow: inset 0 0 25px rgba(0, 0, 0, 0.3), 0 0 15px rgba(0, 172, 193, 0.4);
    }

    .board-theme-emerald .white-1e1d7 { 
      background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
      box-shadow: inset 0 0 15px rgba(40, 167, 69, 0.2);
    }
    .board-theme-emerald .black-3c85d { 
      background: linear-gradient(135deg, #28a745 0%, #218838 100%);
      box-shadow: inset 0 0 25px rgba(0, 0, 0, 0.3);
    }

    .board-theme-gold .white-1e1d7 { 
      background: linear-gradient(135deg, #fff8dc 0%, #ffeaa7 100%);
      box-shadow: inset 0 0 20px rgba(218, 165, 32, 0.3), 0 0 10px rgba(218, 165, 32, 0.1);
    }
    .board-theme-gold .black-3c85d { 
      background: linear-gradient(135deg, #daa520 0%, #c4941c 100%);
      box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.4), 0 0 15px rgba(218, 165, 32, 0.3);
    }

    .board-theme-ocean .white-1e1d7 { 
      background: 
        linear-gradient(135deg, #e0f2f1 0%, #b2dfdb 100%),
        radial-gradient(circle at 30% 30%, rgba(0, 105, 92, 0.1) 0%, transparent 50%);
      box-shadow: inset 0 0 20px rgba(0, 105, 92, 0.15);
    }
    .board-theme-ocean .black-3c85d { 
      background: 
        linear-gradient(135deg, #00695c 0%, #004d40 100%),
        radial-gradient(circle at 70% 70%, rgba(0, 0, 0, 0.2) 0%, transparent 50%);
      box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.4);
    }

    .board-theme-sunset .white-1e1d7 { 
      background: linear-gradient(135deg, #ffe5cc 0%, #ffcc99 100%);
      box-shadow: inset 0 0 20px rgba(255, 107, 53, 0.25);
    }
    .board-theme-sunset .black-3c85d { 
      background: linear-gradient(135deg, #ff6b35 0%, #e55a2b 100%);
      box-shadow: inset 0 0 25px rgba(0, 0, 0, 0.3);
    }

    .board-theme-midnight .white-1e1d7 { 
      background: 
        linear-gradient(135deg, #3a3f4b 0%, #2d323d 100%),
        radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.05) 0%, transparent 70%);
      box-shadow: inset 0 0 25px rgba(0, 0, 0, 0.4);
    }
    .board-theme-midnight .black-3c85d { 
      background: 
        linear-gradient(135deg, #1a1d24 0%, #0f1114 100%),
        radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.03) 0%, transparent 70%);
      box-shadow: inset 0 0 35px rgba(0, 0, 0, 0.6);
    }

    .board-theme-forest .white-1e1d7 { 
      background: 
        linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%),
        repeating-linear-gradient(45deg, transparent, transparent 3px, rgba(46, 125, 50, 0.05) 3px, rgba(46, 125, 50, 0.05) 6px);
      box-shadow: inset 0 0 15px rgba(46, 125, 50, 0.15);
    }
    .board-theme-forest .black-3c85d { 
      background: 
        linear-gradient(135deg, #2e7d32 0%, #1b5e20 100%),
        repeating-linear-gradient(45deg, transparent, transparent 3px, rgba(0, 0, 0, 0.1) 3px, rgba(0, 0, 0, 0.1) 6px);
      box-shadow: inset 0 0 25px rgba(0, 0, 0, 0.35);
    }

    .board-theme-royal .white-1e1d7 { 
      background: linear-gradient(135deg, #f3e5f5 0%, #e1bee7 100%);
      box-shadow: inset 0 0 20px rgba(123, 31, 162, 0.25), 0 0 10px rgba(123, 31, 162, 0.1);
    }
    .board-theme-royal .black-3c85d { 
      background: linear-gradient(135deg, #7b1fa2 0%, #6a1b9a 100%);
      box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.4), 0 0 15px rgba(123, 31, 162, 0.3);
    }

    .board-theme-ice .white-1e1d7 { 
      background: 
        linear-gradient(135deg, #e1f5fe 0%, #b3e5fc 100%),
        radial-gradient(circle at 20% 20%, rgba(2, 119, 189, 0.1) 0%, transparent 60%);
      box-shadow: inset 0 0 20px rgba(2, 119, 189, 0.2);
    }
    .board-theme-ice .black-3c85d { 
      background: 
        linear-gradient(135deg, #0277bd 0%, #01579b 100%),
        radial-gradient(circle at 80% 80%, rgba(0, 0, 0, 0.2) 0%, transparent 60%);
      box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.4);
    }

    .board-theme-cherry .white-1e1d7 { 
      background: linear-gradient(135deg, #ffebee 0%, #ffcdd2 100%);
      box-shadow: inset 0 0 20px rgba(198, 40, 40, 0.2);
    }
    .board-theme-cherry .black-3c85d { 
      background: linear-gradient(135deg, #c62828 0%, #b71c1c 100%);
      box-shadow: inset 0 0 25px rgba(0, 0, 0, 0.35);
    }

    /* Advanced Visual Effect Themes */
    .board-theme-3d .white-1e1d7 { 
      background: 
        linear-gradient(135deg, #f5f5f0 0%, #e8e8e0 50%, #f5f5f0 100%),
        repeating-linear-gradient(45deg, transparent, transparent 4px, rgba(0, 0, 0, 0.02) 4px, rgba(0, 0, 0, 0.02) 8px);
      box-shadow: inset -2px -2px 8px rgba(0, 0, 0, 0.1), inset 2px 2px 8px rgba(255, 255, 255, 0.5);
    }
    .board-theme-3d .black-3c85d { 
      background: 
        linear-gradient(135deg, #8b8680 0%, #7a7570 50%, #8b8680 100%),
        repeating-linear-gradient(45deg, transparent, transparent 4px, rgba(0, 0, 0, 0.1) 4px, rgba(0, 0, 0, 0.1) 8px);
      box-shadow: inset -2px -2px 10px rgba(0, 0, 0, 0.4), inset 2px 2px 10px rgba(255, 255, 255, 0.1);
    }

    .board-theme-glass .white-1e1d7 { 
      background: 
        linear-gradient(135deg, rgba(255, 255, 255, 0.9) 0%, rgba(240, 240, 240, 0.8) 100%),
        radial-gradient(circle at 30% 30%, rgba(200, 200, 255, 0.2) 0%, transparent 70%);
      box-shadow: inset 0 0 30px rgba(200, 200, 255, 0.3), 0 0 20px rgba(200, 200, 255, 0.2);
      backdrop-filter: blur(1px);
    }
    .board-theme-glass .black-3c85d { 
      background: 
        linear-gradient(135deg, rgba(100, 100, 150, 0.8) 0%, rgba(70, 70, 120, 0.9) 100%),
        radial-gradient(circle at 70% 70%, rgba(0, 0, 0, 0.3) 0%, transparent 70%);
      box-shadow: inset 0 0 35px rgba(0, 0, 0, 0.4), 0 0 25px rgba(100, 100, 150, 0.3);
      backdrop-filter: blur(1px);
    }

    .board-theme-carbon .white-1e1d7 { 
      background: 
        linear-gradient(135deg, #e8e8e8 0%, #d0d0d0 100%),
        repeating-linear-gradient(0deg, transparent, transparent 1px, rgba(0, 0, 0, 0.03) 1px, rgba(0, 0, 0, 0.03) 2px),
        repeating-linear-gradient(90deg, transparent, transparent 1px, rgba(0, 0, 0, 0.03) 1px, rgba(0, 0, 0, 0.03) 2px);
      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.1);
    }
    .board-theme-carbon .black-3c85d { 
      background: 
        linear-gradient(135deg, #2c2c2c 0%, #1a1a1a 100%),
        repeating-linear-gradient(0deg, transparent, transparent 1px, rgba(255, 255, 255, 0.05) 1px, rgba(255, 255, 255, 0.05) 2px),
        repeating-linear-gradient(90deg, transparent, transparent 1px, rgba(255, 255, 255, 0.05) 1px, rgba(255, 255, 255, 0.05) 2px);
      box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.5);
    }

    .board-theme-velvet .white-1e1d7 { 
      background: 
        radial-gradient(ellipse at 30% 30%, rgba(255, 255, 255, 0.8) 0%, transparent 50%),
        linear-gradient(135deg, #f5f0f5 0%, #e8e0e8 100%);
      box-shadow: inset 0 0 25px rgba(138, 43, 226, 0.15);
    }
    .board-theme-velvet .black-3c85d { 
      background: 
        radial-gradient(ellipse at 70% 70%, rgba(0, 0, 0, 0.3) 0%, transparent 50%),
        linear-gradient(135deg, #8a2be2 0%, #6a1b9a 100%);
      box-shadow: inset 0 0 35px rgba(0, 0, 0, 0.5), 0 0 20px rgba(138, 43, 226, 0.3);
    }

    .board-theme-stone .white-1e1d7 { 
      background: 
        linear-gradient(135deg, #d5d5d5 0%, #c0c0c0 100%),
        repeating-linear-gradient(45deg, transparent, transparent 6px, rgba(0, 0, 0, 0.05) 6px, rgba(0, 0, 0, 0.05) 12px),
        radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.3) 0%, transparent 40%);
      box-shadow: inset 0 0 25px rgba(0, 0, 0, 0.15);
    }
    .board-theme-stone .black-3c85d { 
      background: 
        linear-gradient(135deg, #696969 0%, #555555 100%),
        repeating-linear-gradient(45deg, transparent, transparent 6px, rgba(0, 0, 0, 0.15) 6px, rgba(0, 0, 0, 0.15) 12px),
        radial-gradient(circle at 80% 80%, rgba(0, 0, 0, 0.3) 0%, transparent 40%);
      box-shadow: inset 0 0 35px rgba(0, 0, 0, 0.4);
    }

    .board-theme-cyber .white-1e1d7 { 
      background: 
        linear-gradient(135deg, #00ff88 0%, #00cc6a 100%),
        repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0, 255, 136, 0.1) 2px, rgba(0, 255, 136, 0.1) 4px);
      box-shadow: inset 0 0 30px rgba(0, 255, 136, 0.4), 0 0 20px rgba(0, 255, 136, 0.3);
    }
    .board-theme-cyber .black-3c85d { 
      background: 
        linear-gradient(135deg, #001a0f 0%, #000000 100%),
        repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0, 255, 136, 0.2) 2px, rgba(0, 255, 136, 0.2) 4px);
      box-shadow: inset 0 0 40px rgba(0, 255, 136, 0.5), 0 0 30px rgba(0, 255, 136, 0.4);
    }

    .board-theme-luxury .white-1e1d7 { 
      background: 
        linear-gradient(135deg, #fffef7 0%, #f5f4e8 100%),
        radial-gradient(ellipse at 50% 50%, rgba(212, 175, 55, 0.15) 0%, transparent 70%);
      box-shadow: inset 0 0 30px rgba(212, 175, 55, 0.2), 0 0 15px rgba(212, 175, 55, 0.1);
    }
    .board-theme-luxury .black-3c85d { 
      background: 
        linear-gradient(135deg, #d4af37 0%, #b8941f 100%),
        radial-gradient(ellipse at 50% 50%, rgba(0, 0, 0, 0.3) 0%, transparent 70%);
      box-shadow: inset 0 0 40px rgba(0, 0, 0, 0.5), 0 0 25px rgba(212, 175, 55, 0.4);
    }

    /* Legal Move Highlights */
    .highlight-legal {
      position: relative;
    }
    .highlight-legal::after {
      content: "";
      position: absolute;
      top: 50%;
      left: 50%;
      width: 20px;
      height: 20px;
      background: radial-gradient(circle, #3498db, transparent);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 10;
      animation: legalMovePulse 1.5s ease-in-out infinite;
    }

    /* Hide default drag-over border */
    #board .square-55d63 {
      box-shadow: none !important;
    }

    /* Enable pointer events for dragging */
    #board img {
      pointer-events: auto !important;
      cursor: grab;
      user-select: none;
      -webkit-user-drag: none;
      -khtml-user-drag: none;
      -moz-user-drag: none;
      -o-user-drag: none;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
    }
    
    #board img[draggable] {
      -webkit-user-drag: none !important;
    }

    #board img:active {
      cursor: grabbing;
    }

    /* Only show yellow border on legal move targets during drag */
    .legal-target {
      box-shadow: inset 0 0 0 3px rgba(255, 235, 59, 0.8) !important;
    }

    @keyframes legalMovePulse {
      0%, 100% { 
        opacity: 0.6; 
        transform: translate(-50%, -50%) scale(1);
      }
      50% { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1.2);
      }
    }

    /* Timers Container */
    #timers-container {
      font-family: "Inter", sans-serif;
      color: #333;
      display: none;
      flex-direction: column;
      justify-content: center;
      gap: 15px;
      user-select: none;
      background-color: white;
      border-radius: 15px;
      padding: 25px;
      border: 1px solid #e9ecef;
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.1);
      min-width: 250px;
      min-height: 150px;
      visibility: visible !important;
    }

    #timers-container div {
      font-size: 1.2em;
      font-weight: 600;
      padding: 15px;
      background-color: #f8f9fa;
      border-radius: 10px;
      border-left: 4px solid #3498db;
      transition: all 0.3s ease;
    }
    
    .time-slot {
      display: block !important;
      visibility: visible !important;
    }

    #timers-container div:hover {
      background-color: #e9ecef;
      transform: translateX(3px);
    }

    /* Move Timer */
    #move-timer-container {
      text-align: center;
      margin: 0;
      font-family: "Inter", sans-serif;
      font-size: 1.3em;
      font-weight: 600;
      user-select: none;
      color: #2c3e50;
      background-color: white;
      border-radius: 15px;
      padding: 20px;
      border: 1px solid #e9ecef;
      max-width: 300px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    /* Last Move Container */
    #last-move-container {
      text-align: center;
      margin: 0;
      font-family: "Inter", sans-serif;
      font-size: 1.2em;
      font-weight: 600;
      color: #2c3e50;
      user-select: none;
      background-color: white;
      border-radius: 15px;
      padding: 20px;
      border: 1px solid #e9ecef;
      max-width: 500px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    #turn-color {
      color: #3498db;
      font-weight: 700;
    }

    #last-move {
      color: #e74c3c;
      font-weight: 700;
    }

    /* Game Statistics Panel */
    #game-stats-panel {
      background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
      padding: 15px;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
      margin: 15px auto;
      max-width: 600px;
      border: 1px solid rgba(52, 152, 219, 0.1);
      font-family: 'Inter', sans-serif;
      display: none;
    }

    #game-stats-panel h3 {
      text-align: center;
      font-size: 1.05rem;
      font-weight: 600;
      color: #2c3e50;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 2px solid #e9ecef;
    }

    .stats-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 10px;
      margin-bottom: 6px;
      background: white;
      border-radius: 6px;
      border-left: 2px solid #3498db;
    }

    .stats-label {
      font-weight: 600;
      color: #2c3e50;
      font-size: 0.9em;
    }

    .stats-value {
      font-weight: 500;
      color: #7f8c8d;
      font-size: 0.9em;
    }

    .captured-pieces {
      display: flex;
      gap: 5px;
      align-items: center;
      flex-wrap: wrap;
    }

    .captured-piece {
      width: 30px;
      height: 30px;
      display: inline-block;
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
    }

    /* Main game container with vertical layout */
    #game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
      margin: 20px auto;
      max-width: 1400px;
    }

    #board-row {
      display: flex;
      justify-content: center;
      align-items: flex-start;
      gap: 25px;
      align-items: flex-start;
    }
    
    /* Ensure board container has flexible height to accommodate flip button */
    #board-timers-container {
      min-height: 450px;
      height: auto;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;
    }

    /* Captured pieces beside board */
    #board-with-captures {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 20px;
    }

    #captured-pieces-left {
      display: flex;
      flex-direction: column;
      gap: 30px;
      min-width: 80px;
    }

    #right-panel {
      display: flex;
      flex-direction: column;
      gap: 15px;
      min-width: 350px;
      max-width: 400px;
      height: 450px;
      overflow-y: auto;
      overflow-x: hidden;
      align-self: flex-start;
    }

    #right-panel > div,
    #right-panel > button {
      margin: 0;
    }

    #game-buttons {
      display: flex;
      gap: 10px;
      justify-content: center;
    }

    #game-buttons button {
      flex: 1;
      min-width: 0;
    }
    
    #board-timers-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      min-height: 450px;
      height: auto;
      justify-content: flex-start;
      align-self: flex-start;
    }

    .captured-section {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
      background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
      border-radius: 10px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
    }

    .captured-section-title {
      font-family: 'Inter', sans-serif;
      font-size: 0.75em;
      font-weight: 600;
      color: #7f8c8d;
      margin-bottom: 8px;
      text-align: center;
    }

    .captured-pieces-display {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      max-width: 70px;
      justify-content: center;
    }

    .material-advantage {
      font-weight: 700;
      font-size: 1.1em;
    }

    .material-advantage.positive {
      color: #2ecc71;
    }

    .material-advantage.negative {
      color: #e74c3c;
    }

    #right-panel {
      display: flex;
      flex-direction: column;
      gap: 15px;
      min-width: 350px;
      max-width: 400px;
      height: 450px;
      overflow-y: auto;
      overflow-x: hidden;
      align-self: flex-start;
    }

    #right-panel > div,
    #right-panel > button {
      margin: 0;
    }

    .material-advantage.equal {
      color: #7f8c8d;
    }

    /* Opening Book Display */
    #opening-display {
      background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
      padding: 12px 15px;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
      margin: 15px auto;
      max-width: 600px;
      text-align: center;
      border: 1px solid rgba(52, 152, 219, 0.1);
      display: none;
    }

    #opening-display .opening-label {
      font-family: 'Inter', sans-serif;
      font-size: 0.8em;
      font-weight: 500;
      color: #7f8c8d;
      margin-bottom: 4px;
    }

    #opening-display .opening-name {
      font-family: 'Inter', sans-serif;
      font-size: 1.1em;
      font-weight: 700;
      color: #3498db;
    }

    /* Export PGN Button */
    #export-pgn-btn {
      background-color: #2ecc71;
      color: white;
      padding: 12px 24px;
      border: none;
      border-radius: 20px;
      cursor: pointer;
      font-family: 'Inter', sans-serif;
      font-weight: 600;
      font-size: 1em;
      box-shadow: 0 4px 12px rgba(46, 204, 113, 0.2);
      transition: all 0.3s ease;
      margin: 10px auto;
      display: none;
    }

    #export-pgn-btn:hover {
      background-color: #27ae60;
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(46, 204, 113, 0.3);
    }
    
    /* Resign Button */
    #resign-btn {
      background-color: #e74c3c;
      color: white;
      padding: 12px 24px;
      border: none;
      border-radius: 20px;
      cursor: pointer;
      font-family: 'Inter', sans-serif;
      font-weight: 600;
      font-size: 1em;
      box-shadow: 0 4px 12px rgba(231, 76, 60, 0.2);
      transition: all 0.3s ease;
      margin: 10px auto;
      display: none;
    }

    #resign-btn:hover {
      background-color: #c0392b;
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(231, 76, 60, 0.3);
    }

    /* Board square highlighting */
    .highlight-last-move {
      background-color: rgba(255, 235, 59, 0.4) !important;
    }

    .highlight-check {
      background-color: rgba(231, 76, 60, 0.5) !important;
      animation: checkPulse 1s ease-in-out infinite;
    }

    @keyframes checkPulse {
      0%, 100% { 
        background-color: rgba(231, 76, 60, 0.5) !important;
      }
      50% { 
        background-color: rgba(231, 76, 60, 0.7) !important;
      }
    }

    /* Illegal move animation */
    @keyframes illegalMoveBlink {
      0%, 100% { 
        background-color: transparent;
        box-shadow: none;
      }
      50% {
        background-color: rgba(231, 76, 60, 0.4) !important;
        box-shadow: inset 0 0 10px rgba(231, 76, 60, 0.5) !important;
      }
    }

    .square-55d63.illegal-move {
      animation: illegalMoveBlink 0.4s ease-in-out !important;
    }

    /* Premove highlighting - medium red between dark and light for both source and destination */
    #board .square-55d63.premove-highlight,
    #board div.premove-highlight {
      background-color: rgba(215, 57, 65, 0.65) !important; /* Medium red between dark and light */
      box-shadow: inset 0 0 0 4px rgba(190, 40, 47, 0.9) !important;
    }
    
    /* Premove source highlighting (same color as destination) */
    #board .square-55d63.premove-source,
    #board div.premove-source {
      background-color: rgba(215, 57, 65, 0.65) !important; /* Same medium red */
      box-shadow: inset 0 0 0 4px rgba(190, 40, 47, 0.9) !important;
    }
    
    /* Override all board theme colors for premove squares */
    #board .premove-highlight.white-1e1d7,
    #board .premove-source.white-1e1d7,
    #board .premove-highlight.black-3c85d,
    #board .premove-source.black-3c85d {
      background-color: rgba(215, 57, 65, 0.65) !important;
      box-shadow: inset 0 0 0 4px rgba(190, 40, 47, 0.9) !important;
    }


    @keyframes slideInRight {
      from {
        transform: translateX(400px);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes slideOutRight {
      from {
        transform: translateX(0);
        opacity: 1;
      }
      to {
        transform: translateX(400px);
        opacity: 0;
      }
    }

    /* Rematch Modal */
    #rematch-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 10001;
      animation: fadeIn 0.3s ease-out;
      justify-content: center;
      align-items: center;
    }

    #rematch-modal.show {
      display: flex;
    }

    .rematch-dialog {
      background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
      border-radius: 16px;
      padding: 30px 35px;
      box-shadow: 
        0 12px 40px rgba(0, 0, 0, 0.3),
        0 0 0 1px rgba(0, 0, 0, 0.05),
        0 0 60px rgba(52, 152, 219, 0.2);
      min-width: 320px;
      max-width: 400px;
      position: relative;
      border: 3px solid #3498db;
      text-align: center;
    }

    .rematch-dialog h3 {
      margin: 0 0 12px 0;
      color: #2c3e50;
      font-family: 'Inter', sans-serif;
      font-size: 1.4em;
      font-weight: 700;
    }

    .rematch-dialog p {
      margin: 0 0 25px 0;
      color: #555;
      font-family: 'Inter', sans-serif;
      font-size: 1.05em;
      line-height: 1.5;
    }

    .rematch-buttons {
      display: flex;
      gap: 12px;
      justify-content: center;
    }

    .rematch-buttons button {
      flex: 1;
      padding: 12px 20px;
      border: none;
      border-radius: 10px;
      font-family: 'Inter', sans-serif;
      font-size: 1em;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .rematch-buttons .rematch-yes {
      background: linear-gradient(135deg, #3498db, #2980b9);
      color: white;
      box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
    }

    .rematch-buttons .rematch-yes:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(52, 152, 219, 0.4);
      background: linear-gradient(135deg, #2980b9, #1f6391);
    }

    .rematch-buttons .rematch-no {
      background: linear-gradient(135deg, #ecf0f1, #bdc3c7);
      color: #555;
    }

    .rematch-buttons .rematch-no:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(189, 195, 199, 0.4);
    }

    @keyframes rematchPopIn {
      from { 
        opacity: 0;
        transform: translateY(-20px) scale(0.9);
      }
      to { 
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    /* Reset Confirmation Modal */
    #reset-confirm-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 10010;
      animation: fadeIn 0.3s ease-out;
      justify-content: center;
      align-items: center;
    }

    #reset-confirm-modal.show {
      display: flex;
    }

    .reset-confirm-dialog {
      background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
      border-radius: 16px;
      padding: 30px 35px;
      box-shadow: 
        0 12px 40px rgba(0, 0, 0, 0.3),
        0 0 0 1px rgba(0, 0, 0, 0.05),
        0 0 60px rgba(231, 76, 60, 0.2);
      min-width: 350px;
      max-width: 450px;
      position: relative;
      border: 3px solid #e74c3c;
      text-align: center;
    }

    .reset-confirm-dialog h3 {
      margin: 0 0 12px 0;
      color: #e74c3c;
      font-family: 'Inter', sans-serif;
      font-size: 1.4em;
      font-weight: 700;
    }

    .reset-confirm-dialog p {
      margin: 0 0 20px 0;
      color: #555;
      font-family: 'Inter', sans-serif;
      font-size: 1.05em;
      line-height: 1.5;
    }

    .reset-confirm-dialog ul {
      text-align: left;
      margin: 15px 0 20px 0;
      padding-left: 25px;
      color: #666;
      font-family: 'Inter', sans-serif;
      font-size: 0.95em;
      line-height: 1.6;
    }

    .reset-confirm-input {
      width: 100%;
      padding: 12px;
      margin: 15px 0 20px 0;
      border: 2px solid #ddd;
      border-radius: 8px;
      font-family: 'Inter', sans-serif;
      font-size: 1em;
      text-align: center;
      text-transform: uppercase;
      box-sizing: border-box;
    }

    .reset-confirm-input:focus {
      outline: none;
      border-color: #e74c3c;
      box-shadow: 0 0 8px rgba(231, 76, 60, 0.3);
    }

    .reset-confirm-buttons {
      display: flex;
      gap: 12px;
      justify-content: center;
    }

    .reset-confirm-buttons button {
      flex: 1;
      padding: 12px 20px;
      border: none;
      border-radius: 10px;
      font-family: 'Inter', sans-serif;
      font-size: 1em;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .reset-confirm-buttons .reset-confirm-yes {
      background: linear-gradient(135deg, #e74c3c, #c0392b);
      color: white;
      box-shadow: 0 4px 12px rgba(231, 76, 60, 0.3);
    }

    .reset-confirm-buttons .reset-confirm-yes:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(231, 76, 60, 0.4);
      background: linear-gradient(135deg, #c0392b, #a93226);
    }

    .reset-confirm-buttons .reset-confirm-no {
      background: linear-gradient(135deg, #ecf0f1, #bdc3c7);
      color: #555;
      box-shadow: 0 4px 12px rgba(189, 195, 199, 0.3);
    }

    .reset-confirm-buttons .reset-confirm-no:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(189, 195, 199, 0.4);
      background: linear-gradient(135deg, #bdc3c7, #95a5a6);
    }

    /* All Achievements Modal */
    #all-achievements-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 10005;
      animation: fadeIn 0.3s ease-out;
      overflow-y: auto;
    }

    #all-achievements-modal.show {
      display: block;
    }

    .all-achievements-dialog {
      background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
      margin: 1% auto;
      width: 98%;
      max-width: 98%;
      height: 98vh;
      max-height: 98vh;
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      padding: 30px;
      position: relative;
      animation: slideDown 0.4s ease-out;
      display: flex;
      flex-direction: column;
      box-sizing: border-box;
    }

    .achievements-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 25px;
      padding-bottom: 15px;
      border-bottom: 3px solid #3498db;
      flex-shrink: 0;
    }

    .achievements-header h2 {
      margin: 0;
      font-family: 'Inter', sans-serif;
      font-size: 2em;
      font-weight: 700;
      color: #2c3e50;
    }

    .close-achievements-btn {
      background: #e74c3c;
      color: white;
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      font-size: 1.5em;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
    }

    .close-achievements-btn:hover {
      background: #c0392b;
      transform: rotate(90deg) scale(1.1);
    }

    .achievements-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 15px;
      overflow-y: auto;
      padding-right: 10px;
      flex: 1;
      min-height: 0;
    }

    .achievement-card {
      background: white;
      border-radius: 12px;
      padding: 15px;
      border: 2px solid #e9ecef;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .achievement-card.unlocked {
      border-color: #2ecc71;
      background: linear-gradient(145deg, #ffffff 0%, #f0fdf4 100%);
      box-shadow: 0 4px 12px rgba(46, 204, 113, 0.2);
    }

    .achievement-card.unlocked::before {
      content: 'âœ“';
      position: absolute;
      top: 10px;
      right: 10px;
      color: #2ecc71;
      font-size: 1.5em;
      font-weight: 700;
    }

    .achievement-card.locked {
      opacity: 0.5;
      filter: grayscale(0.7);
    }

    .achievement-card:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
    }

    .achievement-name {
      font-size: 1.1em;
      font-weight: 700;
      color: #2c3e50;
      margin-bottom: 8px;
      font-family: 'Inter', sans-serif;
    }

    .achievement-desc {
      font-size: 0.9em;
      color: #7f8c8d;
      margin-bottom: 8px;
      font-family: 'Inter', sans-serif;
    }

    .achievement-progress {
      font-size: 0.85em;
      color: #3498db;
      font-weight: 600;
      font-family: 'Inter', sans-serif;
    }

    .achievement-progress-bar {
      width: 100%;
      height: 6px;
      background: #e9ecef;
      border-radius: 3px;
      margin-top: 8px;
      overflow: hidden;
    }

    .achievement-progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #3498db, #2ecc71);
      border-radius: 3px;
      transition: width 0.3s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Custom Confirmation Modal */
    #confirm-modal {
      display: none;
      position: fixed;
      z-index: 10000;
      animation: popIn 0.2s ease-out;
    }

    #confirm-modal.show {
      display: block;
    }

    .confirm-dialog {
      background: white;
      border-radius: 12px;
      padding: 20px 25px;
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.25), 0 0 0 1px rgba(0, 0, 0, 0.05);
      min-width: 280px;
      max-width: 320px;
      position: relative;
      border: 2px solid #e74c3c;
    }

    .confirm-dialog::after {
      content: '';
      position: absolute;
      bottom: -10px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 10px solid transparent;
      border-right: 10px solid transparent;
      border-top: 10px solid #e74c3c;
    }

    .confirm-dialog::before {
      content: '';
      position: absolute;
      bottom: -8px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 9px solid transparent;
      border-right: 9px solid transparent;
      border-top: 9px solid white;
      z-index: 1;
    }

    .confirm-dialog h3 {
      margin: 0 0 10px 0;
      color: #e74c3c;
      font-family: 'Inter', sans-serif;
      font-size: 1.1em;
      font-weight: 600;
    }

    .confirm-dialog p {
      margin: 0 0 15px 0;
      color: #555;
      font-family: 'Inter', sans-serif;
      font-size: 0.95em;
      line-height: 1.4;
    }

    .confirm-buttons {
      display: flex;
      gap: 10px;
      justify-content: stretch;
    }

    .confirm-buttons button {
      flex: 1;
      padding: 8px 16px;
      border: none;
      border-radius: 8px;
      font-family: 'Inter', sans-serif;
      font-size: 0.9em;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .confirm-buttons .confirm-yes {
      background: linear-gradient(135deg, #e74c3c, #c0392b);
      color: white;
    }

    .confirm-buttons .confirm-yes:hover {
      transform: translateY(-1px);
      box-shadow: 0 3px 8px rgba(231, 76, 60, 0.4);
    }

    .confirm-buttons .confirm-no {
      background: linear-gradient(135deg, #ecf0f1, #bdc3c7);
      color: #555;
    }

    .confirm-buttons .confirm-no:hover {
      transform: translateY(-1px);
      box-shadow: 0 3px 8px rgba(189, 195, 199, 0.4);
    }

    @keyframes popIn {
      from { 
        opacity: 0;
        transform: translateY(10px) scale(0.95);
      }
      to { 
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    @keyframes victoryPulse {
      0%, 100% { transform: scale(1); filter: brightness(1); }
      10% { transform: scale(1.08) rotate(2deg); box-shadow: 0 0 60px rgba(46, 204, 113, 1), 0 0 100px rgba(46, 204, 113, 0.8); filter: brightness(1.3) saturate(1.2); }
      20% { transform: scale(0.95) rotate(-2deg); box-shadow: 0 0 80px rgba(46, 204, 113, 1), 0 0 120px rgba(46, 204, 113, 0.9); filter: brightness(1.4) saturate(1.3); }
      30% { transform: scale(1.05) rotate(1deg); box-shadow: 0 0 70px rgba(46, 204, 113, 1), 0 0 110px rgba(46, 204, 113, 0.85); filter: brightness(1.35) saturate(1.25); }
      40% { transform: scale(0.98) rotate(-1deg); box-shadow: 0 0 65px rgba(46, 204, 113, 1), 0 0 105px rgba(46, 204, 113, 0.8); filter: brightness(1.3) saturate(1.2); }
      50% { transform: scale(1.03) rotate(0.5deg); box-shadow: 0 0 75px rgba(46, 204, 113, 1), 0 0 115px rgba(46, 204, 113, 0.9); filter: brightness(1.4) saturate(1.3); }
      60% { transform: scale(0.99) rotate(-0.5deg); box-shadow: 0 0 70px rgba(46, 204, 113, 1), 0 0 110px rgba(46, 204, 113, 0.85); filter: brightness(1.35) saturate(1.25); }
      70% { transform: scale(1.02) rotate(0.3deg); box-shadow: 0 0 68px rgba(46, 204, 113, 1), 0 0 108px rgba(46, 204, 113, 0.8); filter: brightness(1.3) saturate(1.2); }
      80% { transform: scale(1) rotate(0deg); box-shadow: 0 0 50px rgba(46, 204, 113, 0.9), 0 0 90px rgba(46, 204, 113, 0.7); filter: brightness(1.2) saturate(1.1); }
      90% { transform: scale(1.01) rotate(0deg); box-shadow: 0 0 40px rgba(46, 204, 113, 0.8), 0 0 80px rgba(46, 204, 113, 0.6); filter: brightness(1.1) saturate(1.05); }
    }

    @keyframes sparkle {
      0% { opacity: 0; transform: scale(0) rotate(0deg); }
      20% { opacity: 1; transform: scale(1.5) rotate(90deg); }
      50% { opacity: 1; transform: scale(1) rotate(180deg); }
      80% { opacity: 0.8; transform: scale(0.8) rotate(270deg); }
      100% { opacity: 0; transform: scale(0) rotate(360deg); }
    }

    @keyframes firework {
      0% { 
        opacity: 1; 
        transform: scale(0) translateY(0);
      }
      50% { 
        opacity: 1; 
        transform: scale(1) translateY(-50px);
      }
      100% { 
        opacity: 0; 
        transform: scale(2) translateY(-100px);
      }
    }

    @keyframes ripple {
      0% {
        transform: scale(0);
        opacity: 1;
      }
      100% {
        transform: scale(4);
        opacity: 0;
      }
    }

    @keyframes screenFlash {
      0%, 100% { opacity: 0; }
      10% { opacity: 0.3; }
      20% { opacity: 0; }
      30% { opacity: 0.4; }
      40% { opacity: 0; }
      50% { opacity: 0.2; }
    }

    @keyframes textPop {
      0% { transform: scale(0) rotate(-180deg); opacity: 0; }
      50% { transform: scale(1.2) rotate(0deg); opacity: 1; }
      100% { transform: scale(1) rotate(0deg); opacity: 1; }
    }

    @keyframes particleTrail {
      0% { 
        transform: translate(0, 0) scale(1);
        opacity: 1;
      }
      100% { 
        transform: translate(var(--tx), var(--ty)) scale(0);
        opacity: 0;
      }
    }

    @keyframes defeatShake {
      0%, 100% { transform: translateX(0) rotate(0deg) scale(1); }
      5% { transform: translateX(-15px) rotate(-2deg) scale(0.98); }
      10% { transform: translateX(15px) rotate(2deg) scale(1.02); }
      15% { transform: translateX(-15px) rotate(-2deg) scale(0.98); }
      20% { transform: translateX(15px) rotate(2deg) scale(1.02); }
      25% { transform: translateX(-12px) rotate(-1.5deg) scale(0.99); }
      30% { transform: translateX(12px) rotate(1.5deg) scale(1.01); }
      35% { transform: translateX(-12px) rotate(-1.5deg) scale(0.99); }
      40% { transform: translateX(12px) rotate(1.5deg) scale(1.01); }
      50% { transform: translateX(-8px) rotate(-1deg) scale(1); }
      60% { transform: translateX(8px) rotate(1deg) scale(1); }
      70% { transform: translateX(-5px) rotate(-0.5deg) scale(1); }
      80% { transform: translateX(5px) rotate(0.5deg) scale(1); }
      90% { transform: translateX(-2px) rotate(0deg) scale(1); }
    }

    @keyframes defeatPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(0.95); }
    }

    @keyframes defeatFlash {
      0% { opacity: 0; }
      5% { opacity: 0.6; }
      10% { opacity: 0.2; }
      15% { opacity: 0.7; }
      20% { opacity: 0.1; }
      25% { opacity: 0.6; }
      30% { opacity: 0.2; }
      35% { opacity: 0.5; }
      40% { opacity: 0.1; }
      50% { opacity: 0.4; }
      60% { opacity: 0.1; }
      70% { opacity: 0.3; }
      100% { opacity: 0; }
    }

    @keyframes kingFall {
      0% { 
        transform: rotate(0deg) translateY(0);
        opacity: 1;
      }
      50% {
        transform: rotate(45deg) translateY(5px);
        opacity: 1;
      }
      100% { 
        transform: rotate(90deg) translateY(15px);
        opacity: 0.6;
      }
    }

    /* Checkmate Celebration */
    .confetti {
      position: fixed;
      width: 10px;
      height: 10px;
      background: #f0f;
      z-index: 9999;
      border-radius: 50%;
    }

    .confetti.rect {
      border-radius: 2px;
    }

    .confetti.star {
      clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
    }

    .sparkle {
      position: fixed;
      width: 20px;
      height: 20px;
      background: radial-gradient(circle, rgba(255, 215, 0, 1) 0%, rgba(255, 215, 0, 0) 70%);
      border-radius: 50%;
      z-index: 10000;
      pointer-events: none;
    }

    .firework {
      position: fixed;
      width: 8px;
      height: 8px;
      background: radial-gradient(circle, rgba(255, 255, 255, 1) 0%, rgba(255, 200, 0, 0.8) 50%, transparent 100%);
      border-radius: 50%;
      z-index: 10001;
      pointer-events: none;
    }

    .ripple {
      position: fixed;
      border: 3px solid rgba(46, 204, 113, 0.6);
      border-radius: 50%;
      z-index: 9998;
      pointer-events: none;
    }

    .particle {
      position: fixed;
      width: 4px;
      height: 4px;
      background: rgba(255, 255, 255, 0.9);
      border-radius: 50%;
      z-index: 10002;
      pointer-events: none;
    }

    .victory-text {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 4rem;
      font-weight: 900;
      color: #2ecc71;
      text-shadow: 
        0 0 20px rgba(46, 204, 113, 1),
        0 0 40px rgba(46, 204, 113, 0.8),
        0 0 60px rgba(46, 204, 113, 0.6),
        0 0 80px rgba(46, 204, 113, 0.4);
      z-index: 10003;
      pointer-events: none;
      font-family: 'Inter', sans-serif;
      letter-spacing: 0.2em;
      text-transform: uppercase;
    }

    .defeat-text {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 4rem;
      font-weight: 900;
      color: #e74c3c;
      text-shadow: 
        0 0 20px rgba(231, 76, 60, 1),
        0 0 40px rgba(231, 76, 60, 0.8),
        0 0 60px rgba(231, 76, 60, 0.6);
      z-index: 10003;
      pointer-events: none;
      font-family: 'Inter', sans-serif;
      letter-spacing: 0.2em;
      text-transform: uppercase;
    }

    @keyframes confetti-fall {
      0% {
        transform: translateY(0) rotate(0deg) translateX(0);
        opacity: 1;
      }
      100% {
        transform: translateY(100vh) rotate(720deg) translateX(var(--drift, 0px));
        opacity: 0;
      }
    }

    @keyframes confetti-burst {
      0% {
        transform: translate(0, 0) scale(1) rotate(0deg);
        opacity: 1;
      }
      100% {
        transform: translate(var(--tx, 0), var(--ty, 0)) scale(0) rotate(720deg);
        opacity: 0;
      }
    }

    @keyframes drawPulse {
      0%, 100% { 
        transform: scale(1); 
        filter: brightness(1);
        box-shadow: 0 0 80px rgba(243, 156, 18, 0.6), 0 0 120px rgba(230, 126, 34, 0.4);
      }
      50% { 
        transform: scale(1.02); 
        filter: brightness(1.1);
        box-shadow: 0 0 100px rgba(243, 156, 18, 0.8), 0 0 140px rgba(230, 126, 34, 0.6);
      }
    }

    @keyframes drawRipple {
      0% {
        transform: scale(0);
        opacity: 1;
      }
      100% {
        transform: scale(20);
        opacity: 0;
      }
    }

    .checkmate-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 9998;
    }

    .defeat-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, rgba(139, 0, 0, 0.3) 0%, rgba(139, 0, 0, 0.6) 100%);
      pointer-events: none;
      z-index: 9997;
      animation: defeatFlash 1.2s ease-out;
    }

    /* Move History/Notation Container */
    #notation-container {
      background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
      padding: 15px;
      border-radius: 15px;
      box-shadow: 
          0 4px 15px rgba(0, 0, 0, 0.08),
          inset 0 1px 0 rgba(255, 255, 255, 0.8);
      border: 1px solid rgba(52, 152, 219, 0.1);
      font-family: 'Roboto Mono', monospace;
      font-size: 0.85rem;
      line-height: 1.8;
      min-height: 60px;
      height: auto;
      max-height: 450px;
      transition: min-height 0.35s cubic-bezier(0.33,1,0.68,1), max-height 0.35s cubic-bezier(0.33,1,0.68,1);
      box-sizing: border-box;
      overflow-y: auto;
      overflow-x: hidden;
      display: none;
      color: #34495e;
      flex-shrink: 0;
    }
    
    #notation-container .move-item.highlighted {
      background-color: #3498db !important;
      color: white !important;
      font-weight: 600;
    }
    
    #notation-container .move-item.highlighted:hover {
      background-color: #2980b9 !important;
    }

    #notation-container::before {
      content: 'Move History (â† â†’ keys to navigate)';
      display: block;
      font-family: 'Inter', sans-serif;
      font-size: 0.95rem;
      font-weight: 600;
      color: #2c3e50;
      text-align: center;
      margin-bottom: 10px;
      opacity: 0.8;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 2px solid #e9ecef;
      position: sticky;
      top: 0;
      background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
      z-index: 1;
      margin-top: -15px;
      padding-top: 15px;
    }

    .move-pair {
      margin-bottom: 8px;
      padding: 8px 12px;
      background: white;
      border-radius: 8px;
      transition: all 0.2s ease;
    }

    .move-pair:hover {
      background: #f8f9fa;
      transform: translateX(3px);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    }

    .move-number {
      color: #7f8c8d;
      margin-right: -10px;
      font-weight: 600;
      min-width: 30px;
      display: inline-block;
    }

    .white-move {
      color: #2c3e50;
      margin-right: -10px;
      font-weight: 600;
      padding: 4px 8px;
      background: rgba(52, 152, 219, 0.08);
      border-radius: 4px;
      border-left: 3px solid #3498db;
    }

    .move-item {
      cursor: pointer;
      padding: 3px 3px;
      margin: 0;
      border-radius: 4px;
      transition: all 0.2s ease;
      display: inline-block;
    }

    .move-item:hover {
      background: rgba(52, 152, 219, 0.2);
    }

    .move-item.highlighted {
      background: #3498db;
      color: white;
      font-weight: 700;
      box-shadow: 0 2px 6px rgba(52, 152, 219, 0.4);
    }

    .black-move {
      color: #34495e;
      font-weight: 500;
      padding: 4px 8px;
      background: rgba(44, 62, 80, 0.05);
      border-radius: 4px;
      border-left: 3px solid #2c3e50;
    }

    /* Hidden State */
    #timers-container,
    #move-timer-container,
    #last-move-container,
    #notation-container {
      display: none;
    }

    /* Blindfold Mode */
    .blindfold-hidden {
      display: none !important;
    }

    #move-input-container {
      text-align: center;
      margin: 20px auto;
      padding: 20px;
      background-color: white;
      border-radius: 15px;
      border: 1px solid #e9ecef;
      max-width: 600px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    #show-history-row {
      display: none;
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      main {
        padding: 15px;
      }
      
      #board-timers-container {
        flex-direction: column;
        gap: 20px;
      }
      
      #board {
        width: 350px;
        height: 350px;
      }
      
      h2 {
        font-size: 2rem;
      }
      
      #choose-side {
        padding: 20px;
        margin: 0 10px 20px 10px;
      }
      
      .control-row {
        flex-direction: column;
        gap: 10px;
        text-align: center;
      }
      
      select, button {
        width: 200px;
        max-width: 90%;
      }
      
      #timers-container {
        min-width: 200px;
      }
    }
  </style>
</head>
<body>
    <div class="wrapper">
        <header>
            <div class="header-content">
                <a href="index.html" class="logo-link">
                    <img src="img/EagleLogo.png" alt="Ahrens Labs logo" class="header-logo">
                </a>
                <h1>Ahrens Labs</h1>
                <nav>
                    <ul>
                        <li><a href="index.html">Home</a></li>
                        <li><a href="labs.html">Labs & Projects</a></li>
                        <li><a href="contact.html">Contact</a></li>
                        <li><a href="chess_engine.html" class="active">Chess Engine</a></li>
                    </ul>
                </nav>
            </div>
        </header>
	    
	<h2>
    Play Chess against Trifang<span class="sharp">X</span>
    </h2>
  <div id="choose-side">
    <div class="control-row">
      <label for="color-select">Choose your side: </label>
      <select id="color-select">
        <option value="random">Random</option>
        <option value="white">White</option>
        <option value="black">Black</option>
      </select>
      
      <label for="time-control" style="margin-left: 15px;">Time control: </label>
      <select id="time-control">
        <option value="none">None</option>
        <option value="60">1 min</option>
        <option value="180|2">3 | 2</option>egal 
        <option value="300|0">5 min</option>
        <option value="600|0">10 min</option>
        <option value="900|5">15 | 5</option>
        <option value="3600|0">60 min</option>
      </select>
    </div>
    
    <div class="control-row style-option">
      <label for="board-style">Board Style: </label>
      <select id="board-style" onchange="changeBoardStyle()">
        <option value="classic">Classic</option>
        <option value="blue">Blue</option>
        <option value="green">Green</option>
        <option value="gray">Gray</option>
        <option value="purple">Purple</option>
        <option value="wood">Wood</option>
        <option value="coral">Coral</option>
        <option value="marble">Marble</option>
        <option value="dark">Dark</option>
        <option value="neon">Neon</option>
        <option value="emerald">Emerald</option>
        <option value="gold">Gold</option>
        <option value="ocean">Ocean</option>
        <option value="sunset">Sunset</option>
        <option value="midnight">Midnight</option>
        <option value="forest">Forest</option>
        <option value="royal">Royal</option>
        <option value="ice">Ice</option>
        <option value="cherry">Cherry</option>
        <option value="3d">3D</option>
        <option value="glass">Glass</option>
        <option value="carbon">Carbon</option>
        <option value="velvet">Velvet</option>
        <option value="stone">Stone</option>
        <option value="cyber">Cyber</option>
        <option value="luxury">Luxury</option>
      </select>
      
      <label for="piece-style" style="margin-left: 20px;">Piece Style: </label>
      <select id="piece-style" onchange="changePieceStyle()">
        <option value="wikipedia">Wikipedia</option>
        <option value="alpha">Alpha</option>
        <option value="cburnett">CBurnett</option>
        <option value="merida">Merida</option>
        <option value="pirouetti">Pirouetti</option>
        <option value="spatial">Spatial</option>
        <option value="california">California</option>
        <option value="cardinal">Cardinal</option>
        <option value="chessnut">Chessnut</option>
        <option value="chess7">Chess7</option>
        <option value="reillycraig">Reilly Craig</option>
        <option value="riohacha">Riohacha</option>
        <option value="shapes">Shapes</option>
        <option value="staunty">Staunty</option>
        <option value="tatiana">Tatiana</option>
      </select>
    </div>
    
    <div class="control-row">
      <label for="engine-style">Engine Personality:</label>
      <select id="engine-style" onchange="changeEngineStyle()">
        <option value="balanced">âš–ï¸ Balanced</option>
        <option value="aggressive">âš”ï¸ Aggressive</option>
        <option value="defensive">ðŸ›¡ï¸ Defensive</option>
        <option value="positional">ðŸŽ¯ Positional</option>
        <option value="material">ðŸ’Ž Material-Focused</option>
        <option value="tactical">âš¡ Tactical</option>
        <option value="custom">ðŸŽ›ï¸ Custom</option>
      </select>
    </div>
    
    <!-- Custom modifiers panel -->
    <div id="custom-modifiers-panel" style="display: none;">
      <div style="text-align: center; margin-bottom: 15px; font-weight: 600; color: #2c3e50;">
        Customize Engine Modifiers (0.0 - 3.0)
      </div>
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; max-width: 600px; margin: 0 auto;">
        <div class="modifier-input-group">
          <label for="mod-material">Material:</label>
          <input type="number" id="mod-material" min="0" max="3" step="0.1" value="1.0" onchange="updateCustomModifiers()">
        </div>
        <div class="modifier-input-group">
          <label for="mod-king-safety">King Safety:</label>
          <input type="number" id="mod-king-safety" min="0" max="3" step="0.1" value="1.0" onchange="updateCustomModifiers()">
        </div>
        <div class="modifier-input-group">
          <label for="mod-centralization">Centralization:</label>
          <input type="number" id="mod-centralization" min="0" max="3" step="0.1" value="1.0" onchange="updateCustomModifiers()">
        </div>
        <div class="modifier-input-group">
          <label for="mod-attack">Attack:</label>
          <input type="number" id="mod-attack" min="0" max="3" step="0.1" value="1.0" onchange="updateCustomModifiers()">
        </div>
        <div class="modifier-input-group">
          <label for="mod-piece-activity">Piece Activity:</label>
          <input type="number" id="mod-piece-activity" min="0" max="3" step="0.1" value="1.0" onchange="updateCustomModifiers()">
        </div>
        <div class="modifier-input-group">
          <label for="mod-defense">Defense:</label>
          <input type="number" id="mod-defense" min="0" max="3" step="0.1" value="1.0" onchange="updateCustomModifiers()">
        </div>
        <div class="modifier-input-group">
          <label for="mod-pawn-structure">Pawn Structure:</label>
          <input type="number" id="mod-pawn-structure" min="0" max="3" step="0.1" value="1.0" onchange="updateCustomModifiers()">
        </div>
        <div style="grid-column: 1 / -1; text-align: center; margin-top: 5px;">
          <button onclick="resetCustomModifiers()" style="padding: 8px 20px; font-size: 0.9em; background: linear-gradient(135deg, #95a5a6, #7f8c8d); border: none; border-radius: 15px; color: white; cursor: pointer; font-weight: 600;">
            Reset to 1.0
          </button>
        </div>
      </div>
    </div>
    
    <div class="control-row">
      <label for="blindfold-mode">
        <input type="checkbox" id="blindfold-mode" onchange="toggleHistoryOption()" style="margin-right: 8px;">
        Blindfold Mode
      </label>
    
      <label for="show-history" id="show-history-row" style="margin-left: 20px; display: none;">
        <input type="checkbox" id="show-history" style="margin-right: 8px;">
        Show Move History in Blindfold
      </label>
    </div>
    
    <div class="control-row">
      <label for="sound-effects">
        <input type="checkbox" id="sound-effects" checked style="margin-right: 8px;">
        ðŸ”Š Sound Effects
      </label>
    </div>
    
    <div class="control-row">
      <button onclick="startGame()">Start Game</button>
    </div>
  </div>

  <div id="game-container">
    <div style="display: flex; justify-content: center; align-items: center; gap: 20px; flex-wrap: wrap; margin: 20px auto;">
    <div id="move-timer-container">
      Time for this move: <span id="timer">00:00.00</span>
      </div>
      <div id="last-move-container">
        Turn: <span id="turn-color">White</span> | Last Move: <span id="last-move">None</span>
      </div>
    </div>

    <div id="board-row">
      <div id="board-with-captures">
        <div id="captured-pieces-left">
          <div class="captured-section" id="black-captured-section">
            <div class="captured-section-title">Black Pieces</div>
            <div class="captured-pieces-display" id="black-captures-display"></div>
          </div>
          <div class="captured-section" id="white-captured-section">
            <div class="captured-section-title">White Pieces</div>
            <div class="captured-pieces-display" id="white-captures-display"></div>
          </div>
        </div>

        <div id="board-timers-container">
          <div id="board"></div>
          <button id="flip-board-btn" onclick="flipBoard()" style="background: rgba(52, 152, 219, 0.9); color: white; border: none; border-radius: 8px; padding: 8px 12px; cursor: pointer; font-size: 0.9em; font-weight: 600; box-shadow: 0 2px 8px rgba(0,0,0,0.2); display: none; transition: all 0.3s ease; margin-top: 10px; width: 100%; max-width: 200px;" onmouseover="this.style.background='rgba(52, 152, 219, 1)'" onmouseout="this.style.background='rgba(52, 152, 219, 0.9)'">ðŸ”„ Flip Board</button>

          <div id="timers-container">
              <!-- The divs here will be reordered by JavaScript in startGame() based on playerColor. -->
              <!-- They now have IDs for easier manipulation -->
            <div id="time-slot-white" class="time-slot">
              White Time Left: <span id="white-total">--:--.--</span>
            </div>
            <div id="time-slot-black" class="time-slot">
              Black Time Left: <span id="black-total">--:--.--</span>
            </div>
          </div>
        </div>
      </div>

      <div id="right-panel">
        <div id="opening-display">
          <div class="opening-label">Opening:</div>
          <div class="opening-name" id="opening-name">-</div>
        </div>

      <div id="game-stats-panel">
        <h3>Game Statistics</h3>
        <div class="stats-row">
          <span class="stats-label">Material Balance:</span>
          <span class="stats-value material-advantage" id="material-balance">Equal</span>
        </div>
        <div class="stats-row">
          <span class="stats-label">Game Phase:</span>
          <span class="stats-value" id="game-phase">Opening</span>
        </div>
        <div class="stats-row">
          <span class="stats-label">Pieces on Board:</span>
          <span class="stats-value" id="pieces-count">32</span>
        </div>
        <div class="stats-row">
          <span class="stats-label">Check Status:</span>
          <span class="stats-value" id="check-status">None</span>
        </div>
        <div class="stats-row">
          <span class="stats-label">Castling Rights:</span>
          <span class="stats-value" id="castling-rights">Both</span>
        </div>
      </div>

      <div id="notation-container"></div>

      <div id="player-stats-panel" style="display: none; background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%); padding: 15px; border-radius: 10px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06); margin: 15px auto; max-width: 600px; border: 1px solid rgba(52, 152, 219, 0.1); font-family: 'Inter', sans-serif;">
        <h3 style="text-align: center; font-size: 1.05rem; font-weight: 600; color: #2c3e50; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 2px solid #e9ecef;">Your Statistics</h3>
        <div class="stats-row">
          <span class="stats-label">Games Played:</span>
          <span class="stats-value" id="total-games">0</span>
        </div>
        <div class="stats-row">
          <span class="stats-label">Wins:</span>
          <span class="stats-value" style="color: #2ecc71; font-weight: 700;" id="total-wins">0</span>
        </div>
        <div class="stats-row">
          <span class="stats-label">Losses:</span>
          <span class="stats-value" style="color: #e74c3c; font-weight: 700;" id="total-losses">0</span>
        </div>
        <div class="stats-row">
          <span class="stats-label">Draws:</span>
          <span class="stats-value" style="color: #7f8c8d; font-weight: 700;" id="total-draws">0</span>
        </div>
        <div class="stats-row">
          <span class="stats-label">Win Rate:</span>
          <span class="stats-value" style="font-weight: 700;" id="win-rate">0%</span>
        </div>
      </div>

      <div id="achievements-panel" style="display: none; background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%); padding: 15px; border-radius: 10px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06); margin: 15px auto; max-width: 600px; border: 1px solid rgba(52, 152, 219, 0.1); font-family: 'Inter', sans-serif;">
        <h3 style="text-align: center; font-size: 1.05rem; font-weight: 600; color: #2c3e50; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 2px solid #e9ecef;">ðŸ† Achievements</h3>
        <div style="text-align: center; margin-bottom: 12px; padding: 10px; background: linear-gradient(135deg, #f39c12, #e67e22); color: white; border-radius: 8px; font-weight: 700; font-size: 1.1em;">
          <div style="font-size: 0.85em; opacity: 0.95; margin-bottom: 4px;">Total Points</div>
          <div id="total-achievement-points" style="font-size: 1.5em;">0</div>
        </div>
        <div id="achievements-list" style="max-height: 200px; overflow-y: auto;"></div>
        <button onclick="showAllAchievements()" style="width: 100%; margin-top: 10px; padding: 10px; background: linear-gradient(135deg, #3498db, #2980b9); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 0.95em; transition: all 0.3s ease;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(52, 152, 219, 0.3)'" onmouseout="this.style.transform=''; this.style.boxShadow=''">View All Achievements</button>
      </div>

      <div id="game-buttons">
        <button id="export-pgn-btn" onclick="exportPGN()">Export Game (PGN)</button>
        <button id="resign-btn" onclick="resignGame()" style="display: none;">Resign</button>
      </div>
    </div>
  </div>

  <!-- Custom Confirmation Modal -->
  <div id="confirm-modal">
    <div class="confirm-dialog">
      <h3>âš ï¸ Resign Game?</h3>
      <p>Are you sure you want to resign? This cannot be undone.</p>
      <div class="confirm-buttons">
        <button class="confirm-no" onclick="closeConfirmModal()">Cancel</button>
        <button class="confirm-yes" onclick="confirmResign()">Resign</button>
      </div>
    </div>
  </div>

  <!-- Rematch Modal -->
  <div id="rematch-modal">
    <div class="rematch-dialog">
      <h3 id="rematch-title">Game Over</h3>
      <p id="rematch-message">Would you like to play again?</p>
      <div class="rematch-buttons">
        <button class="rematch-yes" onclick="startRematch()">ðŸ”„ Rematch</button>
        <button class="rematch-no" onclick="closeRematchModal()">Close</button>
      </div>
    </div>
  </div>

  <!-- Reset Confirmation Modal -->
  <div id="reset-confirm-modal">
    <div class="reset-confirm-dialog">
      <h3 id="reset-confirm-title">âš ï¸ Warning</h3>
      <p id="reset-confirm-message">This will reset ALL achievements and points to zero!</p>
      <div id="reset-confirm-list-container"></div>
      <input type="text" id="reset-confirm-input" class="reset-confirm-input" placeholder="Type RESET to confirm" style="display: none;">
      <div class="reset-confirm-buttons">
        <button class="reset-confirm-yes" id="reset-confirm-yes-btn">Confirm</button>
        <button class="reset-confirm-no" id="reset-confirm-no-btn">Cancel</button>
      </div>
    </div>
  </div>

  <!-- All Achievements Modal -->
  <div id="all-achievements-modal">
    <div class="all-achievements-dialog">
      <div class="achievements-header">
        <h2>ðŸ† All Achievements</h2>
        <div style="display: flex; gap: 10px; align-items: center;">
          <button id="reset-achievements-btn" style="background: #e67e22; color: white; border: none; border-radius: 8px; padding: 8px 16px; cursor: pointer; font-family: 'Inter', sans-serif; font-weight: 600; font-size: 0.9em; transition: all 0.3s ease;" onmouseover="this.style.background='#d35400'; this.style.transform='translateY(-2px)'" onmouseout="this.style.background='#e67e22'; this.style.transform=''">Reset All</button>
          <button class="close-achievements-btn" onclick="closeAllAchievements()">âœ•</button>
        </div>
      </div>
      <div id="all-achievements-list" style="flex: 1; min-height: 0; width: 100%; overflow-y: auto;"></div>
    </div>
  </div>

  <div id="move-input-container" style="display: none;">
    <input type="text" id="move-input" placeholder="Enter move (e.g., e4, Nf3, O-O)" 
           onkeypress="if(event.key === 'Enter') submitMove()"
           style="padding: 12px 18px; font-size: 1.1em; border: 2px solid #3498db; 
                  border-radius: 20px; margin-right: 10px; font-family: 'Inter', sans-serif;
                  box-shadow: 0 2px 8px rgba(52, 152, 219, 0.1);">
    <button onclick="submitMove()" 
            style="padding: 12px 24px; font-size: 1.1em; background-color: #3498db; 
                   color: white; border: none; border-radius: 20px; cursor: pointer;
                   font-family: 'Inter', sans-serif; font-weight: 600; max-width: none;">
      Submit Move
    </button>
  </div>

  <script>
    let game, board;
    let playerColor = "white";
    let timerStart = 0;
    let timerInterval = null;
    let whiteTime, blackTime, increment;
    let timeLimited = false;
    let gameOver = false;
    let blindfoldMode = false;
    let showHistoryInBlindfold = false;
    let moveHistory = [];
    let currentMoveIndex = -1;
    let capturedPieces = { white: [], black: [] };
    let lastMoveSquares = { from: null, to: null };
    let gameStartTime = null;
    let currentPieceStyle = 'wikipedia';
    let premoves = []; // Store array of premoves as [{from: 'e2', to: 'e4'}, ...]
    let premoveHighlightInterval = null; // Store interval ID for premove highlighting
    let selectedSquare = null; // Track clicked piece for click-to-move
    let currentEngineStyle = 'balanced'; // Track current engine personality
    let currentTimeControl = 'none'; // Track current time control for achievements
    let soundEnabled = true; // Sound effects toggle
    let playerStats = { wins: 0, losses: 0, draws: 0 }; // Player statistics
    let achievements = []; // Achievements unlocked
    let gameStats = { // In-game statistics for achievements (temporary, only committed when game ends)
      capturesByQueen: 0,
      capturesByRook: 0,
      capturesByBishop: 0,
      capturesByKnight: 0,
      capturesByPawn: 0,
      totalCaptures: 0,
      checksGiven: 0,
      castlingMoves: 0,
      promotions: 0,
      enPassants: 0,
      longestGame: 0,
      shortestWin: Infinity,
      // Track what pieces were captured (not what captured them)
      capturedQueens: 0,
      capturedRooks: 0,
      capturedBishops: 0,
      capturedKnights: 0,
      capturedPawns: 0,
      // Random achievement tracking
      movesToE4: 0,
      movesToD4: 0,
      movesToE5: 0,
      movesToD5: 0,
      knightToF3: 0,
      knightToC3: 0,
      knightToF6: 0,
      knightToC6: 0,
      movesOnMove1: 0,
      movesOnMove5: 0,
      movesOnMove10: 0,
      movesOnMove20: 0,
      movesOnMove50: 0,
      pawnToE4: 0,
      pawnToD4: 0,
      queenToD4: 0,
      queenToE4: 0,
      bishopToF4: 0,
      rookToE1: 0,
      kingToE1: 0,
      castledOnMove10: 0,
      castledOnMove20: 0,
      promotedToQueen: 0,
      promotedToRook: 0,
      promotedToBishop: 0,
      promotedToKnight: 0,
      checkOnMove5: 0,
      captureOnMove10: 0,
      // Additional tracking for varied requirements
      movesToE4Multiple: 0,
      movesToD4Multiple: 0,
      knightToF3Multiple: 0,
      knightToC3Multiple: 0,
      queenToD4Multiple: 0,
      promotedToQueenMultiple: 0,
      // Random piece-to-square tracking
      rookToA1: 0, rookToH1: 0, rookToA8: 0, rookToH8: 0,
      bishopToC1: 0, bishopToF1: 0, bishopToC8: 0, bishopToF8: 0,
      knightToG1: 0, knightToB1: 0, knightToG8: 0, knightToB8: 0,
      queenToA1: 0, queenToH1: 0, queenToA8: 0, queenToH8: 0,
      kingToG1: 0, kingToC1: 0, kingToG8: 0, kingToC8: 0,
      pawnToA2: 0, pawnToH2: 0, pawnToA7: 0, pawnToH7: 0,
      // Daily stats for this game
      dailyStats: {
        movesMadeToday: 0,
        capturesToday: 0,
        checksGivenToday: 0,
        uniqueSquaresVisitedToday: []
      }
    };
    
    function resetGameStats() {
      gameStats = {
        capturesByQueen: 0,
        capturesByRook: 0,
        capturesByBishop: 0,
        capturesByKnight: 0,
        capturesByPawn: 0,
        totalCaptures: 0,
        checksGiven: 0,
        castlingMoves: 0,
        promotions: 0,
        enPassants: 0,
        longestGame: 0,
        shortestWin: Infinity,
        capturedQueens: 0,
        capturedRooks: 0,
        capturedBishops: 0,
        capturedKnights: 0,
        capturedPawns: 0,
        movesToE4: 0,
        movesToD4: 0,
        movesToE5: 0,
        movesToD5: 0,
        knightToF3: 0,
        knightToC3: 0,
        knightToF6: 0,
        knightToC6: 0,
        movesOnMove1: 0,
        movesOnMove5: 0,
        movesOnMove10: 0,
        movesOnMove20: 0,
        movesOnMove50: 0,
        pawnToE4: 0,
        pawnToD4: 0,
        queenToD4: 0,
        queenToE4: 0,
        bishopToF4: 0,
        rookToE1: 0,
        kingToE1: 0,
        castledOnMove10: 0,
        castledOnMove20: 0,
        promotedToQueen: 0,
        promotedToRook: 0,
        promotedToBishop: 0,
        promotedToKnight: 0,
        checkOnMove5: 0,
        captureOnMove10: 0,
        movesToE4Multiple: 0,
        movesToD4Multiple: 0,
        knightToF3Multiple: 0,
        knightToC3Multiple: 0,
        queenToD4Multiple: 0,
        promotedToQueenMultiple: 0,
        rookToA1: 0, rookToH1: 0, rookToA8: 0, rookToH8: 0,
        bishopToC1: 0, bishopToF1: 0, bishopToC8: 0, bishopToF8: 0,
        knightToG1: 0, knightToB1: 0, knightToG8: 0, knightToB8: 0,
        queenToA1: 0, queenToH1: 0, queenToA8: 0, queenToH8: 0,
        kingToG1: 0, kingToC1: 0, kingToG8: 0, kingToC8: 0,
        pawnToA2: 0, pawnToH2: 0, pawnToA7: 0, pawnToH7: 0,
        dailyStats: {
          movesMadeToday: 0,
          capturesToday: 0,
          checksGivenToday: 0,
          uniqueSquaresVisitedToday: [],
          bishopMovesInBlindfoldToday: 0,
          currentStreakNoPiecesLost: 0, // Current streak of moves without losing pieces in this game
          hasEnPassant: false, // Track if this game had en passant
          hasUnderpromotion: false, // Track if this game had underpromotion
          promotionTypes: [], // Track types of promotions in this game (q, r, b, n)
          castlingTypes: [], // Track types of castling in this game (k for kingside, q for queenside)
          maxChecksInGame: 0, // Track max checks given in this game
          capturedPieceTypes: [], // Track types of pieces captured in this game
          // New unique daily challenge tracking
          knightMovesInPureBlindfoldToday: 0, // Knight moves in blindfold without history
          promotionsInGame: 0, // Count promotions in current game
          queenVisitedCorners: [], // Track which corners queen visited (a1, h1, a8, h8)
          rooksOnSeventhRank: 0, // Track rooks on 7th/2nd rank
          bishopsKept: 2, // Track if both bishops kept (starts at 2, decrements when lost)
          knightForks: 0, // Count knight forks in this game
          pawnsAdvancedToSixth: [], // Track which pawns reached 6th/3rd rank
          kingMoves: 0, // Count king moves in this game
          pieceTypesMoved: [], // Track which piece types moved (p, n, b, r, q, k)
          eFileSquaresVisited: [], // Track squares on e-file visited
          piecesSacrificed: [], // Track pieces sacrificed (not pawns)
          centerSquaresOccupied: [], // Track center squares occupied (d4, d5, e4, e5)
          pawnIslands: 0, // Count isolated pawn islands
          rookBatteryCreated: false, // Track if rook battery created
          pinsCreated: 0, // Count pins created
          skewersCreated: 0, // Count skewers created
          discoveredAttacks: 0, // Count discovered attacks
          consecutiveChecks: 0, // Track consecutive checks
          maxConsecutiveChecks: 0, // Max consecutive checks in this game
          zwischenzugMade: false // Track if zwischenzug made
        }
      };
    }
    
    function trackWinStats(moveCount, checkmatePiece = null) {
      // Track wins by time control
      if (currentTimeControl && lifetimeStats.winsByTimeControl) {
        if (!lifetimeStats.winsByTimeControl[currentTimeControl]) {
          lifetimeStats.winsByTimeControl[currentTimeControl] = 0;
        }
        lifetimeStats.winsByTimeControl[currentTimeControl]++;
        
        // Track wins by time control today (for daily challenges)
        if (lifetimeStats.dailyStats) {
          if (!lifetimeStats.dailyStats.winsByTimeControlToday) {
            lifetimeStats.dailyStats.winsByTimeControlToday = {};
          }
          if (!lifetimeStats.dailyStats.winsByTimeControlToday[currentTimeControl]) {
            lifetimeStats.dailyStats.winsByTimeControlToday[currentTimeControl] = 0;
          }
          lifetimeStats.dailyStats.winsByTimeControlToday[currentTimeControl]++;
        }
      }
      
      // Track wins by personality
      if (currentEngineStyle && lifetimeStats.winsByPersonality) {
        if (!lifetimeStats.winsByPersonality[currentEngineStyle]) {
          lifetimeStats.winsByPersonality[currentEngineStyle] = 0;
        }
        lifetimeStats.winsByPersonality[currentEngineStyle]++;
      }
      
      // Track wins by color
      if (playerColor === 'white') {
        lifetimeStats.winsAsWhite = (lifetimeStats.winsAsWhite || 0) + 1;
      } else {
        lifetimeStats.winsAsBlack = (lifetimeStats.winsAsBlack || 0) + 1;
      }
      
      // Track creative achievements
      if (moveCount <= 10) {
        lifetimeStats.winsInUnder10Moves = (lifetimeStats.winsInUnder10Moves || 0) + 1;
      }
      if (moveCount <= 20) {
        lifetimeStats.winsInUnder20Moves = (lifetimeStats.winsInUnder20Moves || 0) + 1;
      }
      if (moveCount >= 100) {
        lifetimeStats.winsInOver100Moves = (lifetimeStats.winsInOver100Moves || 0) + 1;
      }
      
      // Track checkmate piece
      if (checkmatePiece) {
        const pieceType = checkmatePiece.toLowerCase();
        if (pieceType === 'n') lifetimeStats.checkmateWithKnight = (lifetimeStats.checkmateWithKnight || 0) + 1;
        else if (pieceType === 'b') lifetimeStats.checkmateWithBishop = (lifetimeStats.checkmateWithBishop || 0) + 1;
        else if (pieceType === 'r') lifetimeStats.checkmateWithRook = (lifetimeStats.checkmateWithRook || 0) + 1;
        else if (pieceType === 'q') lifetimeStats.checkmateWithQueen = (lifetimeStats.checkmateWithQueen || 0) + 1;
        else if (pieceType === 'p') lifetimeStats.checkmateWithPawn = (lifetimeStats.checkmateWithPawn || 0) + 1;
        
        // Track unique checkmate pieces today (for daily challenge)
        if (lifetimeStats.dailyStats) {
          if (!lifetimeStats.dailyStats.uniqueCheckmatePiecesToday) {
            lifetimeStats.dailyStats.uniqueCheckmatePiecesToday = [];
          }
          if (!lifetimeStats.dailyStats.uniqueCheckmatePiecesToday.includes(pieceType)) {
            lifetimeStats.dailyStats.uniqueCheckmatePiecesToday.push(pieceType);
          }
        }
      }
      
      // Track perfect games (no pieces lost)
      const totalLost = (gameStats.capturedQueens || 0) + (gameStats.capturedRooks || 0) + 
                       (gameStats.capturedBishops || 0) + (gameStats.capturedKnights || 0) + 
                       (gameStats.capturedPawns || 0);
      if (totalLost === 0) {
        lifetimeStats.perfectGames = (lifetimeStats.perfectGames || 0) + 1;
        // Track perfect wins for daily challenge
        if (lifetimeStats.dailyStats) {
          lifetimeStats.dailyStats.perfectWinsToday = (lifetimeStats.dailyStats.perfectWinsToday || 0) + 1;
        }
      }
      
      // Track queen sacrifice wins (if we lost a queen but still won)
      if (gameStats.capturedQueens > 0 && lifetimeStats.dailyStats) {
        lifetimeStats.dailyStats.queenSacrificeWinsToday = (lifetimeStats.dailyStats.queenSacrificeWinsToday || 0) + 1;
      }
      
      // Track comeback wins (win after being down 5+ material points)
      // This is checked by comparing material at different points - simplified: if we won and had captured fewer pieces earlier
      // For now, we'll track this in commitGameStatsToLifetime by checking material difference
      
      // Track max checks in single game
      if (gameStats.dailyStats && gameStats.dailyStats.maxChecksInGame) {
        const currentMax = lifetimeStats.dailyStats.maxChecksInSingleGameToday || 0;
        if (gameStats.dailyStats.maxChecksInGame > currentMax) {
          lifetimeStats.dailyStats.maxChecksInSingleGameToday = gameStats.dailyStats.maxChecksInGame;
        }
      }
      
      // Track time pressure wins (won with less than 10 seconds remaining)
      if (timeLimited && lifetimeStats.dailyStats) {
        try {
          const playerTimeRemaining = playerColor === 'white' ? whiteTime : blackTime;
          if (playerTimeRemaining > 0 && playerTimeRemaining < 10) {
            lifetimeStats.dailyStats.timePressureWinsToday = (lifetimeStats.dailyStats.timePressureWinsToday || 0) + 1;
          }
        } catch (e) {
          console.error('Error tracking time pressure win:', e);
        }
      }
      
      // Track double castle games
      if (gameStats.dailyStats && gameStats.dailyStats.castlingTypes && gameStats.dailyStats.castlingTypes.length >= 2) {
        lifetimeStats.dailyStats.doubleCastleGamesToday = (lifetimeStats.dailyStats.doubleCastleGamesToday || 0) + 1;
      }
      
      // Track variety promotion games
      if (gameStats.dailyStats && gameStats.dailyStats.promotionTypes && gameStats.dailyStats.promotionTypes.length >= 2) {
        lifetimeStats.dailyStats.varietyPromotionGamesToday = (lifetimeStats.dailyStats.varietyPromotionGamesToday || 0) + 1;
      }
      
      // Track piece hunter games (captured 5 different piece types)
      if (gameStats.dailyStats && gameStats.dailyStats.capturedPieceTypes && gameStats.dailyStats.capturedPieceTypes.length >= 5) {
        lifetimeStats.dailyStats.pieceHunterGamesToday = (lifetimeStats.dailyStats.pieceHunterGamesToday || 0) + 1;
      }
      
      // Track material advantage at win (for daily challenge)
      try {
        const pieceValues = { p: 1, n: 3, b: 3, r: 5, q: 9, k: 0 };
        let whiteMaterial = 0;
        let blackMaterial = 0;
        const board = game.board();
        for (let i = 0; i < 8; i++) {
          for (let j = 0; j < 8; j++) {
            const piece = board[i][j];
            if (piece) {
              const value = pieceValues[piece.type];
              if (piece.color === 'w') {
                whiteMaterial += value;
              } else {
                blackMaterial += value;
              }
            }
          }
        }
        const materialDiff = playerColor === 'white' ? (whiteMaterial - blackMaterial) : (blackMaterial - whiteMaterial);
        if (materialDiff >= 3 && lifetimeStats.dailyStats) {
          lifetimeStats.dailyStats.winsWithMaterialAdvantageToday = (lifetimeStats.dailyStats.winsWithMaterialAdvantageToday || 0) + 1;
        }
      } catch (e) {
        console.error('Error calculating material advantage:', e);
      }
      
      // Track opening played today (for daily challenge)
      try {
        if (typeof detectOpening === 'function') {
          const opening = detectOpening();
          if (opening && lifetimeStats.dailyStats) {
            if (!lifetimeStats.dailyStats.uniqueOpeningsPlayedToday) {
              lifetimeStats.dailyStats.uniqueOpeningsPlayedToday = [];
            }
            if (!lifetimeStats.dailyStats.uniqueOpeningsPlayedToday.includes(opening)) {
              lifetimeStats.dailyStats.uniqueOpeningsPlayedToday.push(opening);
            }
          }
        }
      } catch (e) {
        console.error('Error tracking opening:', e);
      }
      
      // Track win streak
      lifetimeStats.currentWinStreak = (lifetimeStats.currentWinStreak || 0) + 1;
      if (lifetimeStats.currentWinStreak > (lifetimeStats.longestWinStreak || 0)) {
        lifetimeStats.longestWinStreak = lifetimeStats.currentWinStreak;
      }
      
      // Track blindfold wins
      if (blindfoldMode) {
        lifetimeStats.blindfoldWins = (lifetimeStats.blindfoldWins || 0) + 1;
        // Track wins without move history (harder achievement)
        if (!showHistoryInBlindfold) {
          lifetimeStats.blindfoldWinsNoHistory = (lifetimeStats.blindfoldWinsNoHistory || 0) + 1;
          // Track pure blindfold wins for daily challenge
          if (lifetimeStats.dailyStats) {
            lifetimeStats.dailyStats.pureBlindfoldWinsToday = (lifetimeStats.dailyStats.pureBlindfoldWinsToday || 0) + 1;
          }
        }
      }
      
      // Track new unique daily challenges
      if (gameStats && gameStats.dailyStats && lifetimeStats.dailyStats) {
        // Triple promotion games
        if (gameStats.dailyStats.promotionsInGame >= 3) {
          lifetimeStats.dailyStats.triplePromotionGamesToday = (lifetimeStats.dailyStats.triplePromotionGamesToday || 0) + 1;
        }
        
        // Queen tour (visited all 4 corners)
        if (gameStats.dailyStats.queenVisitedCorners && gameStats.dailyStats.queenVisitedCorners.length >= 4) {
          lifetimeStats.dailyStats.queenTourGamesToday = (lifetimeStats.dailyStats.queenTourGamesToday || 0) + 1;
        }
        
        // Rook ladder (both rooks on 7th/2nd rank)
        if (gameStats.dailyStats.rooksOnSeventhRank >= 2) {
          lifetimeStats.dailyStats.rookLadderGamesToday = (lifetimeStats.dailyStats.rookLadderGamesToday || 0) + 1;
        }
        
        // Bishop pair (kept both bishops)
        if (gameStats.dailyStats.bishopsKept >= 2) {
          lifetimeStats.dailyStats.bishopPairWinsToday = (lifetimeStats.dailyStats.bishopPairWinsToday || 0) + 1;
        }
        
        // Knight fork (3+ forks)
        if (gameStats.dailyStats.knightForks >= 3) {
          lifetimeStats.dailyStats.knightForkGamesToday = (lifetimeStats.dailyStats.knightForkGamesToday || 0) + 1;
        }
        
        // Pawn storm (5+ pawns to 6th/3rd rank)
        if (gameStats.dailyStats.pawnsAdvancedToSixth && gameStats.dailyStats.pawnsAdvancedToSixth.length >= 5) {
          lifetimeStats.dailyStats.pawnStormGamesToday = (lifetimeStats.dailyStats.pawnStormGamesToday || 0) + 1;
        }
        
        // King walk (10+ king moves)
        if (gameStats.dailyStats.kingMoves >= 10) {
          lifetimeStats.dailyStats.kingWalkGamesToday = (lifetimeStats.dailyStats.kingWalkGamesToday || 0) + 1;
        }
        
        // Piece cycle (moved all 6 piece types)
        if (gameStats.dailyStats.pieceTypesMoved && gameStats.dailyStats.pieceTypesMoved.length >= 6) {
          lifetimeStats.dailyStats.pieceCycleGamesToday = (lifetimeStats.dailyStats.pieceCycleGamesToday || 0) + 1;
        }
        
        // Square master (visited all 8 e-file squares)
        if (gameStats.dailyStats.eFileSquaresVisited && gameStats.dailyStats.eFileSquaresVisited.length >= 8) {
          lifetimeStats.dailyStats.squareMasterGamesToday = (lifetimeStats.dailyStats.squareMasterGamesToday || 0) + 1;
        }
        
        // Sacrifice chain (3+ different pieces sacrificed)
        if (gameStats.dailyStats.piecesSacrificed && gameStats.dailyStats.piecesSacrificed.length >= 3) {
          lifetimeStats.dailyStats.sacrificeChainGamesToday = (lifetimeStats.dailyStats.sacrificeChainGamesToday || 0) + 1;
        }
        
        // Center control (occupied all 4 center squares)
        if (gameStats.dailyStats.centerSquaresOccupied && gameStats.dailyStats.centerSquaresOccupied.length >= 4) {
          lifetimeStats.dailyStats.centerControlGamesToday = (lifetimeStats.dailyStats.centerControlGamesToday || 0) + 1;
        }
        
        // Pawn island (3+ isolated islands)
        if (gameStats.dailyStats.pawnIslands >= 3) {
          lifetimeStats.dailyStats.pawnIslandGamesToday = (lifetimeStats.dailyStats.pawnIslandGamesToday || 0) + 1;
        }
        
        // Rook battery
        if (gameStats.dailyStats.rookBatteryCreated) {
          lifetimeStats.dailyStats.rookBatteryGamesToday = (lifetimeStats.dailyStats.rookBatteryGamesToday || 0) + 1;
        }
        
        // Pin master (4+ pins)
        if (gameStats.dailyStats.pinsCreated >= 4) {
          lifetimeStats.dailyStats.pinMasterGamesToday = (lifetimeStats.dailyStats.pinMasterGamesToday || 0) + 1;
        }
        
        // Skewer king (2+ skewers)
        if (gameStats.dailyStats.skewersCreated >= 2) {
          lifetimeStats.dailyStats.skewerKingGamesToday = (lifetimeStats.dailyStats.skewerKingGamesToday || 0) + 1;
        }
        
        // Discovered attack (3+ discovered attacks)
        if (gameStats.dailyStats.discoveredAttacks >= 3) {
          lifetimeStats.dailyStats.discoveredAttackGamesToday = (lifetimeStats.dailyStats.discoveredAttackGamesToday || 0) + 1;
        }
        
        // Windmill (5+ consecutive checks)
        if (gameStats.dailyStats.maxConsecutiveChecks >= 5) {
          lifetimeStats.dailyStats.windmillGamesToday = (lifetimeStats.dailyStats.windmillGamesToday || 0) + 1;
        }
        
        // Zwischenzug
        if (gameStats.dailyStats.zwischenzugMade) {
          lifetimeStats.dailyStats.zwischenzugGamesToday = (lifetimeStats.dailyStats.zwischenzugGamesToday || 0) + 1;
        }
      }
      
      // Track unique personalities won against today (for daily challenge)
      if (currentEngineStyle && lifetimeStats.dailyStats) {
        if (!lifetimeStats.dailyStats.personalitiesWonToday) {
          lifetimeStats.dailyStats.personalitiesWonToday = [];
        }
        if (!lifetimeStats.dailyStats.personalitiesWonToday.includes(currentEngineStyle)) {
          lifetimeStats.dailyStats.personalitiesWonToday.push(currentEngineStyle);
        }
      }
      
      // Track longest streak without losing pieces in one game today
      if (gameStats.dailyStats && gameStats.dailyStats.currentStreakNoPiecesLost) {
        const currentStreak = gameStats.dailyStats.currentStreakNoPiecesLost || 0;
        const longestStreak = lifetimeStats.dailyStats.longestStreakNoPiecesLostToday || 0;
        if (currentStreak > longestStreak) {
          lifetimeStats.dailyStats.longestStreakNoPiecesLostToday = currentStreak;
        }
      }
      
      // Track total games
      lifetimeStats.totalGamesPlayed = (lifetimeStats.totalGamesPlayed || 0) + 1;
      
      saveLifetimeStats();
    }
    
    function trackLossStats() {
      // Reset win streak on loss
      lifetimeStats.currentWinStreak = 0;
      saveLifetimeStats();
    }
    
    function commitGameStatsToLifetime() {
      // Commit all gameStats to lifetimeStats
      resetDailyStatsIfNeeded();
      Object.keys(gameStats).forEach(key => {
        if (key === 'dailyStats') {
          // Handle daily stats separately
          lifetimeStats.dailyStats.movesMadeToday += gameStats.dailyStats.movesMadeToday || 0;
          lifetimeStats.dailyStats.capturesToday += gameStats.dailyStats.capturesToday || 0;
          lifetimeStats.dailyStats.checksGivenToday += gameStats.dailyStats.checksGivenToday || 0;
          lifetimeStats.dailyStats.promotionsToday += gameStats.dailyStats.promotionsToday || 0;
          lifetimeStats.dailyStats.castlingToday += gameStats.dailyStats.castlingToday || 0;
          lifetimeStats.dailyStats.bishopMovesInBlindfoldToday += gameStats.dailyStats.bishopMovesInBlindfoldToday || 0;
          lifetimeStats.dailyStats.knightMovesInPureBlindfoldToday += gameStats.dailyStats.knightMovesInPureBlindfoldToday || 0;
          if (gameStats.dailyStats.uniqueSquaresVisitedToday) {
            gameStats.dailyStats.uniqueSquaresVisitedToday.forEach(square => {
              if (!lifetimeStats.dailyStats.uniqueSquaresVisitedToday.includes(square)) {
                lifetimeStats.dailyStats.uniqueSquaresVisitedToday.push(square);
              }
            });
          }
        } else if (typeof gameStats[key] === 'number') {
          lifetimeStats[key] = (lifetimeStats[key] || 0) + gameStats[key];
          // Note: promotionsToday and castlingToday are already tracked per-move in gameStats.dailyStats
          // They will be added separately below, so we don't double-count here
        }
      });
      
      // Track games where we castled/promoted (once per game, not per move)
      if (gameStats.castlingMoves > 0 && lifetimeStats.dailyStats) {
        lifetimeStats.dailyStats.gamesCastledToday = (lifetimeStats.dailyStats.gamesCastledToday || 0) + 1;
      }
      if (gameStats.promotions > 0 && lifetimeStats.dailyStats) {
        lifetimeStats.dailyStats.gamesPromotedToday = (lifetimeStats.dailyStats.gamesPromotedToday || 0) + 1;
      }
      
      // Track games with en passant
      if (gameStats.dailyStats && gameStats.dailyStats.hasEnPassant && lifetimeStats.dailyStats) {
        lifetimeStats.dailyStats.gamesWithEnPassantToday = (lifetimeStats.dailyStats.gamesWithEnPassantToday || 0) + 1;
      }
      
      // Track underpromotions
      if (gameStats.dailyStats && gameStats.dailyStats.hasUnderpromotion && lifetimeStats.dailyStats) {
        lifetimeStats.dailyStats.underpromotionsToday = (lifetimeStats.dailyStats.underpromotionsToday || 0) + 1;
      }
      
      // Track comeback wins (win after being down 5+ material at some point)
      // Check if we won and had negative material difference at any point
      // Simplified: if we won and opponent captured more valuable pieces than us
      const opponentCapturedValue = (gameStats.capturedQueens || 0) * 9 + (gameStats.capturedRooks || 0) * 5 + 
                                    (gameStats.capturedBishops || 0) * 3 + (gameStats.capturedKnights || 0) * 3 + 
                                    (gameStats.capturedPawns || 0) * 1;
      const playerCapturedValue = (gameStats.capturesByQueen || 0) * 9 + (gameStats.capturesByRook || 0) * 5 + 
                                  (gameStats.capturesByBishop || 0) * 3 + (gameStats.capturesByKnight || 0) * 3 + 
                                  (gameStats.capturesByPawn || 0) * 1;
      // If opponent captured 5+ more points worth of material, it's a comeback
      if (opponentCapturedValue - playerCapturedValue >= 5 && lifetimeStats.dailyStats) {
        lifetimeStats.dailyStats.comebackWinsToday = (lifetimeStats.dailyStats.comebackWinsToday || 0) + 1;
      }
      
      saveLifetimeStats();
      // Reset gameStats after committing
      resetGameStats();
    }
    let lifetimeStats = { // Lifetime statistics
      capturesByQueen: 0,
      capturesByRook: 0,
      capturesByBishop: 0,
      capturesByKnight: 0,
      capturesByPawn: 0,
      totalCaptures: 0,
      checksGiven: 0,
      castlingMoves: 0,
      promotions: 0,
      enPassants: 0,
      longestGame: 0,
      shortestWin: Infinity,
      // Track what pieces were captured (not what captured them)
      capturedQueens: 0,
      capturedRooks: 0,
      capturedBishops: 0,
      capturedKnights: 0,
      capturedPawns: 0,
      // Random achievement tracking
      movesToE4: 0,
      movesToD4: 0,
      movesToE5: 0,
      movesToD5: 0,
      knightToF3: 0,
      knightToC3: 0,
      knightToF6: 0,
      knightToC6: 0,
      movesOnMove1: 0,
      movesOnMove5: 0,
      movesOnMove10: 0,
      movesOnMove20: 0,
      movesOnMove50: 0,
      pawnToE4: 0,
      pawnToD4: 0,
      queenToD4: 0,
      queenToE4: 0,
      bishopToF4: 0,
      rookToE1: 0,
      kingToE1: 0,
      consecutiveSamePiece: 0,
      castledOnMove10: 0,
      castledOnMove20: 0,
      promotedToQueen: 0,
      promotedToRook: 0,
      promotedToBishop: 0,
      promotedToKnight: 0,
      checkOnMove5: 0,
      captureOnMove10: 0,
      // Additional tracking for varied requirements
      movesToE4Multiple: 0,
      movesToD4Multiple: 0,
      knightToF3Multiple: 0,
      knightToC3Multiple: 0,
      queenToD4Multiple: 0,
      promotedToQueenMultiple: 0,
      // Random piece-to-square tracking
      rookToA1: 0, rookToH1: 0, rookToA8: 0, rookToH8: 0,
      bishopToC1: 0, bishopToF1: 0, bishopToC8: 0, bishopToF8: 0,
      knightToG1: 0, knightToB1: 0, knightToG8: 0, knightToB8: 0,
      queenToA1: 0, queenToH1: 0, queenToA8: 0, queenToH8: 0,
      kingToG1: 0, kingToC1: 0, kingToG8: 0, kingToC8: 0,
      pawnToA2: 0, pawnToH2: 0, pawnToA7: 0, pawnToH7: 0,
      // Daily achievement tracking
      dailyStats: {
        lastResetDate: null,
        gamesPlayedToday: 0,
        gamesWonToday: 0,
        movesMadeToday: 0,
        capturesToday: 0,
        checksGivenToday: 0,
        uniqueSquaresVisitedToday: [],
        longestGameToday: 0,
        fastestWinToday: Infinity,
        promotionsToday: 0,
        castlingToday: 0,
        todayDailyIds: [],
        // New daily challenge tracking
        bishopMovesInBlindfoldToday: 0,
        personalitiesWonToday: [], // Array of unique personality IDs won against today
        longestStreakNoPiecesLostToday: 0 // Longest streak of moves without losing pieces in one game today
      },
      // Wins by time control
      winsByTimeControl: {
        none: 0,
        '60': 0,
        '180|2': 0,
        '300|0': 0,
        '600|0': 0,
        '900|5': 0,
        '3600|0': 0
      },
      // Wins by engine personality
      winsByPersonality: {
        balanced: 0,
        aggressive: 0,
        defensive: 0,
        positional: 0,
        material: 0,
        tactical: 0,
        custom: 0
      },
      // Creative achievement tracking
      winsInUnder10Moves: 0,
      winsInUnder20Moves: 0,
      winsInOver100Moves: 0,
      perfectGames: 0, // Games won without losing any pieces
      comebackWins: 0, // Games won after being down material
      longestWinStreak: 0,
      currentWinStreak: 0,
      // Blindfold achievement tracking
      blindfoldWins: 0, // Total wins in blindfold mode (with or without history)
      blindfoldWinsNoHistory: 0 // Wins in blindfold mode without move history
    };

    // Engine personality presets
    const enginePersonalities = {
      balanced: {
        material: 1.0,
        king_safety_b: 1.0, king_safety_w: 1.0,
        centralization_b: 1.0, centralization_w: 1.0,
        attack_b: 1.0, attack_w: 1.0,
        piece_activity_b: 1.0, piece_activity_w: 1.0,
        defense_b: 1.0, defense_w: 1.0,
        pawn_structure_b: 1.0, pawn_structure_w: 1.0
      },
      aggressive: {
        material: 0.7,
        king_safety_b: 0.5, king_safety_w: 0.5,
        centralization_b: 1.5, centralization_w: 1.5,
        attack_b: 2.5, attack_w: 2.5,
        piece_activity_b: 1.8, piece_activity_w: 1.8,
        defense_b: 0.4, defense_w: 0.4,
        pawn_structure_b: 0.6, pawn_structure_w: 0.6
      },
      defensive: {
        material: 1.2,
        king_safety_b: 2.2, king_safety_w: 2.2,
        centralization_b: 0.7, centralization_w: 0.7,
        attack_b: 0.5, attack_w: 0.5,
        piece_activity_b: 0.6, piece_activity_w: 0.6,
        defense_b: 2.0, defense_w: 2.0,
        pawn_structure_b: 1.8, pawn_structure_w: 1.8
      },
      positional: {
        material: 0.8,
        king_safety_b: 1.4, king_safety_w: 1.4,
        centralization_b: 2.0, centralization_w: 2.0,
        attack_b: 0.7, attack_w: 0.7,
        piece_activity_b: 1.5, piece_activity_w: 1.5,
        defense_b: 1.6, defense_w: 1.6,
        pawn_structure_b: 1.9, pawn_structure_w: 1.9
      },
      material: {
        material: 2.5,
        king_safety_b: 0.7, king_safety_w: 0.7,
        centralization_b: 0.6, centralization_w: 0.6,
        attack_b: 0.9, attack_w: 0.9,
        piece_activity_b: 0.5, piece_activity_w: 0.5,
        defense_b: 0.7, defense_w: 0.7,
        pawn_structure_b: 1.1, pawn_structure_w: 1.1
      },
      tactical: {
        material: 0.9,
        king_safety_b: 0.6, king_safety_w: 0.6,
        centralization_b: 1.6, centralization_w: 1.6,
        attack_b: 2.2, attack_w: 2.2,
        piece_activity_b: 2.0, piece_activity_w: 2.0,
        defense_b: 0.7, defense_w: 0.7,
        pawn_structure_b: 0.8, pawn_structure_w: 0.8
      },
      custom: {
        material: 1.0,
        king_safety_b: 1.0, king_safety_w: 1.0,
        centralization_b: 1.0, centralization_w: 1.0,
        attack_b: 1.0, attack_w: 1.0,
        piece_activity_b: 1.0, piece_activity_w: 1.0,
        defense_b: 1.0, defense_w: 1.0,
        pawn_structure_b: 1.0, pawn_structure_w: 1.0
      }
    };

    // Piece style themes
    const pieceThemes = {
      wikipedia: 'lib/img/chesspieces/wikipedia/{piece}.png',
      alpha: 'https://lichess1.org/assets/piece/alpha/{piece}.svg',
      cburnett: 'https://lichess1.org/assets/piece/cburnett/{piece}.svg',
      merida: 'https://lichess1.org/assets/piece/merida/{piece}.svg',
      pirouetti: 'https://lichess1.org/assets/piece/pirouetti/{piece}.svg',
      spatial: 'https://lichess1.org/assets/piece/spatial/{piece}.svg',
      california: 'https://lichess1.org/assets/piece/california/{piece}.svg',
      cardinal: 'https://lichess1.org/assets/piece/cardinal/{piece}.svg',
      chessnut: 'https://lichess1.org/assets/piece/chessnut/{piece}.svg',
      chess7: 'https://lichess1.org/assets/piece/chess7/{piece}.svg',
      reillycraig: 'https://lichess1.org/assets/piece/reillycraig/{piece}.svg',
      riohacha: 'https://lichess1.org/assets/piece/riohacha/{piece}.svg',
      shapes: 'https://lichess1.org/assets/piece/shapes/{piece}.svg',
      staunty: 'https://lichess1.org/assets/piece/staunty/{piece}.svg',
      tatiana: 'https://lichess1.org/assets/piece/tatiana/{piece}.svg'
    };

    // Opening Book Database
    const openingBook = {
      "e4": "King's Pawn Opening",
      "e4 e5": "Open Game",
      "e4 e5 Nf3 Nc6 Bb5": "Ruy Lopez (Spanish Opening)",
      "e4 e5 Nf3 Nc6 Bb5 a6": "Ruy Lopez: Morphy Defense",
      "e4 e5 Nf3 Nc6 Bb5 a6 Ba4 Nf6 O-O": "Ruy Lopez: Closed Variation",
      "e4 e5 Nf3 Nc6 Bb5 a6 Ba4 Nf6 O-O Be7": "Ruy Lopez: Closed, Chigorin Defense",
      "e4 e5 Nf3 Nc6 Bb5 Nf6": "Ruy Lopez: Berlin Defense",
      "e4 e5 Nf3 Nc6 Bc4": "Italian Game",
      "e4 e5 Nf3 Nc6 Bc4 Bc5": "Italian Game: Giuoco Piano",
      "e4 e5 Nf3 Nc6 Bc4 Bc5 c3": "Italian Game: Giuoco Pianissimo",
      "e4 e5 Nf3 Nc6 Bc4 Bc5 b4": "Italian Game: Evans Gambit",
      "e4 e5 Nf3 Nc6 Bc4 Nf6": "Italian Game: Two Knights Defense",
      "e4 e5 Nf3 Nf6": "Petrov's Defense (Russian Game)",
      "e4 c5": "Sicilian Defense",
      "e4 c5 Nf3 d6": "Sicilian Defense: Open Variation",
      "e4 c5 Nf3 d6 d4 cxd4 Nxd4 Nf6 Nc3 a6": "Sicilian Defense: Najdorf Variation",
      "e4 c5 Nf3 d6 d4 cxd4 Nxd4 Nf6 Nc3 g6": "Sicilian Defense: Dragon Variation",
      "e4 c5 Nf3 d6 d4 cxd4 Nxd4 Nf6 Nc3 e6": "Sicilian Defense: Scheveningen Variation",
      "e4 c5 Nf3 Nc6": "Sicilian Defense: Closed Variation",
      "e4 c5 Nf3 e6": "Sicilian Defense: French Variation",
      "e4 c5 c3": "Sicilian Defense: Alapin Variation",
      "e4 e6": "French Defense",
      "e4 e6 d4 d5": "French Defense: Main Line",
      "e4 e6 d4 d5 Nc3": "French Defense: Classical Variation",
      "e4 e6 d4 d5 Nd2": "French Defense: Tarrasch Variation",
      "e4 e6 d4 d5 exd5": "French Defense: Exchange Variation",
      "e4 c6": "Caro-Kann Defense",
      "e4 c6 d4 d5": "Caro-Kann Defense: Main Line",
      "e4 c6 d4 d5 Nc3": "Caro-Kann Defense: Classical Variation",
      "e4 c6 d4 d5 exd5": "Caro-Kann Defense: Exchange Variation",
      "e4 d5": "Scandinavian Defense (Center Counter)",
      "e4 d5 exd5 Qxd5": "Scandinavian Defense: Main Line",
      "e4 d5 exd5 Nf6": "Scandinavian Defense: Modern Variation",
      "d4": "Queen's Pawn Opening",
      "d4 d5": "Closed Game",
      "d4 d5 c4": "Queen's Gambit",
      "d4 d5 c4 e6": "Queen's Gambit Declined",
      "d4 d5 c4 e6 Nc3 Nf6": "Queen's Gambit Declined: Orthodox Variation",
      "d4 d5 c4 e6 Nc3 Nf6 Bg5": "Queen's Gambit Declined: Classical Variation",
      "d4 d5 c4 c6": "Slav Defense",
      "d4 d5 c4 c6 Nf3 Nf6 Nc3 dxc4": "Slav Defense: Accepted Variation",
      "d4 d5 c4 c6 Nf3 Nf6 Nc3 e6": "Semi-Slav Defense",
      "d4 d5 c4 dxc4": "Queen's Gambit Accepted",
      "d4 Nf6 c4 g6": "King's Indian Defense",
      "d4 Nf6 c4 g6 Nc3 Bg7": "King's Indian Defense: Main Line",
      "d4 Nf6 c4 g6 Nc3 Bg7 e4": "King's Indian Defense: Classical Variation",
      "d4 Nf6 c4 e6": "Indian Defense",
      "d4 Nf6 c4 e6 Nc3 Bb4": "Nimzo-Indian Defense",
      "d4 Nf6 c4 e6 Nc3 Bb4 Qc2": "Nimzo-Indian Defense: Classical Variation",
      "d4 Nf6 c4 e6 Nc3 Bb4 e3": "Nimzo-Indian Defense: Rubinstein Variation",
      "d4 Nf6 c4 e6 Nf3 b6": "Queen's Indian Defense",
      "d4 Nf6 Nf3 g6": "King's Indian Attack",
      "d4 Nf6 Nf3 e6": "Indian Game",
      "d4 Nf6 c4 c5 d5": "Benoni Defense: Modern Benoni",
      "d4 Nf6 c4 c5 d5 e6": "Benoni Defense: Modern Variation",
      "Nf3": "RÃ©ti Opening",
      "Nf3 d5 c4": "RÃ©ti Opening: Anglo-Slav Variation",
      "Nf3 Nf6 c4 g6": "RÃ©ti Opening: King's Indian Attack",
      "c4": "English Opening",
      "c4 e5": "English Opening: Reversed Sicilian",
      "c4 Nf6": "English Opening: Anglo-Indian Defense",
      "c4 c5": "English Opening: Symmetrical Variation",
      "e4 e5 Nf3 Nc6 d4": "Scotch Game",
      "e4 e5 Nf3 Nc6 d4 exd4 Nxd4": "Scotch Game: Main Line",
      "e4 e5 Nf3 Nc6 Nc3": "Four Knights Game",
      "e4 e5 Nf3 Nc6 Nc3 Nf6": "Four Knights Game: Spanish Variation",
      "e4 e5 f4": "King's Gambit",
      "e4 e5 f4 exf4": "King's Gambit Accepted",
      "e4 e5 f4 Bc5": "King's Gambit Declined: Classical Defense",
      "d4 Nf6 Bg5": "Trompowsky Attack",
      "d4 Nf6 Bg5 Ne4": "Trompowsky Attack: Main Line",
      "d4 d5 Nf3": "London System",
      "d4 d5 Nf3 Nf6 Bf4": "London System: Main Line",
      "e4 g6": "Modern Defense",
      "e4 g6 d4 Bg7": "Modern Defense: Gurgenidze System",
      "e4 g6 d4 Bg7 Nc3 d6": "Modern Defense: Pseudo-Austrian Attack",
      "e4 Nc6": "Nimzowitsch Defense",
      "e4 Nc6 d4 e5": "Nimzowitsch Defense: Scandinavian Variation",
      "d4 f5": "Dutch Defense",
      "d4 f5 g3": "Dutch Defense: Leningrad Variation",
      "d4 f5 Nf3 Nf6 g3 g6 Bg2 Bg7": "Dutch Defense: Leningrad System",
      "d4 f5 c4 Nf6": "Dutch Defense: Classical Variation",
      "d4 f5 e4": "Dutch Defense: Staunton Gambit",
      "f4": "Bird's Opening",
      "f4 d5": "Bird's Opening: From's Gambit",
      "f4 e5": "Bird's Opening: From Gambit",
      "e4 e5 Nf3 Nc6 Bb5 a6 Ba4 Nf6": "Ruy Lopez: Open Defense",
      "e4 e5 Nf3 Nc6 Bb5 a6 Ba4 Nf6 O-O Nxe4": "Ruy Lopez: Open Variation",
      "e4 e5 Nf3 Nc6 Bb5 a6 Ba4 Nf6 O-O Be7 Re1 b5 Bb3 d6": "Ruy Lopez: Closed, Zaitsev Variation",
      "e4 e5 Nf3 Nc6 Bb5 a6 Ba4 Nf6 O-O Be7 Re1 b5 Bb3 d6 c3 O-O": "Ruy Lopez: Closed, Breyer Variation",
      "e4 e5 Nf3 Nc6 Bb5 a6 Ba4 Nf6 O-O Nxe4 d4": "Ruy Lopez: Open, Howell Attack",
      "e4 e5 Nf3 Nc6 Bc4 Bc5 b4 Bxb4 c3": "Italian Game: Evans Gambit Accepted",
      "e4 e5 Nf3 Nc6 Bc4 Nf6 d4": "Italian Game: Two Knights Defense, Max Lange Attack",
      "e4 e5 Nf3 Nc6 Bc4 Nf6 Ng5": "Italian Game: Two Knights Defense, Fried Liver Attack",
      "e4 e5 Nf3 Nf6 Nxe5": "Petrov's Defense: Steinitz Attack",
      "e4 e5 Nf3 Nf6 Nxe5 d6": "Petrov's Defense: Classical Variation",
      "e4 e5 Nf3 Nf6 d4": "Petrov's Defense: Three Knights Game",
      "e4 c5 Nf3 d6 d4 cxd4 Nxd4 Nf6 Nc3 a6 Be3": "Sicilian Defense: Najdorf, English Attack",
      "e4 c5 Nf3 d6 d4 cxd4 Nxd4 Nf6 Nc3 a6 Be2": "Sicilian Defense: Najdorf, Classical Variation",
      "e4 c5 Nf3 d6 d4 cxd4 Nxd4 Nf6 Nc3 g6 Be3 Bg7": "Sicilian Defense: Dragon, Yugoslav Attack",
      "e4 c5 Nf3 e6 d4 cxd4 Nxd4 a6": "Sicilian Defense: Kan Variation",
      "e4 c5 Nf3 e6 d4 cxd4 Nxd4 Nc6": "Sicilian Defense: Taimanov Variation",
      "e4 c5 Nf3 e6 d4 cxd4 Nxd4 Nc6 Nc3 Qc7": "Sicilian Defense: Taimanov, English Attack",
      "e4 c5 Nf3 e6 c3": "Sicilian Defense: Smith-Morra Gambit",
      "e4 c5 Nf3 e6 c3 d5": "Sicilian Defense: Smith-Morra Gambit Declined",
      "e4 c5 c3 Nf6": "Sicilian Defense: Alapin, Barmen Variation",
      "e4 c5 c3 d5": "Sicilian Defense: Alapin, Normal Variation",
      "e4 e6 d4 d5 Nc3 Bb4": "French Defense: Winawer Variation",
      "e4 e6 d4 d5 Nc3 Bb4 e5": "French Defense: Winawer, Advance Variation",
      "e4 e6 d4 d5 Nc3 Bb4 e5 c5": "French Defense: Winawer, Poisoned Pawn",
      "e4 e6 d4 d5 Nc3 Nf6": "French Defense: Alekhine-Chatard Attack",
      "e4 e6 d4 d5 Nd2 c5": "French Defense: Tarrasch, Guimard Variation",
      "e4 e6 d4 d5 Nd2 Nf6": "French Defense: Tarrasch, Leningrad Variation",
      "e4 e6 d4 d5 exd5 exd5": "French Defense: Exchange, Classical Variation",
      "e4 c6 d4 d5 Nc3 dxe4 Nxe4 Bf5": "Caro-Kann Defense: Classical Variation",
      "e4 c6 d4 d5 Nc3 dxe4 Nxe4 Nd7": "Caro-Kann Defense: Karpov Variation",
      "e4 c6 d4 d5 Nc3 dxe4 Nxe4 Bf5 Ng3 Bg6": "Caro-Kann Defense: Classical, Main Line",
      "e4 c6 d4 d5 Nc3 dxe4 Nxe4 Nd7 Nf3 Ngf6": "Caro-Kann Defense: Karpov, Main Line",
      "e4 d5 exd5 Nf6 c4 e6": "Scandinavian Defense: Modern, Main Line",
      "e4 d5 exd5 Qxd5 Nc3 Qa5": "Scandinavian Defense: Main Line, Gubinsky-Melts Defense",
      "e4 d5 exd5 Qxd5 Nc3 Qd6": "Scandinavian Defense: Main Line, Modern Variation",
      "d4 d5 c4 e6 Nf3": "Queen's Gambit Declined: Orthodox",
      "d4 d5 c4 e6 Nf3 Nf6": "Queen's Gambit Declined: Orthodox, Main Line",
      "d4 d5 c4 e6 Nf3 Nf6 Nc3 Be7": "Queen's Gambit Declined: Orthodox, Classical",
      "d4 d5 c4 e6 Nf3 Nf6 Nc3 Be7 Bg5": "Queen's Gambit Declined: Orthodox, Tartakower Variation",
      "d4 d5 c4 e6 Nf3 Nf6 cxd5": "Queen's Gambit Declined: Exchange Variation",
      "d4 d5 c4 c6 Nf3 Nf6 e3": "Slav Defense: Quiet Variation",
      "d4 d5 c4 c6 Nf3 Nf6 Nc3 dxc4 a4": "Slav Defense: Alekhine Variation",
      "d4 d5 c4 c6 Nf3 Nf6 e3 Bf5": "Slav Defense: Modern Variation",
      "d4 d5 c4 c6 Nf3 Nf6 Nc3 e6 Bg5": "Semi-Slav Defense: Botvinnik Variation",
      "d4 d5 c4 c6 Nf3 Nf6 Nc3 e6 e3": "Semi-Slav Defense: Meran Variation",
      "d4 Nf6 c4 g6 Nc3 Bg7 e4 d6": "King's Indian Defense: Classical, Main Line",
      "d4 Nf6 c4 g6 Nc3 Bg7 e4 d6 Nf3 O-O Be2 e5": "King's Indian Defense: Classical, Petrosian System",
      "d4 Nf6 c4 g6 Nc3 Bg7 e4 d6 f3": "King's Indian Defense: SÃ¤misch Variation",
      "d4 Nf6 c4 g6 Nc3 Bg7 e4 d6 f4": "King's Indian Defense: Four Pawns Attack",
      "d4 Nf6 c4 g6 Nc3 Bg7 e4 d6 Nge2": "King's Indian Defense: Averbakh Variation",
      "d4 Nf6 c4 g6 Nf3 Bg7": "King's Indian Defense: Fianchetto Variation",
      "d4 Nf6 c4 e6 Nc3 Bb4 a3": "Nimzo-Indian Defense: Samisch Variation",
      "d4 Nf6 c4 e6 Nc3 Bb4 Nf3": "Nimzo-Indian Defense: Classical, Ragozin Defense",
      "d4 Nf6 c4 e6 Nc3 Bb4 Nf3 c5": "Nimzo-Indian Defense: Classical, HÃ¼bner Variation",
      "d4 Nf6 c4 e6 Nf3 b6 g3": "Queen's Indian Defense: Fianchetto Variation",
      "d4 Nf6 c4 e6 Nf3 b6 a3": "Queen's Indian Defense: Petrosian Variation",
      "d4 Nf6 c4 e6 Nf3 b6 Nc3": "Queen's Indian Defense: Classical Variation",
      "d4 Nf6 c4 c5 d5 b5": "Benoni Defense: Modern, Benko Gambit",
      "d4 Nf6 c4 c5 d5 b5 cxb5 a6": "Benoni Defense: Modern, Benko Gambit Accepted",
      "d4 Nf6 c4 c5 d5 e5": "Benoni Defense: Czech Benoni",
      "Nf3 d5 d4": "RÃ©ti Opening: Slav System",
      "Nf3 d5 c4 d4": "RÃ©ti Opening: Slav, Alapin Variation",
      "Nf3 Nf6 c4 c5": "RÃ©ti Opening: Symmetrical Variation",
      "Nf3 Nf6 c4 e6": "RÃ©ti Opening: English Defense",
      "c4 e5 Nc3": "English Opening: Reversed Dragon",
      "c4 e5 Nc3 Nf6": "English Opening: Reversed Dragon, Yugoslav Attack",
      "c4 Nf6 Nc3 e5": "English Opening: Symmetrical, Botvinnik System",
      "c4 c5 Nf3": "English Opening: Symmetrical, Hedgehog System",
      "e4 e5 Nf3 Nc6 d4 exd4 Nxd4 Nf6": "Scotch Game: Schmidt Variation",
      "e4 e5 Nf3 Nc6 d4 exd4 Nxd4 Bc5": "Scotch Game: Classical Variation",
      "e4 e5 Nf3 Nc6 Nc3 Nf6 Bb5": "Four Knights Game: Spanish Variation",
      "e4 e5 Nf3 Nc6 Nc3 Nf6 Bb5 Nd4": "Four Knights Game: Spanish, Rubinstein Variation",
      "e4 e5 Nf3 Nc6 Nc3 Nf6 d4": "Four Knights Game: Scotch Variation",
      "e4 e5 Nc3": "Vienna Game",
      "e4 e5 Nc3 Nf6": "Vienna Game: Falkbeer Variation",
      "e4 e5 Nc3 Nf6 f4": "Vienna Game: Gambit",
      "e4 e5 Nc3 Bc5": "Vienna Game: Frankenstein-Dracula Variation",
      "e4 e5 Bc4": "Bishop's Opening",
      "e4 e5 Bc4 Nf6": "Bishop's Opening: Berlin Defense",
      "e4 e5 Bc4 Nc6": "Bishop's Opening: Classical Defense",
      "e4 e5 Nf3 Nc6 Bc4 Bc5 d3": "Italian Game: Giuoco Pianissimo, Main Line",
      "e4 e5 Nf3 Nc6 Bc4 Bc5 O-O": "Italian Game: Giuoco Pianissimo, Modern Variation",
      "e4 e5 f4 exf4 Nf3": "King's Gambit: Accepted, Modern Defense",
      "e4 e5 f4 exf4 Nf3 g5": "King's Gambit: Accepted, Classical Defense",
      "e4 e5 f4 exf4 Nf3 g5 h4": "King's Gambit: Accepted, Allgaier Gambit",
      "e4 e5 f4 exf4 Nc3": "King's Gambit: Accepted, Quade Gambit",
      "e4 e5 f4 Bc5": "King's Gambit: Declined, Classical Defense",
      "e4 e5 f4 d5": "King's Gambit: Declined, Falkbeer Countergambit",
      "d4 d5 Nf3 Nf6 Bf4": "London System: Main Line",
      "d4 d5 Nf3 Nf6 Bf4 c5": "London System: Normal Variation",
      "d4 d5 Nf3 Nf6 Bf4 Bf5": "London System: Symmetrical Variation",
      "d4 Nf6 Bg5 c5": "Trompowsky Attack: Classical Defense",
      "d4 Nf6 Bg5 Ne4 Bf4": "Trompowsky Attack: Raptor Variation",
      "d4 Nf6 Bg5 e6": "Trompowsky Attack: French Variation",
      "d4 Nf6 Nf3 e6 c4": "Indian Defense: Nimzowitsch Variation",
      "d4 Nf6 Nf3 e6 c4 Bb4+": "Indian Defense: Bogo-Indian Defense",
      "d4 Nf6 Nf3 e6 c4 Bb4+ Bd2": "Bogo-Indian Defense: Modern Variation",
      "d4 Nf6 c4 e6 Nc3 Bb4 Qb3": "Nimzo-Indian Defense: Spielmann Variation",
      "d4 Nf6 c4 e6 Nc3 Bb4 e3 O-O": "Nimzo-Indian Defense: Capablanca Variation",
      "d4 Nf6 c4 e6 Nc3 Bb4 a3 Bxc3+": "Nimzo-Indian Defense: Samisch, Main Line",
      "d4 Nf6 c4 e6 Nc3 Bb4 a3 Bxc3+ bxc3": "Nimzo-Indian Defense: Samisch, Orthodox",
      "e4 e5 Nf3 Nc6 d3": "King's Pawn Opening: RÃ©ti System",
      "e4 e5 Nf3 Nc6 Be2": "King's Pawn Opening: Modern Variation",
      "e4 e5 Nf3 Nc6 g3": "King's Pawn Opening: Konstantinopolsky Variation",
      "e4 e5 Nf3 Nc6 c3": "King's Pawn Opening: Ponziani Opening",
      "e4 e5 Nf3 Nc6 c3 d5": "Ponziani Opening: Steinitz Variation",
      "d4 d5 c4 c5": "Queen's Gambit: Slav, Marshall Gambit",
      "d4 d5 c4 e5": "Queen's Gambit: Albin Countergambit",
      "d4 d5 c4 e5 dxe5 d4": "Queen's Gambit: Albin Countergambit Accepted",
      "d4 d5 Nf3": "Queen's Pawn Opening: Zukertort Opening",
      "d4 Nf6": "Indian Game: Wade-Tartakower Defense",
      "Nf3 d5": "Zukertort Opening: Dutch Variation",
      "Nf3 d5 c4": "RÃ©ti Opening: Anglo-Slav, Main Line",
      "Nf3 d5 g3": "RÃ©ti Opening: Fianchetto Variation",
      "b4": "Sokolsky Opening (Orangutan)",
      "b4 e5": "Sokolsky Opening: Outflank Variation",
      "b4 c6": "Sokolsky Opening: Outflank Defense",
      "g4": "Grob Opening",
      "g4 d5": "Grob Opening: Spike Attack",
      "Nc3": "Dunst Opening",
      "Nc3 d5": "Dunst Opening: Normal Defense",
      "Nc3 e5": "Dunst Opening: Sicilian Variation",
      "e3": "Van't Kruijs Opening",
      "e3 d5": "Van't Kruijs Opening: Normal Defense",
      "d3": "Mieses Opening",
      "d3 d5": "Mieses Opening: Reversed Philidor",
      "a4": "Ware Opening",
      "a4 e5": "Ware Opening: Crab Variation",
      "h4": "Kadas Opening",
      "h4 e5": "Kadas Opening: Normal Defense",
      "Na3": "Durkin Opening",
      "f3": "Barnes Opening",
      "f3 e5": "Barnes Opening: Gedult Attack",
      "Nh3": "Amar Opening",
      "b3": "Larsen Opening",
      "b3 e5": "Larsen Opening: Classical Variation",
      "g3": "Benko Opening",
      "g3 d5": "Benko Opening: Reversed Alekhine",
      "c3": "Saragossa Opening",
      "c3 e5": "Saragossa Opening: Normal Variation",
      "b3": "Larsen's Opening (Queen's Fianchetto)"
    };

    // --- sendEngineCommand function ---
    function sendEngineCommand(endpoint) {
    // Key change: Add 'return' here to return the promise chain
    return fetch(`https://hedgehoglover23.pythonanywhere.com/${endpoint}`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({})
    })
    .then(response => {
        if (!response.ok) {
            return response.json().then(err => {
                throw new Error(`Server error for /${endpoint}: ${err.message || response.statusText}`);
            }).catch(() => {
                throw new Error(`Server error for /${endpoint}: ${response.status} ${response.statusText}`);
            });
        }
        return response.json(); // This 'return' passes the parsed data down
    })
    .then(data => {
        console.log(`Command /${endpoint} successful:`, data.message || data.status || data);
        return data; // This 'return data' is correct for the internal chain
    })
    .catch(error => {
        console.error(`Error sending command /${endpoint}:`, error);
        throw error; // Propagate the error so the awaiting function can catch it
    });
}

    function toggleHistoryOption() {
      const blindfoldChecked = document.getElementById("blindfold-mode").checked;
      const historyRow = document.getElementById("show-history-row");
      if (blindfoldChecked) {
        historyRow.style.display = "inline-block";
      } else {
        historyRow.style.display = "none";
      }
    }

    function updateCustomModifiers() {
      // Helper function to clamp values between 0 and 3
      const clampValue = (value) => {
        const num = parseFloat(value);
        if (isNaN(num)) return 1.0;
        return Math.max(0, Math.min(3, num));
      };
      
      // Get values and clamp them
      const material = clampValue(document.getElementById('mod-material').value);
      const kingSafety = clampValue(document.getElementById('mod-king-safety').value);
      const centralization = clampValue(document.getElementById('mod-centralization').value);
      const attack = clampValue(document.getElementById('mod-attack').value);
      const pieceActivity = clampValue(document.getElementById('mod-piece-activity').value);
      const defense = clampValue(document.getElementById('mod-defense').value);
      const pawnStructure = clampValue(document.getElementById('mod-pawn-structure').value);
      
      // Update input fields with clamped values
      document.getElementById('mod-material').value = material.toFixed(1);
      document.getElementById('mod-king-safety').value = kingSafety.toFixed(1);
      document.getElementById('mod-centralization').value = centralization.toFixed(1);
      document.getElementById('mod-attack').value = attack.toFixed(1);
      document.getElementById('mod-piece-activity').value = pieceActivity.toFixed(1);
      document.getElementById('mod-defense').value = defense.toFixed(1);
      document.getElementById('mod-pawn-structure').value = pawnStructure.toFixed(1);
      
      // Update the custom personality in enginePersonalities object
      enginePersonalities.custom.material = material;
      enginePersonalities.custom.king_safety_b = kingSafety;
      enginePersonalities.custom.king_safety_w = kingSafety;
      enginePersonalities.custom.centralization_b = centralization;
      enginePersonalities.custom.centralization_w = centralization;
      enginePersonalities.custom.attack_b = attack;
      enginePersonalities.custom.attack_w = attack;
      enginePersonalities.custom.piece_activity_b = pieceActivity;
      enginePersonalities.custom.piece_activity_w = pieceActivity;
      enginePersonalities.custom.defense_b = defense;
      enginePersonalities.custom.defense_w = defense;
      enginePersonalities.custom.pawn_structure_b = pawnStructure;
      enginePersonalities.custom.pawn_structure_w = pawnStructure;
      
      // Save to localStorage
      localStorage.setItem('customModifiers', JSON.stringify({
        material: material,
        king_safety: kingSafety,
        centralization: centralization,
        attack: attack,
        piece_activity: pieceActivity,
        defense: defense,
        pawn_structure: pawnStructure
      }));
      
      // Apply modifiers in real-time
      applyEngineModifiers('custom');
    }

    function resetCustomModifiers() {
      document.getElementById('mod-material').value = 1.0;
      document.getElementById('mod-king-safety').value = 1.0;
      document.getElementById('mod-centralization').value = 1.0;
      document.getElementById('mod-attack').value = 1.0;
      document.getElementById('mod-piece-activity').value = 1.0;
      document.getElementById('mod-defense').value = 1.0;
      document.getElementById('mod-pawn-structure').value = 1.0;
      updateCustomModifiers();
    }

    function loadCustomModifiers() {
      const saved = localStorage.getItem('customModifiers');
      if (saved) {
        const custom = JSON.parse(saved);
        document.getElementById('mod-material').value = custom.material || 1.0;
        document.getElementById('mod-king-safety').value = custom.king_safety || 1.0;
        document.getElementById('mod-centralization').value = custom.centralization || 1.0;
        document.getElementById('mod-attack').value = custom.attack || 1.0;
        document.getElementById('mod-piece-activity').value = custom.piece_activity || 1.0;
        document.getElementById('mod-defense').value = custom.defense || 1.0;
        document.getElementById('mod-pawn-structure').value = custom.pawn_structure || 1.0;
        updateCustomModifiers();
      }
    }

    function toggleHistoryOption() {
      const blindfoldChecked = document.getElementById("blindfold-mode").checked;
      const historyRow = document.getElementById("show-history-row");
      if (blindfoldChecked) {
        historyRow.style.display = "inline-block";
      } else {
        historyRow.style.display = "none";
        document.getElementById("show-history").checked = false;
      }
    }

    function changeBoardStyle() {
      const style = document.getElementById("board-style").value;
      const boardElement = document.getElementById("board");
      
      // Remove all theme classes
      boardElement.className = boardElement.className.replace(/board-theme-\w+/g, '').trim();
      
      // Add new theme class
      boardElement.classList.add(`board-theme-${style}`);
      
      // Save preference to localStorage
      localStorage.setItem('chessboardStyle', style);
    }

    function changeEngineStyle() {
      const style = document.getElementById("engine-style").value;
      const selector = document.getElementById("engine-style");
      const customPanel = document.getElementById("custom-modifiers-panel");
      currentEngineStyle = style;
      
      // Remove all personality classes
      selector.className = selector.className.replace(/personality-\w+/g, '').trim();
      
      // Add new personality class for color
      selector.classList.add('personality-' + style);
      
      // Show/hide custom modifiers panel
      if (style === 'custom') {
        customPanel.style.display = 'block';
        loadCustomModifiers();
      } else {
        customPanel.style.display = 'none';
      }
      
      // Save preference to localStorage
      localStorage.setItem('enginePersonality', style);
      
      // Apply modifiers to engine
      applyEngineModifiers(style);
    }

    async function applyEngineModifiers(personality) {
      const baseModifiers = enginePersonalities[personality];
      
      if (!baseModifiers) {
        console.error('Unknown engine personality:', personality);
        return;
      }

      // Determine which color the engine is playing
      const engineColor = playerColor === 'white' ? 'black' : 'white';
      // NOTE: Code internals are reversed from board!
      // _b modifiers = WHITE pieces on board, _w modifiers = BLACK pieces on board
      const engineSuffix = engineColor === 'black' ? '_w' : '_b';
      const playerSuffix = engineColor === 'black' ? '_b' : '_w';

      // Build asymmetric modifiers: engine gets personality, player gets balanced (1.0)
      const modifiers = {
        material: baseModifiers.material, // Material is symmetric
      };

      // For each personality trait, apply it to engine's color only
      const traits = ['king_safety', 'centralization', 'attack', 'piece_activity', 'defense', 'pawn_structure'];
      
      traits.forEach(trait => {
        // Engine's color gets the personality modifier
        modifiers[trait + engineSuffix] = baseModifiers[trait + engineSuffix];
        // Player's color gets balanced modifier (1.0)
        modifiers[trait + playerSuffix] = 1.0;
      });

      console.log('Applying asymmetric modifiers:', {
        personality,
        engineColor,
        engineSuffix,
        playerSuffix,
        engineModifiers: modifiers
      });

      try {
        const response = await fetch('https://hedgehoglover23.pythonanywhere.com/modifiers', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(modifiers)
        });

        if (response.ok) {
          const data = await response.json();
          console.log('Engine modifiers updated (asymmetric):', data);
        } else {
          console.error('Failed to update engine modifiers:', response.statusText);
        }
      } catch (error) {
        console.error('Error updating engine modifiers:', error);
      }
    }

    function changePieceStyle() {
      const style = document.getElementById("piece-style").value;
      currentPieceStyle = style;
      
      // Save preference to localStorage
      localStorage.setItem('chessPieceStyle', style);
      
      // If board exists, update the piece theme
      if (board) {
        const currentPosition = board.position();
        board.destroy();
        
        // Check if game is active or preview mode
        const isGameStarted = document.getElementById("choose-side").style.display === "none";
        
        if (isGameStarted && game && !gameOver) {
          // Game is active - recreate with full handlers
          recreateBoard();
        } else {
          // Preview mode - recreate preview board
          board = Chessboard('board', {
            draggable: false,
            position: currentPosition,
            orientation: 'white',
            pieceTheme: pieceThemes[currentPieceStyle]
          });
        }
        board.position(currentPosition);
      }
    }

    function recreateBoard() {
      board = Chessboard("board", {
        draggable: true,
        position: game ? game.fen() : "start",
        orientation: playerColor,
        snapSpeed: 50,
        snapbackSpeed: 50,
        appearSpeed: 0,
        moveSpeed: 100,
        trashSpeed: 50,
        dragThrottleRate: 0,
        sparePieces: false,
        dropOffBoard: 'snapback',
        onDragStart: (source, piece, position, orientation) => {
          if (game.game_over() || gameOver) {
            const sourceSquare = $(`#board .square-${source}`);
            sourceSquare.addClass('illegal-move');
            setTimeout(() => sourceSquare.removeClass('illegal-move'), 600);
            return false;
          }
          const turn = game.turn();
          if ((playerColor === "white" && turn !== "w") || (playerColor === "black" && turn !== "b")) {
            const sourceSquare = $(`#board .square-${source}`);
            sourceSquare.addClass('illegal-move');
            setTimeout(() => sourceSquare.removeClass('illegal-move'), 600);
            return false;
          }
          if ((turn === 'w' && piece.search(/^b/) !== -1) || (turn === 'b' && piece.search(/^w/) !== -1)) {
            const sourceSquare = $(`#board .square-${source}`);
            sourceSquare.addClass('illegal-move');
            setTimeout(() => sourceSquare.removeClass('illegal-move'), 600);
            return false;
          }
          highlightLegalMoves(source);
        },
        onDragMove: (newLocation, oldLocation, source, piece, position, orientation) => {
          $("#board .square-55d63").removeClass("legal-target");
          const moves = game.moves({ square: source, verbose: true });
          const isLegal = moves.some(move => move.to === newLocation);
          if (isLegal) {
            $(`#board .square-${newLocation}`).addClass("legal-target");
          }
        },
        onDrop: handleMove,
        onSnapEnd: () => {
          removeHighlights();
          $("#board .square-55d63").removeClass("legal-target");
        },
        pieceTheme: pieceThemes[currentPieceStyle],
      });
    }

 $(document).ready(function() {
	 		
        console.log("The page has finished loading!");

        // Load saved board style
        const savedStyle = localStorage.getItem('chessboardStyle') || 'classic';
        document.getElementById('board-style').value = savedStyle;
        changeBoardStyle();

        // Load saved piece style
        const savedPieceStyle = localStorage.getItem('chessPieceStyle') || 'wikipedia';
        currentPieceStyle = savedPieceStyle;
        document.getElementById('piece-style').value = savedPieceStyle;

        // Load saved engine personality
        const savedEngineStyle = localStorage.getItem('enginePersonality') || 'balanced';
        currentEngineStyle = savedEngineStyle;
        const engineStyleSelect = document.getElementById('engine-style');
        engineStyleSelect.value = savedEngineStyle;
        // Apply personality color on load
        engineStyleSelect.classList.add('personality-' + savedEngineStyle);
        
        // Show custom panel if custom personality was selected
        if (savedEngineStyle === 'custom') {
          document.getElementById('custom-modifiers-panel').style.display = 'block';
          loadCustomModifiers();
        }

        // Initialize game object for preview board
        game = new Chess();
        gameOver = false;
        playerColor = "white"; // Default for preview

        // Create preview board with dragging enabled
        board = Chessboard('board', {
          draggable: false,
          position: 'start',
          orientation: 'white',
          pieceTheme: pieceThemes[currentPieceStyle]
        });
        
        console.log('Preview board created with config:', {
          draggable: false
        });
        
        // Show the board container
        document.getElementById('board-timers-container').style.display = 'flex';

        // --- AUTOMATIC LOGIC: Stop then Start the engine on page load ---
        console.log("Attempting to stop and then start the engine automatically on page load...");
        sendEngineCommand('stop')
            .then(() => {
                console.log("Stop command sent successfully. Now sending start command...");
                return sendEngineCommand('start');
            })
            .then(() => {
                console.log("Start command sent successfully. Engine should be reset and running.");
            })
            .catch(error => {
                console.error("Error during automatic engine reset on page load:", error);
                // Replaced alert() with a console log
                console.error("Failed to automatically reset engine on page load. Check console for details.");
            });

        // Load sound settings
        const savedSound = localStorage.getItem('soundEnabled');
        if (savedSound !== null) {
          document.getElementById('sound-effects').checked = savedSound === 'true';
          soundEnabled = savedSound === 'true';
        }

        // Add event listener for sound toggle
        document.getElementById('sound-effects').addEventListener('change', function() {
          soundEnabled = this.checked;
          localStorage.setItem('soundEnabled', soundEnabled);
        });

        // Load statistics and achievements
        loadPlayerStats();
        loadAchievements();
        loadLifetimeStats();
        updatePlayerStatsDisplay();
        updateAchievementsDisplay();
        updateTotalPoints();
    });

        $(document).keydown(function(e) {
            if (!blindfoldMode && board && moveHistory.length > 0) {
                if (e.key === 'ArrowLeft' || e.keyCode === 37) {
                    e.preventDefault();
                    navigateToPreviousMove();
                } else if (e.key === 'ArrowRight' || e.keyCode === 39) {
                    e.preventDefault();
                    navigateToNextMove();
                } else if (e.key === 'ArrowUp' || e.keyCode === 38) {
                    e.preventDefault();
                    navigateToStart();
                } else if (e.key === 'ArrowDown' || e.keyCode === 40) {
                    e.preventDefault();
                    navigateToCurrent();
                }
            }
        });
    function formatTime(ms) {
      const t = Math.max(0, Math.floor(ms));
      const totalHundredths = Math.floor(t / 10);
      const minutes = String(Math.floor(totalHundredths / 6000)).padStart(2, "0");
      const seconds = String(Math.floor((totalHundredths % 6000) / 100)).padStart(2, "0");
      const hundredths = String(totalHundredths % 100).padStart(2, "0");
      return `${minutes}:${seconds}.${hundredths}`;
    }
    
    function updateClockStyles() {
        const turn = game.turn();
        const playerIsWhite = playerColor === 'white';
        
        // Determine which slot is the player's and which is the engine's
        const playerSlot = playerIsWhite ? document.getElementById("time-slot-white") : document.getElementById("time-slot-black");
        const engineSlot = playerIsWhite ? document.getElementById("time-slot-black") : document.getElementById("time-slot-white");
        
        // Remove active class from both
        playerSlot.classList.remove('time-active');
        engineSlot.classList.remove('time-active');

        // Add active class only to the player's clock when it's their turn
        if ((playerIsWhite && turn === 'w') || (!playerIsWhite && turn === 'b')) {
            playerSlot.classList.add('time-active');
        }
    }


    // MODIFIED: Timer always counts up, but only deducts time if it's the player's turn.
    function startTimer() {
      clearInterval(timerInterval);
      timerStart = performance.now();

      const turn = game.turn();
      const isPlayerTurn = (playerColor === "white" && turn === "w") || (playerColor === "black" && turn === "b");
      
      // Update clock styling (active state)
      updateClockStyles();

      // MODIFICATION START: Set player's time to its value and engine's time to "Unlimited"
      if (timeLimited) {
          // Determine element IDs and time references
          const playerTotalId = playerColor === 'white' ? "white-total" : "black-total";
          const engineTotalId = playerColor === 'white' ? "black-total" : "white-total";
          const playerTimeRef = playerColor === 'white' ? whiteTime : blackTime;
          
          // Set player's time display
          document.getElementById(playerTotalId).textContent = formatTime(playerTimeRef);
          
          // Set engine's time display to "Unlimited"
          document.getElementById(engineTotalId).textContent = "Unlimited";
      }
      // MODIFICATION END
      
      timerInterval = setInterval(() => {
          if (gameOver) {
              clearInterval(timerInterval);
              return;
          }

        const elapsed = performance.now() - timerStart;

        // 1. Always update the move timer display (Counts up)
        document.getElementById("timer").textContent = formatTime(elapsed);

        // 2. ONLY manage total time deduction/check if it's time limited AND the player's turn
        if (timeLimited && isPlayerTurn) {
            const totalTimeElementId = playerColor === 'white' ? "white-total" : "black-total";
            const playerTimeRef = playerColor === 'white' ? whiteTime : blackTime;
            
            const newTime = playerTimeRef - elapsed;

            // Update the player's total remaining time (countdown)
            document.getElementById(totalTimeElementId).textContent = formatTime(newTime);
            
            if (newTime <= 0) {
                clearInterval(timerInterval);
                // Replaced alert() with UI message
                const moveContainer = document.getElementById("move-timer-container");
                moveContainer.innerHTML = 'TIME OUT! <span style="color:red;">You lose!</span>';
                gameOver = true;
                
      // Update statistics
      playerStats.losses++;
      savePlayerStats();
      updatePlayerStatsDisplay();
      resetDailyStatsIfNeeded();
      lifetimeStats.dailyStats.gamesPlayedToday++;
      const moveCount = game.history().length;
      if (moveCount > lifetimeStats.dailyStats.longestGameToday) {
        lifetimeStats.dailyStats.longestGameToday = moveCount;
      }
      trackLossStats();
      commitGameStatsToLifetime();
      checkAndUnlockAchievements();
                
                // Show rematch modal
                setTimeout(() => showRematchModal("â° Time Out", "You ran out of time! Play again?"), 1500);
            }
        }
      }, 10);
    }

    // UNMODIFIED Logic, only checking if the color that just moved was the player's color
    function stopTimerAndUpdateTotal(color) {
      clearInterval(timerInterval);
      const elapsed = performance.now() - timerStart;
      if (timeLimited) {
        if (
          (color === "w" && playerColor === "white") ||
          (color === "b" && playerColor === "black")
          ) {
          if (color === "w") {
            whiteTime = Math.max(0, whiteTime - elapsed);
            whiteTime += increment * 1000;
            document.getElementById("white-total").textContent = formatTime(whiteTime);
          } else {
            blackTime = Math.max(0, blackTime - elapsed);
            blackTime += increment * 1000;
            document.getElementById("black-total").textContent = formatTime(blackTime);
          }
        }
      }
      return elapsed;
    }

function navigateToPreviousMove() {
      if (currentMoveIndex === -1 && moveHistory.length > 0) {
        currentMoveIndex = moveHistory.length - 2;
        if (currentMoveIndex < 0) currentMoveIndex = 0;
        displayPositionAtIndex(currentMoveIndex);
      } else if (currentMoveIndex === 0) {
        currentMoveIndex = -2;
        board.position('start');
        updateMoveHighlight();
      } else if (currentMoveIndex > 0) {
        currentMoveIndex--;
        displayPositionAtIndex(currentMoveIndex);
      }
    }

    function navigateToNextMove() {
      if (currentMoveIndex === -2 && moveHistory.length > 0) {
        currentMoveIndex = 0;
        displayPositionAtIndex(currentMoveIndex);
      } else if (currentMoveIndex === -1) {
        // Already at current position, do nothing
        return;
      } else if (currentMoveIndex < moveHistory.length - 1) {
        currentMoveIndex++;
        displayPositionAtIndex(currentMoveIndex);
      } else if (currentMoveIndex === moveHistory.length - 1) {
        currentMoveIndex = -1;
        board.position(game.fen());
        updateMoveHighlight();
      }
    }

    function navigateToStart() {
      currentMoveIndex = -2;
      board.position('start');
      updateMoveHighlight();
    }

    function navigateToCurrent() {
      currentMoveIndex = -1;
      board.position(game.fen());
      updateMoveHighlight();
    }

    function displayPositionAtIndex(index) {
      if (index >= 0 && index < moveHistory.length) {
        board.position(moveHistory[index]);
        updateMoveHighlight();
      }
    }

    function updateMoveHighlight() {
      $('.move-item').removeClass('highlighted');
      if (currentMoveIndex >= 0 && currentMoveIndex < moveHistory.length) {
        $(`.move-item[data-move-index="${currentMoveIndex}"]`).addClass('highlighted');
      }
    }

    function updateNotationDisplay() {
      const history = game.history();
      const container = document.getElementById("notation-container");
      container.innerHTML = '';
      // Dynamic height: expands up to board height as moves are played
      const minHeight = 60;
      const maxHeight = 450;
      const basePadding = 35;
      let dynHeight = minHeight + Math.min(history.length * 16, maxHeight-minHeight);
      dynHeight = Math.max(minHeight, Math.min(dynHeight, maxHeight));
      container.style.minHeight = minHeight + 'px';
      container.style.height = dynHeight + 'px';
      container.style.maxHeight = maxHeight + 'px';
      // Group moves by full move (White + Black)
      for (let i = 0; i < history.length; i += 2) {
          const moveNum = Math.floor(i / 2) + 1;
        const moveRow = document.createElement('div');
        moveRow.style.marginBottom = '4px';
        moveRow.style.display = 'flex';
        moveRow.style.alignItems = 'center';
        moveRow.style.gap = '8px';
        
        // Move number
        const moveNumSpan = document.createElement('span');
        moveNumSpan.className = 'move-number';
        moveNumSpan.textContent = moveNum + '.';
        moveNumSpan.style.fontWeight = '600';
        moveNumSpan.style.minWidth = '30px';
        moveNumSpan.style.color = '#7f8c8d';
        moveRow.appendChild(moveNumSpan);
        
        // White move
        const whiteMove = history[i];
        if (whiteMove) {
          const whiteSpan = document.createElement('span');
          whiteSpan.className = 'move-item';
        if (currentMoveIndex === i || (currentMoveIndex === -1 && i === history.length - 1)) {
            whiteSpan.classList.add('highlighted');
          }
          whiteSpan.setAttribute('data-move-index', i);
          whiteSpan.onclick = function() { jumpToMove(i); };
          whiteSpan.textContent = whiteMove;
          whiteSpan.style.cursor = 'pointer';
          whiteSpan.style.padding = '2px 6px';
          whiteSpan.style.borderRadius = '4px';
          whiteSpan.style.transition = 'background-color 0.2s';
          whiteSpan.onmouseover = function() { this.style.backgroundColor = '#ecf0f1'; };
          whiteSpan.onmouseout = function() { if (!this.classList.contains('highlighted')) this.style.backgroundColor = 'transparent'; };
          moveRow.appendChild(whiteSpan);
        }
        
        // Black move
        const blackMove = history[i + 1];
        if (blackMove) {
          const blackSpan = document.createElement('span');
          blackSpan.className = 'move-item';
          if (currentMoveIndex === i + 1 || (currentMoveIndex === -1 && i + 1 === history.length - 1)) {
            blackSpan.classList.add('highlighted');
          }
          blackSpan.setAttribute('data-move-index', i + 1);
          blackSpan.onclick = function() { jumpToMove(i + 1); };
          blackSpan.textContent = blackMove;
          blackSpan.style.cursor = 'pointer';
          blackSpan.style.padding = '2px 6px';
          blackSpan.style.borderRadius = '4px';
          blackSpan.style.transition = 'background-color 0.2s';
          blackSpan.onmouseover = function() { this.style.backgroundColor = '#ecf0f1'; };
          blackSpan.onmouseout = function() { if (!this.classList.contains('highlighted')) this.style.backgroundColor = 'transparent'; };
          moveRow.appendChild(blackSpan);
        }
        
        container.appendChild(moveRow);
      }
    }

    function jumpToMove(index) {
      if (!blindfoldMode && index >= 0 && index < moveHistory.length) {
        currentMoveIndex = index;
        displayPositionAtIndex(index);
      }
    }

    function updateLastMove(move, timeStr, color, move_number) {
      const txt = move ? `${move} (${timeStr})` : "None";
      document.getElementById("last-move").textContent = txt;

      if (move) {
        moveHistory.push(game.fen());
        currentMoveIndex = -1;
        updateNotationDisplay();
      }
}

    function updateTurnDisplay() {
      document.getElementById("turn-color").textContent = game.turn() === "w" ? "White" : "Black";
    }

    function highlightLegalMoves(square) {
      const moves = game.moves({ square, verbose: true });
      for (const move of moves) {
        $(`#board .square-${move.to}`).addClass("highlight-legal");
      }
    }

    function removeHighlights() {
      // Don't remove highlights if a piece is selected for click-to-move
      if (!selectedSquare) {
        $("#board .square-55d63").removeClass("highlight-legal");
      }
      // Don't remove premove highlights here - they're managed separately
    }

    function isPremoveLegal(from, to, piece) {
      // Validate if a premove would be theoretically legal for this piece type
      // on an empty board (or for pawns, with diagonal capture squares occupied)
      
      const fromFile = from.charCodeAt(0) - 'a'.charCodeAt(0);
      const fromRank = parseInt(from[1]) - 1;
      const toFile = to.charCodeAt(0) - 'a'.charCodeAt(0);
      const toRank = parseInt(to[1]) - 1;
      
      const fileDiff = Math.abs(toFile - fromFile);
      const rankDiff = Math.abs(toRank - fromRank);
      const fileDir = toFile - fromFile;
      const rankDir = toRank - fromRank;
      
      const pieceType = piece.type;
      const pieceColor = piece.color;
      
      switch(pieceType) {
        case 'p': // Pawn
          const direction = pieceColor === 'w' ? 1 : -1;
          const startRank = pieceColor === 'w' ? 1 : 6;
          
          // Forward one square
          if (fileDir === 0 && rankDir === direction) return true;
          
          // Forward two squares from starting position
          if (fileDir === 0 && rankDir === 2 * direction && fromRank === startRank) return true;
          
          // Diagonal capture (always allow for premoves since we assume piece could be there)
          if (fileDiff === 1 && rankDir === direction) return true;
          
          return false;
          
        case 'n': // Knight
          return (fileDiff === 2 && rankDiff === 1) || (fileDiff === 1 && rankDiff === 2);
          
        case 'b': // Bishop
          return fileDiff === rankDiff && fileDiff > 0;
          
        case 'r': // Rook
          return (fileDiff === 0 && rankDiff > 0) || (rankDiff === 0 && fileDiff > 0);
          
        case 'q': // Queen
          return (fileDiff === rankDiff && fileDiff > 0) || // Diagonal
                 (fileDiff === 0 && rankDiff > 0) ||        // Vertical
                 (rankDiff === 0 && fileDiff > 0);          // Horizontal
          
        case 'k': // King
          return fileDiff <= 1 && rankDiff <= 1 && (fileDiff > 0 || rankDiff > 0);
          
        default:
          return false;
      }
    }

    function clearPremove() {
      // Clear highlighting interval
      if (premoveHighlightInterval) {
        clearInterval(premoveHighlightInterval);
        premoveHighlightInterval = null;
      }
      
      if (premoves.length > 0 && board) {
        // Restore board position when clearing premoves since we actually moved pieces
        board.position(game.fen());
      }
      premoves = [];
      selectedSquare = null;
      // Clear premove highlights
      $("#board .square-55d63").removeClass("premove-highlight premove-source");
    }
    
    // Helper function to update board visual with all premoves applied
    function updatePremoveVisual() {
      if (!board || !game) return;
      
      // Clear any existing interval
      if (premoveHighlightInterval) {
        clearInterval(premoveHighlightInterval);
        premoveHighlightInterval = null;
      }
      
      if (premoves.length === 0) {
        // Reset board to actual game position
        board.position(game.fen());
        // Clear all premove highlights
        $("#board .square-55d63").removeClass("premove-highlight premove-source");
        return;
      }
      
      // Always start from the actual game position
      // First, reset board to actual game position to get clean state
      board.position(game.fen());
      
      // Use requestAnimationFrame to ensure board has updated, then apply premoves
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          const pos = board.position();
          if (!pos || Object.keys(pos).length === 0) {
            // If position is empty, try to get it directly from game.fen() by setting it again
            board.position(game.fen());
            setTimeout(() => updatePremoveVisual(), 50);
            return;
          }
          
          // Create a deep copy of the position object
          const newPos = {};
          for (const square in pos) {
            newPos[square] = pos[square];
          }
          
          // Track all squares involved in premoves for highlighting
          const highlightSquares = [];
          
          // Manually apply all premoves to show them visually
          // For each premove in sequence, move the piece from source to destination
          for (const pm of premoves) {
            const piece = newPos[pm.from];
            if (piece) {
              // Remove piece from source
              delete newPos[pm.from];
              // Place piece on destination (overwriting anything there, as premoves can capture)
              newPos[pm.to] = piece;
              // Track squares for highlighting (both source and destination)
              highlightSquares.push({ from: pm.from, to: pm.to });
            }
          }
          
          // Update board to show all premoves
          board.position(newPos);
          
          // Function to apply highlights - will be called repeatedly
          const applyHighlights = () => {
            // Clear all highlights first
            $("#board .square-55d63").removeClass("premove-highlight premove-source");
            
            // Apply highlights to all premove squares
            for (const sq of highlightSquares) {
              const fromSquare = $(`#board .square-${sq.from}`);
              const toSquare = $(`#board .square-${sq.to}`);
              
              if (fromSquare.length > 0) {
                fromSquare.addClass("premove-source");
              }
              if (toSquare.length > 0) {
                toSquare.addClass("premove-highlight");
              }
            }
          };
          
          // Clear all highlights first, then add red highlights for all premoves
          requestAnimationFrame(() => {
            applyHighlights();
            
            // Set up interval to continuously reapply highlights (they may be cleared by board updates)
            premoveHighlightInterval = setInterval(() => {
              if (premoves.length === 0) {
                clearInterval(premoveHighlightInterval);
                premoveHighlightInterval = null;
                board.position(game.fen());
                $("#board .square-55d63").removeClass("premove-highlight premove-source");
                return;
              }
              applyHighlights();
            }, 100);
          });
        });
      });
    }

    function handleSquareClick(square) {
      console.log('=== handleSquareClick START ===', square);
      const turn = game.turn();
      const isPlayerTurn = (playerColor === "white" && turn === "w") || (playerColor === "black" && turn === "b");
      const piece = game.get(square);  // Use game.get() to get piece from game state
      console.log('Turn:', turn, 'isPlayerTurn:', isPlayerTurn, 'piece:', piece, 'selectedSquare:', selectedSquare);
      
      // If there's a selected piece
      if (selectedSquare) {
        // If clicking the same square, deselect
        if (selectedSquare === square) {
          selectedSquare = null;
          removeHighlights();
          return;
        }
        
        // Check if this is a legal move or premove
        if (!isPlayerTurn) {
          // Make premove via click - allow any destination including recapturing own pieces
          // (might be currently illegal but could become legal after opponent moves)
          const premoveFrom = selectedSquare;
          const premoveTo = square;
          
          // Verify there's a piece at the source that belongs to the player
          const sourcePiece = game.get(premoveFrom);
          if (!sourcePiece || sourcePiece.color !== (playerColor === 'white' ? 'w' : 'b')) {
            selectedSquare = null;
            removeHighlights();
            return;
          }
          
          // Validate premove is theoretically legal for this piece type
          if (!isPremoveLegal(premoveFrom, premoveTo, sourcePiece)) {
            console.log('Premove not valid for piece type:', sourcePiece.type, premoveFrom, '->', premoveTo);
            selectedSquare = null;
            removeHighlights();
            return;
          }
          
          selectedSquare = null;
          removeHighlights();
          
          // Add new premove to the array (chain of premoves)
          const newPremove = { from: premoveFrom, to: premoveTo };
          premoves.push(newPremove);
          premoveJustSet = true;
          console.log('Premove added via click:', newPremove, 'Total premoves:', premoves.length);
          
          // Update visual to show all premoves in the chain
          updatePremoveVisual();
          return;
        } else {
          // Try to make a normal move
          const moveFrom = selectedSquare;
          const moveTo = square;
          console.log('Attempting move from', moveFrom, 'to', moveTo);
          const testMove = game.move({ from: moveFrom, to: moveTo, promotion: 'q' });
          console.log('Test move result:', testMove);
          
          if (testMove) {
            // Legal move - undo the test move, then execute properly
            game.undo();
            clearPremove();
            selectedSquare = null;
            removeHighlights();
            console.log('Calling handleMove');
            handleMove(moveFrom, moveTo);
            return;
          } else if (piece) {
            const pieceColorFull = piece.color === 'w' ? 'white' : 'black';
            if (pieceColorFull === playerColor) {
              // Illegal move but clicked on own piece - change selection
              console.log('Switching selection to', square);
              // Clear old highlights before selecting new piece
              $("#board .square-55d63").removeClass("highlight-legal");
              selectedSquare = square;
              highlightLegalMoves(square);
              return;
            }
          }
          
          // Invalid move, deselect
          console.log('Invalid move, deselecting');
          selectedSquare = null;
          removeHighlights();
          return;
        }
      }
      
      // No piece selected - select clicked piece if valid
      if (piece) {
        const pieceColorFull = piece.color === 'w' ? 'white' : 'black';
        if (pieceColorFull === playerColor) {
          // Allow selecting own pieces even during opponent's turn (for premoves)
          console.log('Setting selectedSquare to:', square);
          // Clear old highlights before selecting new piece
          $("#board .square-55d63").removeClass("highlight-legal");
          selectedSquare = square;
          highlightLegalMoves(square);
          console.log('After setting, selectedSquare is:', selectedSquare);
        }
      } else {
        // Clicked on empty square with no piece selected
        // Cancel all premoves if it's the opponent's turn (when premoves can be set)
        if (!isPlayerTurn && premoves.length > 0) {
          console.log('Empty square clicked during opponent turn, canceling all premoves');
          clearPremove();
        }
      }
    }

    function detectOpening() {
      const history = game.history();
      let movesStr = history.join(" ");
      
      // Check for exact matches, starting with longest sequences
      const sortedOpenings = Object.keys(openingBook).sort((a, b) => b.length - a.length);
      
      for (let opening of sortedOpenings) {
        if (movesStr.startsWith(opening)) {
          return openingBook[opening];
        }
      }
      
      return null;
    }

    function updateOpeningDisplay() {
      const opening = detectOpening();
      const openingNameEl = document.getElementById("opening-name");
      
      if (opening) {
        openingNameEl.textContent = opening;
        document.getElementById("opening-display").style.display = "block";
      } else if (game.history().length > 10) {
        openingNameEl.textContent = "General Position";
        document.getElementById("opening-display").style.display = "block";
      }
    }

    function highlightLastMove(from, to) {
      // Remove previous highlights
      $("#board .square-55d63").removeClass("highlight-last-move");
      
      // Add new highlights
      if (from && to) {
        $("#board .square-" + from).addClass("highlight-last-move");
        $("#board .square-" + to).addClass("highlight-last-move");
      }
    }

    function highlightCheck() {
      // Remove previous check highlights
      $("#board .square-55d63").removeClass("highlight-check");
      
      if (game.in_check()) {
        const turn = game.turn();
        const kingSquare = findKingSquare(turn);
        if (kingSquare) {
          $("#board .square-" + kingSquare).addClass("highlight-check");
        }
      }
    }

    function findKingSquare(color) {
      const board = game.board();
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          const piece = board[i][j];
          if (piece && piece.type === 'k' && piece.color === color) {
            const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
            return files[j] + (8 - i);
          }
        }
      }
      return null;
    }

    function updateGameStats() {
      // Update captured pieces display
      updateCapturedPieces();
      
      // Calculate and update material balance
      updateMaterialBalance();
      
      // Update game phase - more accurate detection
      const moveCount = game.history().length;
      const phaseEl = document.getElementById("game-phase");
      
      // Count pieces and check game state for more accurate phase detection
      const boardState = game.board();
      let pieceCount = 0;
      let queenCount = 0;
      let rookCount = 0;
      
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          const piece = boardState[i][j];
          if (piece) {
            pieceCount++;
            if (piece.type === 'q') queenCount++;
            else if (piece.type === 'r') rookCount++;
          }
        }
      }
      
      // More accurate phase detection
      // Opening: first 15-20 moves, most pieces still on board, queens present
      // Middlegame: pieces developed, material exchanges happening, queens usually still present
      // Endgame: few pieces left, queens often traded, or very low material
      if (pieceCount <= 12 || (queenCount === 0 && pieceCount <= 18)) {
        // Endgame: very few pieces or queens traded with low material
        phaseEl.textContent = "Endgame";
        phaseEl.style.color = "#e74c3c";
      } else if (moveCount >= 20 && pieceCount > 20 && queenCount > 0) {
        // Middlegame: enough moves played, good material, queens present
        phaseEl.textContent = "Middlegame";
        phaseEl.style.color = "#2ecc71";
      } else if (moveCount >= 15 && (pieceCount <= 20 || rookCount >= 2)) {
        // Transition to middlegame: pieces developed or material exchanges
        phaseEl.textContent = "Middlegame";
        phaseEl.style.color = "#2ecc71";
      } else {
        // Opening: early game, most pieces on board
        phaseEl.textContent = "Opening";
        phaseEl.style.color = "#3498db";
      }
      
      // Update pieces count display
      document.getElementById("pieces-count").textContent = pieceCount;
      
      // Update check status
      const checkEl = document.getElementById("check-status");
      if (game.in_check()) {
        const turn = game.turn();
        checkEl.textContent = turn === 'w' ? "White in Check" : "Black in Check";
        checkEl.style.color = "#e74c3c";
        checkEl.style.fontWeight = "700";
      } else {
        checkEl.textContent = "None";
        checkEl.style.color = "#7f8c8d";
        checkEl.style.fontWeight = "500";
      }
      
      // Update castling rights
      const fen = game.fen();
      const castlingRights = fen.split(' ')[2];
      const castlingEl = document.getElementById("castling-rights");
      if (castlingRights === '-') {
        castlingEl.textContent = "None";
        castlingEl.style.color = "#7f8c8d";
      } else {
        const whiteCanCastle = castlingRights.includes('K') || castlingRights.includes('Q');
        const blackCanCastle = castlingRights.includes('k') || castlingRights.includes('q');
        if (whiteCanCastle && blackCanCastle) {
          castlingEl.textContent = "Both";
          castlingEl.style.color = "#2ecc71";
        } else if (whiteCanCastle) {
          castlingEl.textContent = "White Only";
          castlingEl.style.color = "#3498db";
        } else if (blackCanCastle) {
          castlingEl.textContent = "Black Only";
          castlingEl.style.color = "#34495e";
        } else {
          castlingEl.textContent = "None";
          castlingEl.style.color = "#7f8c8d";
        }
      }
    }

    function updateCapturedPieces() {
      const whiteCapDiv = document.getElementById("white-captures-display");
      const blackCapDiv = document.getElementById("black-captures-display");
      
      whiteCapDiv.innerHTML = capturedPieces.white.length > 0 ? 
        capturedPieces.white.map(p => `<div class="captured-piece" style="background-image: url('lib/img/chesspieces/wikipedia/${p}.png')"></div>`).join('') :
        '';
      
      blackCapDiv.innerHTML = capturedPieces.black.length > 0 ? 
        capturedPieces.black.map(p => `<div class="captured-piece" style="background-image: url('lib/img/chesspieces/wikipedia/${p}.png')"></div>`).join('') :
        '';
    }

    function updateMaterialBalance() {
      const pieceValues = { p: 1, n: 3, b: 3, r: 5, q: 9, k: 0 };
      
      let whiteMaterial = 0;
      let blackMaterial = 0;
      
      const board = game.board();
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          const piece = board[i][j];
          if (piece) {
            const value = pieceValues[piece.type];
            if (piece.color === 'w') {
              whiteMaterial += value;
            } else {
              blackMaterial += value;
            }
          }
        }
      }
      
      const difference = whiteMaterial - blackMaterial;
      const balanceEl = document.getElementById("material-balance");
      
      balanceEl.classList.remove('positive', 'negative', 'equal');
      
      if (difference > 0) {
        balanceEl.textContent = `White +${difference}`;
        balanceEl.classList.add('positive');
      } else if (difference < 0) {
        balanceEl.textContent = `Black +${Math.abs(difference)}`;
        balanceEl.classList.add('negative');
      } else {
        balanceEl.textContent = 'Equal';
        balanceEl.classList.add('equal');
      }
    }

    function trackCapturedPiece(move) {
      if (!move) {
        console.warn('trackCapturedPiece called with null/undefined move');
        return;
      }
      const isPlayerMove = (move.color === 'w' && playerColor === 'white') || (move.color === 'b' && playerColor === 'black');
      const isOpponentMove = !isPlayerMove;
      
      if (move.captured) {
        const capturedPieceCode = move.color === 'w' ? 'b' + move.captured.toUpperCase() : 'w' + move.captured.toUpperCase();
        if (move.color === 'w') {
          capturedPieces.white.push(capturedPieceCode);
        } else {
          capturedPieces.black.push(capturedPieceCode);
        }
        
        // Track captures by piece type for achievements (only player's captures)
        if (isPlayerMove) {
          gameStats.totalCaptures++;
          
          const pieceType = move.captured.toLowerCase();
          if (pieceType === 'q') {
            gameStats.capturesByQueen++;
            // Also track that we captured a queen
            gameStats.capturedQueens++;
          } else if (pieceType === 'r') {
            gameStats.capturesByRook++;
            gameStats.capturedRooks++;
          } else if (pieceType === 'b') {
            gameStats.capturesByBishop++;
            gameStats.capturedBishops++;
          } else if (pieceType === 'n') {
            gameStats.capturesByKnight++;
            gameStats.capturedKnights++;
          } else if (pieceType === 'p') {
            gameStats.capturesByPawn++;
            gameStats.capturedPawns++;
          }
          // Track captured piece types for daily challenge
          if (gameStats.dailyStats && !gameStats.dailyStats.capturedPieceTypes.includes(pieceType)) {
            gameStats.dailyStats.capturedPieceTypes.push(pieceType);
          }
        }
        
        // If opponent captured one of our pieces, reset the "no pieces lost" streak
        if (isOpponentMove && gameStats.dailyStats) {
          gameStats.dailyStats.currentStreakNoPiecesLost = 0;
        }
      } else {
        // No capture happened - if it's a player move, increment the streak
        if (isPlayerMove && gameStats.dailyStats) {
          if (gameStats.dailyStats.currentStreakNoPiecesLost === undefined) {
            gameStats.dailyStats.currentStreakNoPiecesLost = 0;
          }
          gameStats.dailyStats.currentStreakNoPiecesLost++;
        }
      }
      
      // Track other move types
      if (isPlayerMove) {
        if (move.flags && move.flags.includes('k')) {
          gameStats.castlingMoves++;
        }
        if (move.promotion) {
          gameStats.promotions++;
        }
        if (move.flags && move.flags.includes('e')) {
          gameStats.enPassants++;
          // Track games with en passant for daily challenge
          if (gameStats.dailyStats && !gameStats.dailyStats.hasEnPassant) {
            gameStats.dailyStats.hasEnPassant = true;
          }
        }
        if (move.san && move.san.includes('+')) {
          gameStats.checksGiven++;
          // Track max checks in this game for daily challenge
          if (gameStats.dailyStats) {
            gameStats.dailyStats.maxChecksInGame = Math.max(gameStats.dailyStats.maxChecksInGame || 0, gameStats.checksGiven);
            // Track consecutive checks for windmill challenge
            gameStats.dailyStats.consecutiveChecks = (gameStats.dailyStats.consecutiveChecks || 0) + 1;
            gameStats.dailyStats.maxConsecutiveChecks = Math.max(gameStats.dailyStats.maxConsecutiveChecks || 0, gameStats.dailyStats.consecutiveChecks);
          }
        } else {
          // Reset consecutive checks if no check
          if (gameStats && gameStats.dailyStats) {
            gameStats.dailyStats.consecutiveChecks = 0;
          }
        }
      }
    }

    function trackRandomAchievements(move, source, target) {
      const isPlayerMove = (move.color === 'w' && playerColor === 'white') || (move.color === 'b' && playerColor === 'black');
      if (!isPlayerMove) return;
      
      const gameMoveNumber = game.history().length;
      // Calculate player's move number (1st move, 2nd move, etc. for the player)
      const playerMoveNumber = playerColor === 'white' 
        ? Math.floor((gameMoveNumber + 1) / 2)  // White plays on odd moves: 1,3,5... -> 1,2,3...
        : Math.floor(gameMoveNumber / 2);        // Black plays on even moves: 2,4,6... -> 1,2,3...
      
      const pieceType = move.piece.toLowerCase();
      
      // Track moves to specific squares (in gameStats, not lifetimeStats)
      if (target === 'e4') {
        gameStats.movesToE4++;
        gameStats.movesToE4Multiple++;
        if (pieceType === 'p') gameStats.pawnToE4++;
      }
      if (target === 'd4') {
        gameStats.movesToD4++;
        gameStats.movesToD4Multiple++;
        if (pieceType === 'p') gameStats.pawnToD4++;
      }
      if (target === 'e5') gameStats.movesToE5++;
      if (target === 'd5') gameStats.movesToD5++;
      
      // Track knight moves to specific squares
      if (pieceType === 'n') {
        if (target === 'f3') {
          gameStats.knightToF3++;
          gameStats.knightToF3Multiple++;
        }
        if (target === 'c3') {
          gameStats.knightToC3++;
          gameStats.knightToC3Multiple++;
        }
        if (target === 'f6') gameStats.knightToF6++;
        if (target === 'c6') gameStats.knightToC6++;
        
        // Simplified knight fork detection: if knight captures and attacks another piece
        // This is a simplified check - full fork detection would require position analysis
        if (move.captured && gameStats && gameStats.dailyStats) {
          // Increment fork count (simplified - assumes any knight capture might be a fork)
          gameStats.dailyStats.knightForks = (gameStats.dailyStats.knightForks || 0) + 1;
        }
      }
      
      // Track moves on specific player move numbers (e.g., "on your 5th move")
      if (playerMoveNumber === 1) gameStats.movesOnMove1++;
      if (playerMoveNumber === 5) gameStats.movesOnMove5++;
      if (playerMoveNumber === 10) gameStats.movesOnMove10++;
      if (playerMoveNumber === 20) gameStats.movesOnMove20++;
      if (playerMoveNumber === 50) gameStats.movesOnMove50++;
      
      // Track specific piece moves to specific squares
      if (pieceType === 'q') {
        if (target === 'd4') {
          gameStats.queenToD4++;
          gameStats.queenToD4Multiple++;
        }
        if (target === 'e4') gameStats.queenToE4++;
      }
      if (pieceType === 'b' && target === 'f4') gameStats.bishopToF4++;
      if (pieceType === 'b' && target === 'c1') gameStats.bishopToC1++;
      if (pieceType === 'b' && target === 'f1') gameStats.bishopToF1++;
      if (pieceType === 'b' && target === 'c8') gameStats.bishopToC8++;
      if (pieceType === 'b' && target === 'f8') gameStats.bishopToF8++;
      
      // Track bishop moves in blindfold mode (for daily challenge)
      // Check blindfold mode explicitly - it should be set when game starts
      const isBlindfoldActive = typeof blindfoldMode !== 'undefined' && blindfoldMode === true;
      const isPureBlindfold = isBlindfoldActive && typeof showHistoryInBlindfold !== 'undefined' && showHistoryInBlindfold === false;
      
      if (pieceType === 'b' && isBlindfoldActive && gameStats && gameStats.dailyStats) {
        if (!gameStats.dailyStats.bishopMovesInBlindfoldToday) {
          gameStats.dailyStats.bishopMovesInBlindfoldToday = 0;
        }
        gameStats.dailyStats.bishopMovesInBlindfoldToday++;
        console.log('Blindfold bishop move tracked:', gameStats.dailyStats.bishopMovesInBlindfoldToday);
      }
      
      // Track knight moves in pure blindfold (no history) for daily challenge
      if (pieceType === 'n' && isPureBlindfold && gameStats && gameStats.dailyStats) {
        if (!gameStats.dailyStats.knightMovesInPureBlindfoldToday) {
          gameStats.dailyStats.knightMovesInPureBlindfoldToday = 0;
        }
        gameStats.dailyStats.knightMovesInPureBlindfoldToday++;
      }
      
      // Track king moves for daily challenge
      if (pieceType === 'k' && gameStats && gameStats.dailyStats) {
        gameStats.dailyStats.kingMoves = (gameStats.dailyStats.kingMoves || 0) + 1;
      }
      
      // Track piece types moved for daily challenge
      if (gameStats && gameStats.dailyStats && !gameStats.dailyStats.pieceTypesMoved.includes(pieceType)) {
        gameStats.dailyStats.pieceTypesMoved.push(pieceType);
      }
      
      // Track e-file squares visited for daily challenge
      if (target && target[0] === 'e' && gameStats && gameStats.dailyStats) {
        if (!gameStats.dailyStats.eFileSquaresVisited.includes(target)) {
          gameStats.dailyStats.eFileSquaresVisited.push(target);
        }
      }
      
      // Track queen visiting corner squares for daily challenge
      if (pieceType === 'q' && gameStats && gameStats.dailyStats) {
        const corners = ['a1', 'h1', 'a8', 'h8'];
        if (corners.includes(target) && !gameStats.dailyStats.queenVisitedCorners.includes(target)) {
          gameStats.dailyStats.queenVisitedCorners.push(target);
        }
      }
      
      // Track rooks on 7th/2nd rank for daily challenge
      if (pieceType === 'r' && gameStats && gameStats.dailyStats) {
        const rank = parseInt(target[1]);
        const targetRank = playerColor === 'white' ? 7 : 2;
        if (rank === targetRank && !gameStats.dailyStats.rooksOnSeventhRank) {
          gameStats.dailyStats.rooksOnSeventhRank = 0;
        }
        // Check if rook is on target rank
        const board = game.board();
        let rooksOnRank = 0;
        for (let i = 0; i < 8; i++) {
          const square = String.fromCharCode(97 + i) + targetRank;
          const piece = game.get(square);
          if (piece && piece.type === 'r' && piece.color === (playerColor === 'white' ? 'w' : 'b')) {
            rooksOnRank++;
          }
        }
        if (rooksOnRank >= 2) {
          gameStats.dailyStats.rooksOnSeventhRank = 2;
        }
      }
      
      // Track pawns advanced to 6th/3rd rank for daily challenge
      if (pieceType === 'p' && gameStats && gameStats.dailyStats) {
        const rank = parseInt(target[1]);
        const targetRank = playerColor === 'white' ? 6 : 3;
        if (rank === targetRank && !gameStats.dailyStats.pawnsAdvancedToSixth.includes(target)) {
          gameStats.dailyStats.pawnsAdvancedToSixth.push(target);
        }
      }
      
      // Track center squares occupied for daily challenge
      const centerSquares = ['d4', 'd5', 'e4', 'e5'];
      if (centerSquares.includes(target) && gameStats && gameStats.dailyStats) {
        if (!gameStats.dailyStats.centerSquaresOccupied.includes(target)) {
          gameStats.dailyStats.centerSquaresOccupied.push(target);
        }
      }
      
      // Track streak of moves without losing pieces
      // Initialize streak counter if needed
      if (gameStats.dailyStats && gameStats.dailyStats.currentStreakNoPiecesLost === undefined) {
        gameStats.dailyStats.currentStreakNoPiecesLost = 0;
      }
      if (pieceType === 'r' && target === 'e1') gameStats.rookToE1++;
      if (pieceType === 'r' && target === 'a1') gameStats.rookToA1++;
      if (pieceType === 'r' && target === 'h1') gameStats.rookToH1++;
      if (pieceType === 'r' && target === 'a8') gameStats.rookToA8++;
      if (pieceType === 'r' && target === 'h8') gameStats.rookToH8++;
      if (pieceType === 'k' && target === 'e1') gameStats.kingToE1++;
      if (pieceType === 'k' && target === 'g1') gameStats.kingToG1++;
      if (pieceType === 'k' && target === 'c1') gameStats.kingToC1++;
      if (pieceType === 'k' && target === 'g8') gameStats.kingToG8++;
      if (pieceType === 'k' && target === 'c8') gameStats.kingToC8++;
      if (pieceType === 'n' && target === 'g1') gameStats.knightToG1++;
      if (pieceType === 'n' && target === 'b1') gameStats.knightToB1++;
      if (pieceType === 'n' && target === 'g8') gameStats.knightToG8++;
      if (pieceType === 'n' && target === 'b8') gameStats.knightToB8++;
      if (pieceType === 'q' && target === 'a1') gameStats.queenToA1++;
      if (pieceType === 'q' && target === 'h1') gameStats.queenToH1++;
      if (pieceType === 'q' && target === 'a8') gameStats.queenToA8++;
      if (pieceType === 'q' && target === 'h8') gameStats.queenToH8++;
      if (pieceType === 'p' && target === 'a2') gameStats.pawnToA2++;
      if (pieceType === 'p' && target === 'h2') gameStats.pawnToH2++;
      if (pieceType === 'p' && target === 'a7') gameStats.pawnToA7++;
      if (pieceType === 'p' && target === 'h7') gameStats.pawnToH7++;
      
      // Track daily stats (temporary for this game)
      gameStats.dailyStats.movesMadeToday++;
      if (move.captured) gameStats.dailyStats.capturesToday++;
      if (move.san && move.san.includes('+')) gameStats.dailyStats.checksGivenToday++;
      if (!gameStats.dailyStats.uniqueSquaresVisitedToday.includes(target)) {
        gameStats.dailyStats.uniqueSquaresVisitedToday.push(target);
      }
      
      // Track promotions
      if (move.promotion) {
        // Track promotion count for daily challenge
        if (gameStats && gameStats.dailyStats) {
          gameStats.dailyStats.promotionsInGame = (gameStats.dailyStats.promotionsInGame || 0) + 1;
          gameStats.dailyStats.promotionsToday = (gameStats.dailyStats.promotionsToday || 0) + 1;
        }
        
        if (move.promotion === 'q') {
          gameStats.promotedToQueen++;
          gameStats.promotedToQueenMultiple++;
          if (gameStats.dailyStats && !gameStats.dailyStats.promotionTypes.includes('q')) {
            gameStats.dailyStats.promotionTypes.push('q');
          }
        }
        if (move.promotion === 'r') {
          gameStats.promotedToRook++;
          lifetimeStats.underpromotions = (lifetimeStats.underpromotions || 0) + 1;
          // Track underpromotion for daily challenge
          if (gameStats.dailyStats) {
            gameStats.dailyStats.hasUnderpromotion = true;
            if (!gameStats.dailyStats.promotionTypes.includes('r')) {
              gameStats.dailyStats.promotionTypes.push('r');
            }
          }
        }
        if (move.promotion === 'b') {
          gameStats.promotedToBishop++;
          lifetimeStats.underpromotions = (lifetimeStats.underpromotions || 0) + 1;
          if (gameStats.dailyStats) {
            gameStats.dailyStats.hasUnderpromotion = true;
            if (!gameStats.dailyStats.promotionTypes.includes('b')) {
              gameStats.dailyStats.promotionTypes.push('b');
            }
          }
        }
        if (move.promotion === 'n') {
          gameStats.promotedToKnight++;
          lifetimeStats.underpromotions = (lifetimeStats.underpromotions || 0) + 1;
          if (gameStats.dailyStats) {
            gameStats.dailyStats.hasUnderpromotion = true;
            if (!gameStats.dailyStats.promotionTypes.includes('n')) {
              gameStats.dailyStats.promotionTypes.push('n');
            }
          }
        }
        if (move.promotion === 'q' && gameStats.dailyStats) {
          if (!gameStats.dailyStats.promotionTypes.includes('q')) {
            gameStats.dailyStats.promotionTypes.push('q');
          }
        }
      }
      
      // Track castling on specific player move numbers
      if (move.flags && move.flags.includes('k')) {
        if (playerMoveNumber === 10) gameStats.castledOnMove10++;
        if (playerMoveNumber === 20) gameStats.castledOnMove20++;
        gameStats.dailyStats.castlingToday++; // Track daily castling
        // Track castling type for daily challenge
        if (gameStats.dailyStats) {
          const castlingType = move.san.includes('O-O-O') ? 'q' : 'k'; // queenside or kingside
          if (!gameStats.dailyStats.castlingTypes.includes(castlingType)) {
            gameStats.dailyStats.castlingTypes.push(castlingType);
          }
        }
      }
      
      // Track checks on specific player move numbers (skip move 1 as it's impossible)
      if (move.san && move.san.includes('+')) {
        if (playerMoveNumber === 5) gameStats.checkOnMove5++;
      }
      
      // Track captures on specific player move numbers (skip move 1 as it's impossible for white)
      if (move.captured) {
        if (playerMoveNumber === 10) gameStats.captureOnMove10++;
      }
    }

    function celebrateDraw(drawReason) {
      console.log('celebrateDraw called, reason:', drawReason);
      
      // === DRAW CELEBRATION - UNIQUE ANIMATION ===
      
      // Screen flash effect (orange/yellow gradient)
      const screenFlash = document.createElement('div');
      screenFlash.style.position = 'fixed';
      screenFlash.style.top = '0';
      screenFlash.style.left = '0';
      screenFlash.style.width = '100%';
      screenFlash.style.height = '100%';
      screenFlash.style.background = 'radial-gradient(circle, rgba(243, 156, 18, 0.4) 0%, rgba(230, 126, 34, 0.3) 50%, transparent 100%)';
      screenFlash.style.pointerEvents = 'none';
      screenFlash.style.zIndex = '9997';
      screenFlash.style.animation = 'screenFlash 1s ease-out';
      document.body.appendChild(screenFlash);
      setTimeout(() => screenFlash.remove(), 1000);

      // Draw text animation
      const drawText = document.createElement('div');
      drawText.className = 'draw-text';
      drawText.textContent = 'Draw!';
      drawText.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 4em;
        font-weight: 900;
        color: #f39c12;
        text-shadow: 0 0 30px rgba(243, 156, 18, 0.8), 0 0 60px rgba(230, 126, 34, 0.6);
        z-index: 9998;
        font-family: 'Inter', sans-serif;
        pointer-events: none;
      `;
      drawText.style.animation = 'textPop 1.2s ease-out';
      document.body.appendChild(drawText);
      setTimeout(() => {
        drawText.style.transition = 'opacity 0.5s ease-out';
        drawText.style.opacity = '0';
        setTimeout(() => drawText.remove(), 500);
      }, 2500);

      // Overlay for draw effects
        const overlay = document.createElement('div');
      overlay.className = 'draw-overlay';
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 9996;
      `;
        document.body.appendChild(overlay);

      // Generate orange/yellow confetti
      const colors = ['#F39C12', '#E67E22', '#D35400', '#F1C40F', '#F7DC6F', '#F8C471', '#F4D03F', '#F9E79F'];
      const shapes = ['circle', 'rect', 'star'];
      
        for (let i = 0; i < 200; i++) {
          setTimeout(() => {
            const confetti = document.createElement('div');
          const shape = shapes[Math.floor(Math.random() * shapes.length)];
          confetti.className = 'confetti ' + shape;
            confetti.style.left = Math.random() * 100 + '%';
          confetti.style.top = -20 + 'px';
            confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
          const size = Math.random() * 15 + 5;
          confetti.style.width = size + 'px';
          confetti.style.height = size + 'px';
            confetti.style.opacity = Math.random() * 0.5 + 0.5;
          const drift = (Math.random() - 0.5) * 150;
          confetti.style.setProperty('--drift', drift + 'px');
            confetti.style.animation = `confetti-fall ${(Math.random() * 2 + 2)}s linear forwards`;
          confetti.style.animationDelay = (Math.random() * 0.2) + 's';
            overlay.appendChild(confetti);
          setTimeout(() => confetti.remove(), 4000);
        }, i * 10);
      }

      // Gentle pulse effect on board (orange glow)
      const board = document.getElementById('board');
      if (board) {
        board.style.animation = 'drawPulse 1.5s ease-in-out 3';
        board.style.transition = 'all 0.3s ease';
        board.style.boxShadow = '0 0 80px rgba(243, 156, 18, 0.6), 0 0 120px rgba(230, 126, 34, 0.4)';
        setTimeout(() => {
          board.style.animation = '';
          board.style.boxShadow = '';
        }, 5000);
      }

      // Ripple effects from board center (orange)
      const boardRect = board ? board.getBoundingClientRect() : { left: window.innerWidth / 2, top: window.innerHeight / 2, width: 0, height: 0 };
      const centerX = boardRect.left + boardRect.width / 2;
      const centerY = boardRect.top + boardRect.height / 2;

      for (let r = 0; r < 4; r++) {
        setTimeout(() => {
          const ripple = document.createElement('div');
          ripple.style.cssText = `
            position: fixed;
            left: ${centerX}px;
            top: ${centerY}px;
            width: 30px;
            height: 30px;
            margin-left: -15px;
            margin-top: -15px;
            border: 3px solid rgba(243, 156, 18, 0.6);
            border-radius: 50%;
            pointer-events: none;
            z-index: 9995;
          `;
          ripple.style.animation = `drawRipple ${2}s ease-out`;
          document.body.appendChild(ripple);
          setTimeout(() => ripple.remove(), 2000);
        }, r * 300);
      }

      setTimeout(() => overlay.remove(), 5000);
    }

    function celebrateCheckmate(playerWon) {
      console.log('celebrateCheckmate called, playerWon:', playerWon);
      if (playerWon) {
        // === VICTORY CELEBRATION - ULTRA ENHANCED ===
        
        // Screen flash effect
        const screenFlash = document.createElement('div');
        screenFlash.style.position = 'fixed';
        screenFlash.style.top = '0';
        screenFlash.style.left = '0';
        screenFlash.style.width = '100%';
        screenFlash.style.height = '100%';
        screenFlash.style.background = 'radial-gradient(circle, rgba(46, 204, 113, 0.4) 0%, transparent 70%)';
        screenFlash.style.pointerEvents = 'none';
        screenFlash.style.zIndex = '9997';
        screenFlash.style.animation = 'screenFlash 0.8s ease-out';
        document.body.appendChild(screenFlash);
        setTimeout(() => screenFlash.remove(), 800);

        // Victory text animation
        const victoryText = document.createElement('div');
        victoryText.className = 'victory-text';
        victoryText.textContent = 'Victory!';
        victoryText.style.animation = 'textPop 1s ease-out';
        document.body.appendChild(victoryText);
        setTimeout(() => {
          victoryText.style.transition = 'opacity 0.5s ease-out';
          victoryText.style.opacity = '0';
          setTimeout(() => victoryText.remove(), 500);
        }, 2000);

        // Overlay for confetti
        const overlay = document.createElement('div');
        overlay.className = 'checkmate-overlay';
        document.body.appendChild(overlay);

        // Generate MASSIVE confetti with different shapes and trajectories
        const colors = ['#FFD700', '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE', '#2ECC71', '#3498DB', '#FF1493', '#00CED1', '#FFD700', '#FF4500'];
        const shapes = ['circle', 'rect', 'star'];
        
        for (let i = 0; i < 400; i++) {
          setTimeout(() => {
            const confetti = document.createElement('div');
            const shape = shapes[Math.floor(Math.random() * shapes.length)];
            confetti.className = 'confetti ' + shape;
            confetti.style.left = Math.random() * 100 + '%';
            confetti.style.top = -20 + 'px';
            confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
            const size = Math.random() * 20 + 6;
            confetti.style.width = size + 'px';
            confetti.style.height = size + 'px';
            confetti.style.opacity = Math.random() * 0.6 + 0.4;
            const drift = (Math.random() - 0.5) * 200;
            confetti.style.setProperty('--drift', drift + 'px');
            confetti.style.animation = `confetti-fall ${(Math.random() * 2 + 2.5)}s linear forwards`;
            confetti.style.animationDelay = (Math.random() * 0.3) + 's';
            overlay.appendChild(confetti);
            setTimeout(() => confetti.remove(), 5000);
          }, i * 8);
        }

        // Fireworks explosions from board center
        const board = document.getElementById('board');
        const boardRect = board.getBoundingClientRect();
        const centerX = boardRect.left + boardRect.width / 2;
        const centerY = boardRect.top + boardRect.height / 2;

        // Multiple firework bursts
        for (let burst = 0; burst < 8; burst++) {
          setTimeout(() => {
            const numParticles = 30;
            for (let i = 0; i < numParticles; i++) {
              const angle = (Math.PI * 2 * i) / numParticles;
              const distance = 100 + Math.random() * 150;
              const particle = document.createElement('div');
              particle.className = 'particle';
              const tx = Math.cos(angle) * distance;
              const ty = Math.sin(angle) * distance;
              particle.style.setProperty('--tx', tx + 'px');
              particle.style.setProperty('--ty', ty + 'px');
              particle.style.left = centerX + 'px';
              particle.style.top = centerY + 'px';
              particle.style.background = colors[Math.floor(Math.random() * colors.length)];
              particle.style.animation = `particleTrail ${0.8 + Math.random() * 0.4}s ease-out forwards`;
              document.body.appendChild(particle);
              setTimeout(() => particle.remove(), 1200);
            }
          }, burst * 300);
        }

        // Enhanced sparkles around the board
        for (let i = 0; i < 60; i++) {
          setTimeout(() => {
            const sparkle = document.createElement('div');
            sparkle.className = 'sparkle';
            const angle = (Math.PI * 2 * i) / 60;
            const distance = 250 + Math.random() * 200;
            sparkle.style.left = (centerX + Math.cos(angle) * distance) + 'px';
            sparkle.style.top = (centerY + Math.sin(angle) * distance) + 'px';
            sparkle.style.width = (15 + Math.random() * 20) + 'px';
            sparkle.style.height = sparkle.style.width;
            sparkle.style.animation = `sparkle ${0.6 + Math.random() * 0.6}s ease-out`;
            document.body.appendChild(sparkle);
            setTimeout(() => sparkle.remove(), 1500);
          }, i * 30);
        }

        // Ripple effects from board center
        for (let r = 0; r < 5; r++) {
          setTimeout(() => {
            const ripple = document.createElement('div');
            ripple.className = 'ripple';
            ripple.style.left = centerX + 'px';
            ripple.style.top = centerY + 'px';
            ripple.style.width = '20px';
            ripple.style.height = '20px';
            ripple.style.marginLeft = '-10px';
            ripple.style.marginTop = '-10px';
            ripple.style.animation = `ripple ${1.5}s ease-out`;
            document.body.appendChild(ripple);
            setTimeout(() => ripple.remove(), 1500);
          }, r * 200);
        }

        // ULTRA dramatic victory pulse with rotation and enhanced glow
        board.style.animation = 'victoryPulse 0.8s ease-in-out 6';
        board.style.transition = 'all 0.3s ease';
        setTimeout(() => {
          board.style.animation = '';
          board.style.filter = '';
          board.style.boxShadow = '';
        }, 5000);

        setTimeout(() => overlay.remove(), 6000);
      } else {
        // === DEFEAT ANIMATION - ULTRA ENHANCED ===
        
        // Screen flash effect (red)
        const screenFlash = document.createElement('div');
        screenFlash.style.position = 'fixed';
        screenFlash.style.top = '0';
        screenFlash.style.left = '0';
        screenFlash.style.width = '100%';
        screenFlash.style.height = '100%';
        screenFlash.style.background = 'radial-gradient(circle, rgba(231, 76, 60, 0.5) 0%, rgba(139, 0, 0, 0.3) 50%, transparent 100%)';
        screenFlash.style.pointerEvents = 'none';
        screenFlash.style.zIndex = '9997';
        screenFlash.style.animation = 'screenFlash 1.2s ease-out';
        document.body.appendChild(screenFlash);
        setTimeout(() => screenFlash.remove(), 1200);

        // Defeat text animation
        const defeatText = document.createElement('div');
        defeatText.className = 'defeat-text';
        defeatText.textContent = 'Defeat!';
        defeatText.style.animation = 'textPop 0.8s ease-out';
        document.body.appendChild(defeatText);
        setTimeout(() => {
          defeatText.style.transition = 'opacity 0.5s ease-out';
          defeatText.style.opacity = '0';
          setTimeout(() => defeatText.remove(), 500);
        }, 2000);

        const overlay = document.createElement('div');
        overlay.className = 'defeat-overlay';
        document.body.appendChild(overlay);

        // Shake the entire game container with more intensity
        const gameContainer = document.getElementById('game-container');
        if (gameContainer) {
          gameContainer.style.animation = 'defeatPulse 2s ease-out';
          gameContainer.style.filter = 'brightness(0.8)';
          setTimeout(() => {
            gameContainer.style.animation = '';
            gameContainer.style.filter = '';
          }, 2000);
        }

        // Shake the entire page
        document.body.style.animation = 'defeatShake 2s ease-in-out';
        setTimeout(() => {
          document.body.style.animation = '';
        }, 2000);

        const board = document.getElementById('board');
        
        // ULTRA intense shake with massive red glow and distortion
        board.style.animation = 'defeatShake 2s ease-in-out';
        board.style.boxShadow = '0 0 100px 30px rgba(220, 53, 69, 1), inset 0 0 60px rgba(220, 53, 69, 0.5), 0 0 150px rgba(139, 0, 0, 0.8)';
        board.style.filter = 'brightness(0.6) saturate(1.8) contrast(1.2)';
        board.style.border = '4px solid rgba(220, 53, 69, 0.8)';
        
        // Red particles falling from board
        const boardRect = board.getBoundingClientRect();
        for (let i = 0; i < 50; i++) {
          setTimeout(() => {
            const particle = document.createElement('div');
            particle.style.position = 'fixed';
            particle.style.width = '6px';
            particle.style.height = '6px';
            particle.style.background = 'rgba(220, 53, 69, 0.9)';
            particle.style.borderRadius = '50%';
            particle.style.left = (boardRect.left + Math.random() * boardRect.width) + 'px';
            particle.style.top = boardRect.top + 'px';
            particle.style.zIndex = '10000';
            particle.style.pointerEvents = 'none';
            particle.style.animation = `confetti-fall ${1 + Math.random()}s linear forwards`;
            particle.style.setProperty('--drift', (Math.random() - 0.5) * 50 + 'px');
            document.body.appendChild(particle);
            setTimeout(() => particle.remove(), 2000);
          }, i * 30);
        }
        
        setTimeout(() => {
          board.style.animation = '';
          board.style.boxShadow = '';
          board.style.filter = '';
          board.style.border = '';
        }, 2000);

        // Remove overlay after animation
        setTimeout(() => overlay.remove(), 2500);
      }
    }

    function exportPGN() {
      const date = new Date();
      const dateStr = date.toISOString().split('T')[0].replace(/-/g, '.');
      
      let pgn = '[Event "Chess vs TrifangX"]\n';
      pgn += '[Site "Ahrens Labs"]\n';
      pgn += `[Date "${dateStr}"]\n`;
      pgn += '[Round "1"]\n';
      pgn += `[White "${playerColor === 'white' ? 'Player' : 'TrifangX'}"]\n`;
      pgn += `[Black "${playerColor === 'black' ? 'Player' : 'TrifangX'}"]\n`;
      
      let result = '*';
      if (game.in_checkmate()) {
        result = game.turn() === 'w' ? '0-1' : '1-0';
      } else if (game.in_draw() || game.in_stalemate() || game.in_threefold_repetition()) {
        result = '1/2-1/2';
      }
      pgn += `[Result "${result}"]\n\n`;
      
      const history = game.history();
      let moveText = '';
      for (let i = 0; i < history.length; i++) {
        if (i % 2 === 0) {
          moveText += `${Math.floor(i / 2) + 1}. `;
        }
        moveText += history[i] + ' ';
        if (i % 2 === 1) {
          moveText += '\n';
        }
      }
      
      pgn += moveText.trim() + ` ${result}`;
      
      // Create download
      const blob = new Blob([pgn], { type: 'text/plain' });
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `chess_game_${dateStr}.pgn`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
    }
    
    function resignGame() {
      if (gameOver) return;
      
      // Position the modal directly above the resign button (popping out of it)
      const modal = document.getElementById('confirm-modal');
      const resignBtn = document.getElementById('resign-btn');
      
      // Show the modal first
      modal.classList.add('show');
      
      // Use requestAnimationFrame to ensure modal is rendered before getting dimensions
      requestAnimationFrame(() => {
        const modalRect = modal.getBoundingClientRect();
        const btnRect = resignBtn.getBoundingClientRect();
        
        // Position centered horizontally above the button with a small gap
        // Make it appear to "pop out" from the button
        const gap = 8; // 8px gap between button and modal
        modal.style.left = (btnRect.left + btnRect.width / 2 - modalRect.width / 2) + 'px';
        modal.style.top = (btnRect.top - modalRect.height - gap) + 'px';
        modal.style.position = 'fixed'; // Use fixed positioning relative to viewport
      });
    }

    function closeConfirmModal() {
      document.getElementById('confirm-modal').classList.remove('show');
    }

    function confirmResign() {
      closeConfirmModal();
      
      const winner = playerColor === 'white' ? 'black' : 'white';
      const moveContainer = document.getElementById("move-timer-container");
      moveContainer.innerHTML = `RESIGNATION! <span style="color:red;">You Lose!</span>`;
      gameOver = true;
      
      // Play losing celebration
      playSound('checkmate');
      celebrateCheckmate(false);
      
      // Update statistics
      playerStats.losses++;
      savePlayerStats();
      updatePlayerStatsDisplay();
      resetDailyStatsIfNeeded();
      lifetimeStats.dailyStats.gamesPlayedToday++;
      const moveCount = game.history().length;
      if (moveCount > lifetimeStats.dailyStats.longestGameToday) {
        lifetimeStats.dailyStats.longestGameToday = moveCount;
      }
      trackLossStats();
      commitGameStatsToLifetime();
      checkAndUnlockAchievements();
      
      // Send resignation to engine
      sendEngineCommand("resign").catch(err => console.error("Error sending resignation:", err));
      
      // Show rematch modal
      setTimeout(() => showRematchModal("You Resigned", "Would you like to play again?"), 2000);
    }

    function showRematchModal(title, message) {
      const modal = document.getElementById('rematch-modal');
      const titleEl = document.getElementById('rematch-title');
      const messageEl = document.getElementById('rematch-message');
      
      if (!modal || !titleEl || !messageEl) {
        console.error('Rematch modal elements not found');
        return;
      }
      
      titleEl.textContent = title;
      messageEl.textContent = message;
      
      // Reset any positioning styles
      modal.style.left = '';
      modal.style.top = '';
      modal.style.position = 'fixed';
      
      // Show the modal - it will be centered by flexbox
      modal.classList.add('show');
    }

    function closeRematchModal() {
      document.getElementById('rematch-modal').classList.remove('show');
    }

    function startRematch() {
      closeRematchModal();
      
      // Reset game state
      gameOver = false;
      
      // Reset game
      if (game) {
        game.reset();
      }
      moveHistory = [];
      currentMoveIndex = -1;
      capturedPieces = { white: [], black: [] };
      lastMoveSquares = { from: null, to: null };
      premoves = [];
      selectedSquare = null;
      resetGameStats();
      
      // Reset UI
      document.getElementById("move-timer-container").innerHTML = 'Time for this move: <span id="timer">00:00.00</span>';
      updateLastMove(null, "00:00.00", 0, 0);
      updateTurnDisplay();
      updateGameStats();
      updateOpeningDisplay();
      document.getElementById("opening-display").style.display = "none";
      
      // Reset board
      if (board) {
        board.position('start');
      }
      
      // Clear highlights
      $("#board .square-55d63").removeClass("highlight-last-move highlight-check premove-highlight premove-source");
      
      // Reset timers
      const timeOption = document.getElementById("time-control").value;
      if (timeOption !== "none") {
        const [base, inc] = timeOption.split("|").map(Number);
        whiteTime = base ? base * 1000 : 0;
        blackTime = base ? base * 1000 : 0;
        increment = inc || 0;
        timeLimited = true;
        document.getElementById("white-total").textContent = formatTime(whiteTime);
        document.getElementById("black-total").textContent = formatTime(blackTime);
        document.getElementById("timers-container").style.display = "flex";
      } else {
        timeLimited = false;
        document.getElementById("timers-container").style.display = "none";
      }
      
      // Clear notation
      document.getElementById("notation-container").innerHTML = '';
      
      // Start new game
      startTimer();
      
      // Restart engine
      sendEngineCommand("start").then(() => {
        applyEngineModifiers(currentEngineStyle);
        if (playerColor === "black") {
          engineMove();
        }
      }).catch(err => console.error("Error restarting engine:", err));
    }

    // === NEW FEATURE FUNCTIONS ===

    function flipBoard() {
      if (!board || !game) return;
      const currentOrientation = board.orientation();
      const newOrientation = currentOrientation === 'white' ? 'black' : 'white';
      board.orientation(newOrientation);
      playSound('move');
    }

    function playSound(type) {
      if (!soundEnabled) return;
      
      // Create audio context for sound generation
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      switch(type) {
        case 'move':
          oscillator.frequency.value = 400;
          oscillator.type = 'sine';
          gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext.currentTime + 0.1);
          break;
        case 'capture':
          oscillator.frequency.value = 600;
          oscillator.type = 'square';
          gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext.currentTime + 0.15);
          break;
        case 'check':
          oscillator.frequency.value = 800;
          oscillator.type = 'sine';
          gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext.currentTime + 0.2);
          break;
        case 'checkmate':
          // Victory sound
          [400, 500, 600, 700].forEach((freq, i) => {
            setTimeout(() => {
              const osc = audioContext.createOscillator();
              const gain = audioContext.createGain();
              osc.connect(gain);
              gain.connect(audioContext.destination);
              osc.frequency.value = freq;
              osc.type = 'sine';
              gain.gain.setValueAtTime(0.2, audioContext.currentTime);
              gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
              osc.start(audioContext.currentTime);
              osc.stop(audioContext.currentTime + 0.3);
            }, i * 100);
          });
          break;
      }
    }

    function loadPlayerStats() {
      const saved = localStorage.getItem('playerStats');
      if (saved) {
        playerStats = JSON.parse(saved);
      }
    }

    function savePlayerStats() {
      localStorage.setItem('playerStats', JSON.stringify(playerStats));
    }

    function updatePlayerStatsDisplay() {
      const total = playerStats.wins + playerStats.losses + playerStats.draws;
      document.getElementById("total-games").textContent = total;
      document.getElementById("total-wins").textContent = playerStats.wins;
      document.getElementById("total-losses").textContent = playerStats.losses;
      document.getElementById("total-draws").textContent = playerStats.draws;
      const winRate = total > 0 ? Math.round((playerStats.wins / total) * 100) : 0;
      document.getElementById("win-rate").textContent = winRate + '%';
      document.getElementById("win-rate").style.color = winRate >= 50 ? '#2ecc71' : winRate >= 30 ? '#f39c12' : '#e74c3c';
    }

    function checkAchievements() {
      const total = playerStats.wins + playerStats.losses + playerStats.draws;
      const winRate = total > 0 ? (playerStats.wins / total) * 100 : 0;
      
      // Calculate total points for point-gated achievements
      const allAchievements = getAllAchievementsList();
      const totalPoints = allAchievements.reduce((sum, ach) => {
        if (achievements.includes(ach.id) && ach.points) {
          return sum + ach.points;
        }
        return sum;
      }, 0);
      
      const newAchievements = [];
      
      // Game count achievements
      if (total >= 1 && !achievements.includes('first_game')) {
        newAchievements.push({ id: 'first_game', name: 'ðŸŽ® First Game', desc: 'Played your first game' });
        achievements.push('first_game');
      }
      if (playerStats.wins >= 1 && !achievements.includes('first_win')) {
        newAchievements.push({ id: 'first_win', name: 'ðŸ† First Victory', desc: 'Won your first game' });
        achievements.push('first_win');
      }
      if (playerStats.wins >= 10 && !achievements.includes('ten_wins')) {
        newAchievements.push({ id: 'ten_wins', name: 'â­ Decade of Wins', desc: 'Won 10 games' });
        achievements.push('ten_wins');
      }
      if (playerStats.wins >= 50 && !achievements.includes('fifty_wins')) {
        newAchievements.push({ id: 'fifty_wins', name: 'ðŸ‘‘ Master Player', desc: 'Won 50 games' });
        achievements.push('fifty_wins');
      }
      if (total >= 100 && !achievements.includes('century')) {
        newAchievements.push({ id: 'century', name: 'ðŸ’¯ Century Club', desc: 'Played 100 games' });
        achievements.push('century');
      }
      if (winRate >= 70 && total >= 10 && !achievements.includes('excellent')) {
        newAchievements.push({ id: 'excellent', name: 'ðŸŒŸ Excellent Player', desc: '70%+ win rate (10+ games)' });
        achievements.push('excellent');
      }
      
      // In-game capture achievements (lifetime stats)
      if (lifetimeStats.capturesByQueen >= 10 && !achievements.includes('queen_capturer')) {
        newAchievements.push({ id: 'queen_capturer', name: 'ðŸ‘¸ Queen Capturer', desc: 'Captured 10 pieces with your queen', points: 100 });
        achievements.push('queen_capturer');
      }
      if (lifetimeStats.capturesByRook >= 10 && !achievements.includes('rook_capturer')) {
        newAchievements.push({ id: 'rook_capturer', name: 'ðŸ° Rook Capturer', desc: 'Captured 10 pieces with your rook', points: 120 });
        achievements.push('rook_capturer');
      }
      if (lifetimeStats.capturesByBishop >= 10 && !achievements.includes('bishop_capturer')) {
        newAchievements.push({ id: 'bishop_capturer', name: 'â™— Bishop Capturer', desc: 'Captured 10 pieces with your bishop', points: 130 });
        achievements.push('bishop_capturer');
      }
      if (lifetimeStats.capturesByKnight >= 10 && !achievements.includes('knight_capturer')) {
        newAchievements.push({ id: 'knight_capturer', name: 'ðŸ´ Knight Capturer', desc: 'Captured 10 pieces with your knight', points: 150 });
        achievements.push('knight_capturer');
      }
      if (lifetimeStats.capturesByPawn >= 10 && !achievements.includes('pawn_capturer')) {
        newAchievements.push({ id: 'pawn_capturer', name: 'â™Ÿï¸ Pawn Capturer', desc: 'Captured 10 pieces with your pawn', points: 200 });
        achievements.push('pawn_capturer');
      }
      if (lifetimeStats.totalCaptures >= 50 && !achievements.includes('capture_master')) {
        newAchievements.push({ id: 'capture_master', name: 'âš”ï¸ Capture Master', desc: 'Captured 50 pieces total', points: 200 });
        achievements.push('capture_master');
      }
      if (lifetimeStats.totalCaptures >= 100 && !achievements.includes('capture_legend')) {
        newAchievements.push({ id: 'capture_legend', name: 'ðŸ—¡ï¸ Capture Legend', desc: 'Captured 100 pieces total', points: 400 });
        achievements.push('capture_legend');
      }
      
      // Special move achievements
      if (lifetimeStats.castlingMoves >= 5 && !achievements.includes('castler')) {
        newAchievements.push({ id: 'castler', name: 'ðŸ° Castler', desc: 'Castled 5 times', points: 100 });
        achievements.push('castler');
      }
      if (lifetimeStats.promotions >= 5 && !achievements.includes('promoter')) {
        newAchievements.push({ id: 'promoter', name: 'â¬†ï¸ Promoter', desc: 'Promoted 5 pawns', points: 150 });
        achievements.push('promoter');
      }
      if (lifetimeStats.enPassants >= 1 && !achievements.includes('en_passant')) {
        newAchievements.push({ id: 'en_passant', name: 'ðŸŽ¯ En Passant', desc: 'Performed an en passant capture', points: 150 });
        achievements.push('en_passant');
      }
      if (lifetimeStats.checksGiven >= 50 && !achievements.includes('check_giver')) {
        newAchievements.push({ id: 'check_giver', name: 'âœ“ Check Giver', desc: 'Gave 50 checks', points: 200 });
        achievements.push('check_giver');
      }
      
      // Milestone achievements (always achievable)
      if (playerStats.wins >= 3 && !achievements.includes('three_wins')) {
        newAchievements.push({ id: 'three_wins', name: 'ðŸ”¥ Three Wins', desc: 'Won 3 games', points: 25 });
        achievements.push('three_wins');
      }
      if (playerStats.wins >= 5 && !achievements.includes('five_wins')) {
        newAchievements.push({ id: 'five_wins', name: 'âš¡ Five Wins', desc: 'Won 5 games', points: 50 });
        achievements.push('five_wins');
      }
      if (playerStats.wins >= 15 && !achievements.includes('fifteen_wins')) {
        newAchievements.push({ id: 'fifteen_wins', name: 'ðŸŒŸ Fifteen Wins', desc: 'Won 15 games', points: 100 });
        achievements.push('fifteen_wins');
      }
      if (playerStats.wins >= 100 && !achievements.includes('centurion')) {
        newAchievements.push({ id: 'centurion', name: 'ðŸ’¯ Centurion', desc: 'Won 100 games', points: 500 });
        achievements.push('centurion');
      }
      if (winRate >= 80 && total >= 20 && !achievements.includes('grandmaster')) {
        newAchievements.push({ id: 'grandmaster', name: 'ðŸŽ–ï¸ Grandmaster', desc: '80%+ win rate (20+ games)', points: 300 });
        achievements.push('grandmaster');
      }
      
      // More motivating achievements
      if (playerStats.wins >= 25 && !achievements.includes('quarter_century')) {
        newAchievements.push({ id: 'quarter_century', name: 'ðŸŽ¯ Quarter Century', desc: 'Won 25 games', points: 150 });
        achievements.push('quarter_century');
      }
      if (playerStats.wins >= 200 && !achievements.includes('double_centurion')) {
        const ach = allAchievements.find(a => a.id === 'double_centurion');
        if (!ach || !ach.requiredPoints || totalPoints >= ach.requiredPoints) {
          newAchievements.push({ id: 'double_centurion', name: 'ðŸ’¯ðŸ’¯ Double Centurion', desc: 'Won 200 games', points: 1500 });
          achievements.push('double_centurion');
        }
      }
      if (playerStats.wins >= 500 && !achievements.includes('half_millennium')) {
        const ach = allAchievements.find(a => a.id === 'half_millennium');
        if (!ach || !ach.requiredPoints || totalPoints >= ach.requiredPoints) {
          newAchievements.push({ id: 'half_millennium', name: 'ðŸ† Half Millennium', desc: 'Won 500 games', points: 4000 });
          achievements.push('half_millennium');
        }
      }
      if (total >= 50 && !achievements.includes('fifty_games')) {
        newAchievements.push({ id: 'fifty_games', name: 'ðŸ“Š Fifty Games', desc: 'Played 50 games', points: 75 });
        achievements.push('fifty_games');
      }
      if (total >= 250 && !achievements.includes('two_fifty')) {
        newAchievements.push({ id: 'two_fifty', name: 'ðŸ“ˆ Two Fifty', desc: 'Played 250 games', points: 400 });
        achievements.push('two_fifty');
      }
      if (total >= 500 && !achievements.includes('five_hundred')) {
        newAchievements.push({ id: 'five_hundred', name: 'ðŸŽ² Five Hundred', desc: 'Played 500 games', points: 800 });
        achievements.push('five_hundred');
      }
      if (winRate >= 60 && total >= 10 && !achievements.includes('good_player')) {
        newAchievements.push({ id: 'good_player', name: 'ðŸ‘ Good Player', desc: '60%+ win rate (10+ games)', points: 100 });
        achievements.push('good_player');
      }
      if (winRate >= 90 && total >= 20 && !achievements.includes('near_perfect')) {
        const ach = allAchievements.find(a => a.id === 'near_perfect');
        if (!ach || !ach.requiredPoints || totalPoints >= ach.requiredPoints) {
          newAchievements.push({ id: 'near_perfect', name: 'âœ¨ Near Perfect', desc: '90%+ win rate (20+ games)', points: 750 });
          achievements.push('near_perfect');
        }
      }
      
      // In-game action achievements
      if (lifetimeStats.capturesByQueen >= 25 && !achievements.includes('queen_master')) {
        newAchievements.push({ id: 'queen_master', name: 'ðŸ‘¸ Queen Master', desc: 'Captured 25 pieces with queen', points: 250 });
        achievements.push('queen_master');
      }
      if (lifetimeStats.capturesByQueen >= 50 && !achievements.includes('queen_legend')) {
        const ach = allAchievements.find(a => a.id === 'queen_legend');
        if (!ach || !ach.requiredPoints || totalPoints >= ach.requiredPoints) {
          newAchievements.push({ id: 'queen_legend', name: 'ðŸ‘‘ Queen Legend', desc: 'Captured 50 pieces with queen', points: 500 });
          achievements.push('queen_legend');
        }
      }
      if (lifetimeStats.totalCaptures >= 200 && !achievements.includes('capture_king')) {
        const ach = allAchievements.find(a => a.id === 'capture_king');
        if (!ach || !ach.requiredPoints || totalPoints >= ach.requiredPoints) {
          newAchievements.push({ id: 'capture_king', name: 'ðŸ‘‘ Capture King', desc: 'Captured 200 pieces total', points: 800 });
          achievements.push('capture_king');
        }
      }
      if (lifetimeStats.totalCaptures >= 500 && !achievements.includes('capture_god')) {
        const ach = allAchievements.find(a => a.id === 'capture_god');
        if (!ach || !ach.requiredPoints || totalPoints >= ach.requiredPoints) {
          newAchievements.push({ id: 'capture_god', name: 'âš¡ Capture God', desc: 'Captured 500 pieces total', points: 2000 });
          achievements.push('capture_god');
        }
      }
      if (lifetimeStats.castlingMoves >= 10 && !achievements.includes('castling_master')) {
        newAchievements.push({ id: 'castling_master', name: 'ðŸ° Castling Master', desc: 'Castled 10 times', points: 200 });
        achievements.push('castling_master');
      }
      if (lifetimeStats.castlingMoves >= 25 && !achievements.includes('castling_legend')) {
        const ach = allAchievements.find(a => a.id === 'castling_legend');
        if (!ach || !ach.requiredPoints || totalPoints >= ach.requiredPoints) {
          newAchievements.push({ id: 'castling_legend', name: 'ðŸ° Castling Legend', desc: 'Castled 25 times', points: 500 });
          achievements.push('castling_legend');
        }
      }
      if (lifetimeStats.promotions >= 10 && !achievements.includes('promotion_master')) {
        newAchievements.push({ id: 'promotion_master', name: 'â¬†ï¸ Promotion Master', desc: 'Promoted 10 pawns', points: 300 });
        achievements.push('promotion_master');
      }
      if (lifetimeStats.promotions >= 25 && !achievements.includes('promotion_legend')) {
        const ach = allAchievements.find(a => a.id === 'promotion_legend');
        if (!ach || !ach.requiredPoints || totalPoints >= ach.requiredPoints) {
          newAchievements.push({ id: 'promotion_legend', name: 'â¬†ï¸ Promotion Legend', desc: 'Promoted 25 pawns', points: 600 });
          achievements.push('promotion_legend');
        }
      }
      if (lifetimeStats.checksGiven >= 100 && !achievements.includes('check_master')) {
        newAchievements.push({ id: 'check_master', name: 'âœ“ Check Master', desc: 'Gave 100 checks', points: 400 });
        achievements.push('check_master');
      }
      if (lifetimeStats.checksGiven >= 250 && !achievements.includes('check_legend')) {
        const ach = allAchievements.find(a => a.id === 'check_legend');
        if (!ach || !ach.requiredPoints || totalPoints >= ach.requiredPoints) {
          newAchievements.push({ id: 'check_legend', name: 'âœ“ Check Legend', desc: 'Gave 250 checks', points: 800 });
          achievements.push('check_legend');
        }
      }
      if (lifetimeStats.enPassants >= 3 && !achievements.includes('en_passant_master')) {
        const ach = allAchievements.find(a => a.id === 'en_passant_master');
        if (!ach || !ach.requiredPoints || totalPoints >= ach.requiredPoints) {
          newAchievements.push({ id: 'en_passant_master', name: 'ðŸŽ¯ En Passant Master', desc: 'Performed 3 en passants', points: 400 });
          achievements.push('en_passant_master');
        }
      }
      if (lifetimeStats.enPassants >= 10 && !achievements.includes('en_passant_legend')) {
        const ach = allAchievements.find(a => a.id === 'en_passant_legend');
        if (!ach || !ach.requiredPoints || totalPoints >= ach.requiredPoints) {
          newAchievements.push({ id: 'en_passant_legend', name: 'ðŸŽ¯ En Passant Legend', desc: 'Performed 10 en passants', points: 1000 });
          achievements.push('en_passant_legend');
        }
      }
      
      // Balanced play achievements
      if (playerStats.draws >= 10 && !achievements.includes('peacemaker')) {
        newAchievements.push({ id: 'peacemaker', name: 'ðŸ¤ Peacemaker', desc: 'Drew 10 games', points: 100 });
        achievements.push('peacemaker');
      }
      if (playerStats.draws >= 25 && !achievements.includes('diplomat')) {
        newAchievements.push({ id: 'diplomat', name: 'ðŸ¤ Diplomat', desc: 'Drew 25 games', points: 200 });
        achievements.push('diplomat');
      }
      
      // Captured piece achievements (what pieces you captured, not what captured them)
      if (lifetimeStats.capturedQueens >= 5 && !achievements.includes('queen_hunter_5')) {
        const ach = allAchievements.find(a => a.id === 'queen_hunter_5');
        if (!ach || !ach.requiredPoints || totalPoints >= ach.requiredPoints) {
          newAchievements.push({ id: 'queen_hunter_5', name: 'ðŸ‘¸ Queen Hunter', desc: 'Captured 5 queens', points: 500 });
          achievements.push('queen_hunter_5');
        }
      }
      if (lifetimeStats.capturedQueens >= 10 && !achievements.includes('queen_hunter_10')) {
        const ach = allAchievements.find(a => a.id === 'queen_hunter_10');
        if (!ach || !ach.requiredPoints || totalPoints >= ach.requiredPoints) {
          newAchievements.push({ id: 'queen_hunter_10', name: 'ðŸ‘¸ Queen Slayer', desc: 'Captured 10 queens', points: 1500 });
          achievements.push('queen_hunter_10');
        }
      }
      if (lifetimeStats.capturedRooks >= 10 && !achievements.includes('rook_hunter_10')) {
        newAchievements.push({ id: 'rook_hunter_10', name: 'ðŸ° Rook Hunter', desc: 'Captured 10 rooks', points: 300 });
        achievements.push('rook_hunter_10');
      }
      if (lifetimeStats.capturedRooks >= 25 && !achievements.includes('rook_hunter_25')) {
        const ach = allAchievements.find(a => a.id === 'rook_hunter_25');
        if (!ach || !ach.requiredPoints || totalPoints >= ach.requiredPoints) {
          newAchievements.push({ id: 'rook_hunter_25', name: 'ðŸ° Rook Slayer', desc: 'Captured 25 rooks', points: 750 });
          achievements.push('rook_hunter_25');
        }
      }
      if (lifetimeStats.capturedBishops >= 10 && !achievements.includes('bishop_hunter_10')) {
        newAchievements.push({ id: 'bishop_hunter_10', name: 'â™— Bishop Hunter', desc: 'Captured 10 bishops', points: 300 });
        achievements.push('bishop_hunter_10');
      }
      if (lifetimeStats.capturedBishops >= 25 && !achievements.includes('bishop_hunter_25')) {
        const ach = allAchievements.find(a => a.id === 'bishop_hunter_25');
        if (!ach || !ach.requiredPoints || totalPoints >= ach.requiredPoints) {
          newAchievements.push({ id: 'bishop_hunter_25', name: 'â™— Bishop Slayer', desc: 'Captured 25 bishops', points: 750 });
          achievements.push('bishop_hunter_25');
        }
      }
      if (lifetimeStats.capturedKnights >= 10 && !achievements.includes('knight_hunter_10')) {
        newAchievements.push({ id: 'knight_hunter_10', name: 'ðŸ´ Knight Hunter', desc: 'Captured 10 knights', points: 300 });
        achievements.push('knight_hunter_10');
      }
      if (lifetimeStats.capturedKnights >= 25 && !achievements.includes('knight_hunter_25')) {
        const ach = allAchievements.find(a => a.id === 'knight_hunter_25');
        if (!ach || !ach.requiredPoints || totalPoints >= ach.requiredPoints) {
          newAchievements.push({ id: 'knight_hunter_25', name: 'ðŸ´ Knight Slayer', desc: 'Captured 25 knights', points: 750 });
          achievements.push('knight_hunter_25');
        }
      }
      if (lifetimeStats.capturedPawns >= 50 && !achievements.includes('pawn_hunter_50')) {
        newAchievements.push({ id: 'pawn_hunter_50', name: 'â™Ÿï¸ Pawn Hunter', desc: 'Captured 50 pawns', points: 250 });
        achievements.push('pawn_hunter_50');
      }
      if (lifetimeStats.capturedPawns >= 100 && !achievements.includes('pawn_hunter_100')) {
        newAchievements.push({ id: 'pawn_hunter_100', name: 'â™Ÿï¸ Pawn Slayer', desc: 'Captured 100 pawns', points: 500 });
        achievements.push('pawn_hunter_100');
      }
      
      // Random achievements
      if (lifetimeStats.movesToE4 >= 1 && !achievements.includes('move_to_e4')) {
        newAchievements.push({ id: 'move_to_e4', name: 'ðŸŽ¯ E4 Enthusiast', desc: 'Moved to e4', points: 25 });
        achievements.push('move_to_e4');
      }
      if (lifetimeStats.movesToD4 >= 1 && !achievements.includes('move_to_d4')) {
        newAchievements.push({ id: 'move_to_d4', name: 'ðŸŽ¯ D4 Devotee', desc: 'Moved to d4', points: 25 });
        achievements.push('move_to_d4');
      }
      if (lifetimeStats.pawnToE4 >= 1 && !achievements.includes('pawn_to_e4')) {
        newAchievements.push({ id: 'pawn_to_e4', name: 'â™Ÿï¸ E4 Pawn', desc: 'Moved a pawn to e4', points: 30 });
        achievements.push('pawn_to_e4');
      }
      if (lifetimeStats.pawnToD4 >= 1 && !achievements.includes('pawn_to_d4')) {
        newAchievements.push({ id: 'pawn_to_d4', name: 'â™Ÿï¸ D4 Pawn', desc: 'Moved a pawn to d4', points: 30 });
        achievements.push('pawn_to_d4');
      }
      if (lifetimeStats.knightToF3 >= 1 && !achievements.includes('knight_to_f3')) {
        newAchievements.push({ id: 'knight_to_f3', name: 'ðŸ´ F3 Knight', desc: 'Moved a knight to f3', points: 20 });
        achievements.push('knight_to_f3');
      }
      if (lifetimeStats.knightToC3 >= 1 && !achievements.includes('knight_to_c3')) {
        newAchievements.push({ id: 'knight_to_c3', name: 'ðŸ´ C3 Knight', desc: 'Moved a knight to c3', points: 20 });
        achievements.push('knight_to_c3');
      }
      if (lifetimeStats.queenToD4 >= 1 && !achievements.includes('queen_to_d4')) {
        newAchievements.push({ id: 'queen_to_d4', name: 'ðŸ‘¸ Queen to D4', desc: 'Moved queen to d4', points: 50 });
        achievements.push('queen_to_d4');
      }
      if (lifetimeStats.queenToE4 >= 1 && !achievements.includes('queen_to_e4')) {
        newAchievements.push({ id: 'queen_to_e4', name: 'ðŸ‘¸ Queen to E4', desc: 'Moved queen to e4', points: 50 });
        achievements.push('queen_to_e4');
      }
      if (lifetimeStats.bishopToF4 >= 1 && !achievements.includes('bishop_to_f4')) {
        newAchievements.push({ id: 'bishop_to_f4', name: 'â™— Bishop to F4', desc: 'Moved bishop to f4', points: 30 });
        achievements.push('bishop_to_f4');
      }
      if (lifetimeStats.rookToE1 >= 1 && !achievements.includes('rook_to_e1')) {
        newAchievements.push({ id: 'rook_to_e1', name: 'ðŸ° Rook to E1', desc: 'Moved rook to e1', points: 30 });
        achievements.push('rook_to_e1');
      }
      if (lifetimeStats.kingToE1 >= 1 && !achievements.includes('king_to_e1')) {
        newAchievements.push({ id: 'king_to_e1', name: 'ðŸ‘‘ King to E1', desc: 'Moved king to e1', points: 40 });
        achievements.push('king_to_e1');
      }
      if (lifetimeStats.movesOnMove1 >= 1 && !achievements.includes('move_on_1')) {
        newAchievements.push({ id: 'move_on_1', name: '1ï¸âƒ£ First Move', desc: 'Made a move on your 1st move', points: 15 });
        achievements.push('move_on_1');
      }
      if (lifetimeStats.movesOnMove5 >= 1 && !achievements.includes('move_on_5')) {
        newAchievements.push({ id: 'move_on_5', name: '5ï¸âƒ£ Fifth Move', desc: 'Made a move on your 5th move', points: 20 });
        achievements.push('move_on_5');
      }
      if (lifetimeStats.movesOnMove10 >= 1 && !achievements.includes('move_on_10')) {
        newAchievements.push({ id: 'move_on_10', name: 'ðŸ”Ÿ Tenth Move', desc: 'Made a move on your 10th move', points: 25 });
        achievements.push('move_on_10');
      }
      if (lifetimeStats.movesOnMove20 >= 1 && !achievements.includes('move_on_20')) {
        newAchievements.push({ id: 'move_on_20', name: '2ï¸âƒ£0ï¸âƒ£ Twentieth Move', desc: 'Made a move on your 20th move', points: 30 });
        achievements.push('move_on_20');
      }
      if (lifetimeStats.movesOnMove50 >= 1 && !achievements.includes('move_on_50')) {
        newAchievements.push({ id: 'move_on_50', name: '5ï¸âƒ£0ï¸âƒ£ Fiftieth Move', desc: 'Made a move on your 50th move', points: 50 });
        achievements.push('move_on_50');
      }
      if (lifetimeStats.castledOnMove10 >= 1 && !achievements.includes('castle_on_10')) {
        newAchievements.push({ id: 'castle_on_10', name: 'ðŸ° Castle on 10', desc: 'Castled on your 10th move', points: 75 });
        achievements.push('castle_on_10');
      }
      if (lifetimeStats.castledOnMove20 >= 1 && !achievements.includes('castle_on_20')) {
        newAchievements.push({ id: 'castle_on_20', name: 'ðŸ° Castle on 20', desc: 'Castled on your 20th move', points: 75 });
        achievements.push('castle_on_20');
      }
      if (lifetimeStats.promotedToQueen >= 1 && !achievements.includes('promote_to_queen')) {
        newAchievements.push({ id: 'promote_to_queen', name: 'ðŸ‘¸ Queen Promotion', desc: 'Promoted to queen', points: 50 });
        achievements.push('promote_to_queen');
      }
      if (lifetimeStats.promotedToRook >= 1 && !achievements.includes('promote_to_rook')) {
        newAchievements.push({ id: 'promote_to_rook', name: 'ðŸ° Rook Promotion', desc: 'Promoted to rook', points: 100 });
        achievements.push('promote_to_rook');
      }
      if (lifetimeStats.promotedToBishop >= 1 && !achievements.includes('promote_to_bishop')) {
        newAchievements.push({ id: 'promote_to_bishop', name: 'â™— Bishop Promotion', desc: 'Promoted to bishop', points: 100 });
        achievements.push('promote_to_bishop');
      }
      if (lifetimeStats.promotedToKnight >= 1 && !achievements.includes('promote_to_knight')) {
        newAchievements.push({ id: 'promote_to_knight', name: 'ðŸ´ Knight Promotion', desc: 'Promoted to knight', points: 100 });
        achievements.push('promote_to_knight');
      }
      if (lifetimeStats.checkOnMove5 >= 1 && !achievements.includes('check_on_5')) {
        newAchievements.push({ id: 'check_on_5', name: 'âœ“ Check on 5', desc: 'Gave check on your 5th move', points: 75 });
        achievements.push('check_on_5');
      }
      if (lifetimeStats.captureOnMove10 >= 1 && !achievements.includes('capture_on_10')) {
        newAchievements.push({ id: 'capture_on_10', name: 'âš”ï¸ Capture on 10', desc: 'Captured on your 10th move', points: 50 });
        achievements.push('capture_on_10');
      }
      
      // New random piece-to-square achievements
      if (lifetimeStats.rookToA1 >= 1 && !achievements.includes('rook_to_a1')) {
        newAchievements.push({ id: 'rook_to_a1', name: 'ðŸ° Rook to A1', desc: 'Moved rook to a1', points: 30 });
        achievements.push('rook_to_a1');
      }
      if (lifetimeStats.rookToH1 >= 1 && !achievements.includes('rook_to_h1')) {
        newAchievements.push({ id: 'rook_to_h1', name: 'ðŸ° Rook to H1', desc: 'Moved rook to h1', points: 30 });
        achievements.push('rook_to_h1');
      }
      if (lifetimeStats.bishopToC1 >= 1 && !achievements.includes('bishop_to_c1')) {
        newAchievements.push({ id: 'bishop_to_c1', name: 'â™— Bishop to C1', desc: 'Moved bishop to c1', points: 25 });
        achievements.push('bishop_to_c1');
      }
      if (lifetimeStats.bishopToF1 >= 1 && !achievements.includes('bishop_to_f1')) {
        newAchievements.push({ id: 'bishop_to_f1', name: 'â™— Bishop to F1', desc: 'Moved bishop to f1', points: 25 });
        achievements.push('bishop_to_f1');
      }
      if (lifetimeStats.knightToG1 >= 1 && !achievements.includes('knight_to_g1')) {
        newAchievements.push({ id: 'knight_to_g1', name: 'ðŸ´ Knight to G1', desc: 'Moved knight to g1', points: 20 });
        achievements.push('knight_to_g1');
      }
      if (lifetimeStats.knightToB1 >= 1 && !achievements.includes('knight_to_b1')) {
        newAchievements.push({ id: 'knight_to_b1', name: 'ðŸ´ Knight to B1', desc: 'Moved knight to b1', points: 20 });
        achievements.push('knight_to_b1');
      }
      if (lifetimeStats.queenToA1 >= 1 && !achievements.includes('queen_to_a1')) {
        newAchievements.push({ id: 'queen_to_a1', name: 'ðŸ‘¸ Queen to A1', desc: 'Moved queen to a1', points: 40 });
        achievements.push('queen_to_a1');
      }
      if (lifetimeStats.queenToH1 >= 1 && !achievements.includes('queen_to_h1')) {
        newAchievements.push({ id: 'queen_to_h1', name: 'ðŸ‘¸ Queen to H1', desc: 'Moved queen to h1', points: 40 });
        achievements.push('queen_to_h1');
      }
      if (lifetimeStats.kingToG1 >= 1 && !achievements.includes('king_to_g1')) {
        newAchievements.push({ id: 'king_to_g1', name: 'ðŸ‘‘ King to G1', desc: 'Moved king to g1', points: 35 });
        achievements.push('king_to_g1');
      }
      if (lifetimeStats.kingToC1 >= 1 && !achievements.includes('king_to_c1')) {
        newAchievements.push({ id: 'king_to_c1', name: 'ðŸ‘‘ King to C1', desc: 'Moved king to c1', points: 35 });
        achievements.push('king_to_c1');
      }
      if (lifetimeStats.pawnToA2 >= 1 && !achievements.includes('pawn_to_a2')) {
        newAchievements.push({ id: 'pawn_to_a2', name: 'â™Ÿï¸ Pawn to A2', desc: 'Moved a pawn to a2', points: 20 });
        achievements.push('pawn_to_a2');
      }
      if (lifetimeStats.pawnToH2 >= 1 && !achievements.includes('pawn_to_h2')) {
        newAchievements.push({ id: 'pawn_to_h2', name: 'â™Ÿï¸ Pawn to H2', desc: 'Moved a pawn to h2', points: 20 });
        achievements.push('pawn_to_h2');
      }
      
      // Check ALL achievements dynamically using their progress functions
      // Daily achievements reset each day via resetDailyStatsIfNeeded(), so we can safely
      // check ALL daily achievements here (not just the 3 featured "daily challenges").
      resetDailyStatsIfNeeded();
      const todayDailyIds = getTodayDailyAchievements();
      
      allAchievements.forEach(ach => {
        // Skip if already unlocked
        if (achievements.includes(ach.id)) return;
        
        // Check point requirements for locked achievements
        if (ach.requiredPoints && totalPoints < ach.requiredPoints) {
          return; // Not enough points yet
        }
        
        // Check if achievement has a progress function
        if (!ach.progress) return;
        
        try {
          const progress = ach.progress();
          // Check if achievement has additional requirements (like minimum games played)
          // needsTotal should be true or undefined (not false) to meet requirements
          const meetsRequirements = progress.needsTotal !== false;
          // needsNoLosses should be true or undefined (not false) to meet requirements
          const meetsNoLosses = progress.needsNoLosses !== false;
          
          // Only unlock if progress reaches target AND all requirements are met
          if (progress.current >= progress.target && progress.target > 0 && meetsRequirements && meetsNoLosses) {
            newAchievements.push({ 
              id: ach.id, 
              name: ach.name, 
              desc: ach.desc, 
              points: ach.points || 0 
            });
            achievements.push(ach.id);
          }
        } catch (e) {
          console.error('Error checking achievement', ach.id, e);
        }
      });
      
      return newAchievements; // Return new achievements instead of showing immediately
    }
    
    function checkAndUnlockAchievements() {
      // This function is called after game completion to check and unlock achievements
      const newAchievements = checkAchievements();
      
      if (newAchievements.length > 0) {
        saveAchievements();
        updateAchievementsDisplay();
        updateTotalPoints();
        // Show notifications one at a time with delays
        showAchievementNotificationsSequentially(newAchievements);
      }
    }

    function loadAchievements() {
      const saved = localStorage.getItem('achievements');
      if (saved) {
        achievements = JSON.parse(saved);
      }
    }

    function saveAchievements() {
      localStorage.setItem('achievements', JSON.stringify(achievements));
    }

    function getAllAchievementsList() {
      return [
        // General Achievements - Grouped
        { id: 'first_game', name: 'ðŸŽ® First Game', desc: 'Played your first game', category: 'General', points: 10, groupKey: 'games_played', progress: () => {
          const total = playerStats.wins + playerStats.losses + playerStats.draws;
          return { current: total, target: 1 };
        }},
        { id: 'fifty_games', name: 'ðŸ“Š Fifty Games', desc: 'Played 50 games', category: 'General', points: 75, groupKey: 'games_played', progress: () => {
          const total = playerStats.wins + playerStats.losses + playerStats.draws;
          return { current: total, target: 50 };
        }},
        { id: 'century', name: 'ðŸ’¯ Century Club', desc: 'Played 100 games', category: 'General', points: 150, groupKey: 'games_played', progress: () => {
          const total = playerStats.wins + playerStats.losses + playerStats.draws;
          return { current: total, target: 100 };
        }},
        { id: 'two_fifty', name: 'ðŸ“ˆ Two Fifty', desc: 'Played 250 games', category: 'General', points: 400, groupKey: 'games_played', progress: () => {
          const total = playerStats.wins + playerStats.losses + playerStats.draws;
          return { current: total, target: 250 };
        }},
        { id: 'five_hundred', name: 'ðŸŽ² Five Hundred', desc: 'Played 500 games', category: 'General', points: 800, groupKey: 'games_played', progress: () => {
          const total = playerStats.wins + playerStats.losses + playerStats.draws;
          return { current: total, target: 500 };
        }},
        { id: 'first_win', name: 'ðŸ† First Victory', desc: 'Won your first game', category: 'General', points: 25, groupKey: 'wins', progress: () => {
          return { current: playerStats.wins, target: 1 };
        }},
        { id: 'three_wins', name: 'ðŸ”¥ Three Wins', desc: 'Won 3 games', category: 'General', points: 25, groupKey: 'wins', progress: () => {
          return { current: playerStats.wins, target: 3 };
        }},
        { id: 'five_wins', name: 'âš¡ Five Wins', desc: 'Won 5 games', category: 'General', points: 50, groupKey: 'wins', progress: () => {
          return { current: playerStats.wins, target: 5 };
        }},
        { id: 'ten_wins', name: 'â­ Decade of Wins', desc: 'Won 10 games', category: 'General', points: 75, groupKey: 'wins', progress: () => {
          return { current: playerStats.wins, target: 10 };
        }},
        { id: 'fifteen_wins', name: 'ðŸŒŸ Fifteen Wins', desc: 'Won 15 games', category: 'General', points: 100, groupKey: 'wins', progress: () => {
          return { current: playerStats.wins, target: 15 };
        }},
        { id: 'quarter_century', name: 'ðŸŽ¯ Quarter Century', desc: 'Won 25 games', category: 'General', points: 150, groupKey: 'wins', progress: () => {
          return { current: playerStats.wins, target: 25 };
        }},
        { id: 'fifty_wins', name: 'ðŸ‘‘ Master Player', desc: 'Won 50 games', category: 'General', points: 200, groupKey: 'wins', progress: () => {
          return { current: playerStats.wins, target: 50 };
        }},
        { id: 'centurion', name: 'ðŸ’¯ Centurion', desc: 'Won 100 games', category: 'General', points: 500, groupKey: 'wins', progress: () => {
          return { current: playerStats.wins, target: 100 };
        }},
        { id: 'double_centurion', name: 'ðŸ’¯ðŸ’¯ Double Centurion', desc: 'Won 200 games', category: 'General', points: 1000, groupKey: 'wins', progress: () => {
          return { current: playerStats.wins, target: 200 };
        }},
        { id: 'half_millennium', name: 'ðŸ† Half Millennium', desc: 'Won 500 games', category: 'General', points: 2500, groupKey: 'wins', progress: () => {
          return { current: playerStats.wins, target: 500 };
        }},
        { id: 'good_player', name: 'ðŸ‘ Good Player', desc: '60%+ win rate (10+ games)', category: 'General', points: 100, groupKey: 'win_rate', progress: () => {
          const total = playerStats.wins + playerStats.losses + playerStats.draws;
          if (total < 10) return { current: 0, target: 60, needsTotal: false };
          const winRate = total > 0 ? (playerStats.wins / total) * 100 : 0;
          return { current: Math.round(winRate), target: 60, needsTotal: true };
        }},
        { id: 'excellent', name: 'ðŸŒŸ Excellent Player', desc: '70%+ win rate (10+ games)', category: 'General', points: 200, groupKey: 'win_rate', progress: () => {
          const total = playerStats.wins + playerStats.losses + playerStats.draws;
          if (total < 10) return { current: 0, target: 70, needsTotal: false };
          const winRate = total > 0 ? (playerStats.wins / total) * 100 : 0;
          return { current: Math.round(winRate), target: 70, needsTotal: true };
        }},
        { id: 'grandmaster', name: 'ðŸŽ–ï¸ Grandmaster', desc: '80%+ win rate (20+ games)', category: 'General', points: 300, groupKey: 'win_rate', progress: () => {
          const total = playerStats.wins + playerStats.losses + playerStats.draws;
          if (total < 20) return { current: 0, target: 80, needsTotal: false };
          const winRate = total > 0 ? (playerStats.wins / total) * 100 : 0;
          return { current: Math.round(winRate), target: 80, needsTotal: true };
        }},
        { id: 'near_perfect', name: 'âœ¨ Near Perfect', desc: '90%+ win rate (20+ games)', category: 'General', points: 750, requiredPoints: 15000, groupKey: 'win_rate', progress: () => {
          const total = playerStats.wins + playerStats.losses + playerStats.draws;
          if (total < 20) return { current: 0, target: 90, needsTotal: false };
          const winRate = total > 0 ? (playerStats.wins / total) * 100 : 0;
          return { current: Math.round(winRate), target: 90, needsTotal: true };
        }},
        { id: 'peacemaker', name: 'ðŸ¤ Peacemaker', desc: 'Drew 10 games', category: 'General', points: 100, groupKey: 'draws', progress: () => {
          return { current: playerStats.draws, target: 10 };
        }},
        { id: 'diplomat', name: 'ðŸ¤ Diplomat', desc: 'Drew 25 games', category: 'General', points: 200, groupKey: 'draws', progress: () => {
          return { current: playerStats.draws, target: 25 };
        }},
        
        // Captured Piece Achievements (what pieces you captured)
        { id: 'queen_hunter_5', name: 'ðŸ‘¸ Queen Hunter', desc: 'Captured 5 queens', category: 'In-Game', points: 500, requiredPoints: 2000, groupKey: 'captured_queens', progress: () => {
          return { current: (lifetimeStats.capturedQueens || 0), target: 5 };
        }},
        { id: 'queen_hunter_10', name: 'ðŸ‘¸ Queen Slayer', desc: 'Captured 10 queens', category: 'In-Game', points: 1500, requiredPoints: 20000, groupKey: 'captured_queens', progress: () => {
          return { current: (lifetimeStats.capturedQueens || 0), target: 10 };
        }},
        { id: 'rook_hunter_10', name: 'ðŸ° Rook Hunter', desc: 'Captured 10 rooks', category: 'In-Game', points: 300, groupKey: 'captured_rooks', progress: () => {
          return { current: (lifetimeStats.capturedRooks || 0), target: 10 };
        }},
        { id: 'rook_hunter_25', name: 'ðŸ° Rook Slayer', desc: 'Captured 25 rooks', category: 'In-Game', points: 750, requiredPoints: 5000, groupKey: 'captured_rooks', progress: () => {
          return { current: (lifetimeStats.capturedRooks || 0), target: 25 };
        }},
        { id: 'bishop_hunter_10', name: 'â™— Bishop Hunter', desc: 'Captured 10 bishops', category: 'In-Game', points: 300, groupKey: 'captured_bishops', progress: () => {
          return { current: (lifetimeStats.capturedBishops || 0), target: 10 };
        }},
        { id: 'bishop_hunter_25', name: 'â™— Bishop Slayer', desc: 'Captured 25 bishops', category: 'In-Game', points: 750, requiredPoints: 5000, groupKey: 'captured_bishops', progress: () => {
          return { current: (lifetimeStats.capturedBishops || 0), target: 25 };
        }},
        { id: 'knight_hunter_10', name: 'ðŸ´ Knight Hunter', desc: 'Captured 10 knights', category: 'In-Game', points: 300, groupKey: 'captured_knights', progress: () => {
          return { current: (lifetimeStats.capturedKnights || 0), target: 10 };
        }},
        { id: 'knight_hunter_25', name: 'ðŸ´ Knight Slayer', desc: 'Captured 25 knights', category: 'In-Game', points: 750, requiredPoints: 5000, groupKey: 'captured_knights', progress: () => {
          return { current: (lifetimeStats.capturedKnights || 0), target: 25 };
        }},
        { id: 'pawn_hunter_50', name: 'â™Ÿï¸ Pawn Hunter', desc: 'Captured 50 pawns', category: 'In-Game', points: 250, groupKey: 'captured_pawns', progress: () => {
          return { current: (lifetimeStats.capturedPawns || 0), target: 50 };
        }},
        { id: 'pawn_hunter_100', name: 'â™Ÿï¸ Pawn Slayer', desc: 'Captured 100 pawns', category: 'In-Game', points: 500, groupKey: 'captured_pawns', progress: () => {
          return { current: (lifetimeStats.capturedPawns || 0), target: 100 };
        }},
        
        // Group keys for other achievement types
        { id: 'queen_capturer', name: 'ðŸ‘¸ Queen Capturer', desc: 'Captured 10 pieces with your queen', category: 'In-Game', points: 100, groupKey: 'captures_with_queen', progress: () => {
          return { current: (lifetimeStats.capturesByQueen || 0), target: 10 };
        }},
        { id: 'queen_master', name: 'ðŸ‘¸ Queen Master', desc: 'Captured 25 pieces with queen', category: 'In-Game', points: 250, groupKey: 'captures_with_queen', progress: () => {
          return { current: (lifetimeStats.capturesByQueen || 0), target: 25 };
        }},
        { id: 'queen_legend', name: 'ðŸ‘‘ Queen Legend', desc: 'Captured 50 pieces with queen', category: 'In-Game', points: 500, requiredPoints: 5000, groupKey: 'captures_with_queen', progress: () => {
          return { current: (lifetimeStats.capturesByQueen || 0), target: 50 };
        }},
        { id: 'rook_capturer', name: 'ðŸ° Rook Capturer', desc: 'Captured 10 pieces with your rook', category: 'In-Game', points: 120, groupKey: 'captures_with_rook', progress: () => {
          return { current: (lifetimeStats.capturesByRook || 0), target: 10 };
        }},
        { id: 'bishop_capturer', name: 'â™— Bishop Capturer', desc: 'Captured 10 pieces with your bishop', category: 'In-Game', points: 130, groupKey: 'captures_with_bishop', progress: () => {
          return { current: (lifetimeStats.capturesByBishop || 0), target: 10 };
        }},
        { id: 'knight_capturer', name: 'ðŸ´ Knight Capturer', desc: 'Captured 10 pieces with your knight', category: 'In-Game', points: 150, groupKey: 'captures_with_knight', progress: () => {
          return { current: (lifetimeStats.capturesByKnight || 0), target: 10 };
        }},
        { id: 'pawn_capturer', name: 'â™Ÿï¸ Pawn Capturer', desc: 'Captured 10 pieces with your pawn', category: 'In-Game', points: 200, groupKey: 'captures_with_pawn', progress: () => {
          return { current: (lifetimeStats.capturesByPawn || 0), target: 10 };
        }},
        { id: 'capture_master', name: 'âš”ï¸ Capture Master', desc: 'Captured 50 pieces total', category: 'In-Game', points: 200, groupKey: 'total_captures', progress: () => {
          return { current: (lifetimeStats.totalCaptures || 0), target: 50 };
        }},
        { id: 'capture_legend', name: 'ðŸ—¡ï¸ Capture Legend', desc: 'Captured 100 pieces total', category: 'In-Game', points: 400, groupKey: 'total_captures', progress: () => {
          return { current: (lifetimeStats.totalCaptures || 0), target: 100 };
        }},
        { id: 'capture_king', name: 'ðŸ‘‘ Capture King', desc: 'Captured 200 pieces total', category: 'In-Game', points: 800, requiredPoints: 8000, groupKey: 'total_captures', progress: () => {
          return { current: (lifetimeStats.totalCaptures || 0), target: 200 };
        }},
        { id: 'capture_god', name: 'âš¡ Capture God', desc: 'Captured 500 pieces total', category: 'In-Game', points: 2000, requiredPoints: 30000, groupKey: 'total_captures', progress: () => {
          return { current: (lifetimeStats.totalCaptures || 0), target: 500 };
        }},
        { id: 'castler', name: 'ðŸ° Castler', desc: 'Castled 5 times', category: 'In-Game', points: 100, groupKey: 'castling', progress: () => {
          return { current: (lifetimeStats.castlingMoves || 0), target: 5 };
        }},
        { id: 'castling_master', name: 'ðŸ° Castling Master', desc: 'Castled 10 times', category: 'In-Game', points: 200, groupKey: 'castling', progress: () => {
          return { current: (lifetimeStats.castlingMoves || 0), target: 10 };
        }},
        { id: 'castling_legend', name: 'ðŸ° Castling Legend', desc: 'Castled 25 times', category: 'In-Game', points: 500, requiredPoints: 3000, groupKey: 'castling', progress: () => {
          return { current: (lifetimeStats.castlingMoves || 0), target: 25 };
        }},
        { id: 'promoter', name: 'â¬†ï¸ Promoter', desc: 'Promoted 5 pawns', category: 'In-Game', points: 150, groupKey: 'promotions', progress: () => {
          return { current: (lifetimeStats.promotions || 0), target: 5 };
        }},
        { id: 'promotion_master', name: 'â¬†ï¸ Promotion Master', desc: 'Promoted 10 pawns', category: 'In-Game', points: 300, groupKey: 'promotions', progress: () => {
          return { current: (lifetimeStats.promotions || 0), target: 10 };
        }},
        { id: 'promotion_legend', name: 'â¬†ï¸ Promotion Legend', desc: 'Promoted 25 pawns', category: 'In-Game', points: 600, requiredPoints: 3000, groupKey: 'promotions', progress: () => {
          return { current: (lifetimeStats.promotions || 0), target: 25 };
        }},
        { id: 'en_passant', name: 'ðŸŽ¯ En Passant', desc: 'Performed an en passant capture', category: 'In-Game', points: 150, groupKey: 'en_passants', progress: () => {
          return { current: (lifetimeStats.enPassants || 0), target: 1 };
        }},
        { id: 'en_passant_master', name: 'ðŸŽ¯ En Passant Master', desc: 'Performed 3 en passants', category: 'In-Game', points: 400, requiredPoints: 1500, groupKey: 'en_passants', progress: () => {
          return { current: (lifetimeStats.enPassants || 0), target: 3 };
        }},
        { id: 'en_passant_legend', name: 'ðŸŽ¯ En Passant Legend', desc: 'Performed 10 en passants', category: 'In-Game', points: 1000, requiredPoints: 25000, groupKey: 'en_passants', progress: () => {
          return { current: (lifetimeStats.enPassants || 0), target: 10 };
        }},
        { id: 'check_giver', name: 'âœ“ Check Giver', desc: 'Gave 50 checks', category: 'In-Game', points: 200, groupKey: 'checks', progress: () => {
          return { current: (lifetimeStats.checksGiven || 0), target: 50 };
        }},
        { id: 'check_master', name: 'âœ“ Check Master', desc: 'Gave 100 checks', category: 'In-Game', points: 400, groupKey: 'checks', progress: () => {
          return { current: (lifetimeStats.checksGiven || 0), target: 100 };
        }},
        { id: 'check_legend', name: 'âœ“ Check Legend', desc: 'Gave 250 checks', category: 'In-Game', points: 800, requiredPoints: 15000, groupKey: 'checks', progress: () => {
          return { current: (lifetimeStats.checksGiven || 0), target: 250 };
        }},
        
        // Random/Fun Achievements - Grouped with varied requirements
        { id: 'move_to_e4', name: 'ðŸŽ¯ E4 Enthusiast', desc: 'Moved to e4', category: 'Random', points: 25, groupKey: 'moves_to_e4', progress: () => {
          return { current: (lifetimeStats.movesToE4 || 0), target: 1 };
        }},
        { id: 'move_to_e4_5', name: 'ðŸŽ¯ E4 Lover', desc: 'Moved to e4 five times', category: 'Random', points: 75, groupKey: 'moves_to_e4', progress: () => {
          return { current: (lifetimeStats.movesToE4Multiple || 0), target: 5 };
        }},
        { id: 'move_to_e4_10', name: 'ðŸŽ¯ E4 Master', desc: 'Moved to e4 ten times', category: 'Random', points: 150, groupKey: 'moves_to_e4', progress: () => {
          return { current: (lifetimeStats.movesToE4Multiple || 0), target: 10 };
        }},
        { id: 'move_to_d4', name: 'ðŸŽ¯ D4 Devotee', desc: 'Moved to d4', category: 'Random', points: 25, groupKey: 'moves_to_d4', progress: () => {
          return { current: ((lifetimeStats.movesToD4 || 0) + ((gameStats && gameStats.movesToD4) || 0)), target: 1 };
        }},
        { id: 'move_to_d4_5', name: 'ðŸŽ¯ D4 Lover', desc: 'Moved to d4 five times', category: 'Random', points: 75, groupKey: 'moves_to_d4', progress: () => {
          return { current: ((lifetimeStats.movesToD4Multiple || 0) + ((gameStats && gameStats.movesToD4Multiple) || 0)), target: 5 };
        }},
        { id: 'move_to_d4_10', name: 'ðŸŽ¯ D4 Master', desc: 'Moved to d4 ten times', category: 'Random', points: 150, groupKey: 'moves_to_d4', progress: () => {
          return { current: ((lifetimeStats.movesToD4Multiple || 0) + ((gameStats && gameStats.movesToD4Multiple) || 0)), target: 10 };
        }},
        { id: 'move_to_d4_25', name: 'ðŸŽ¯ D4 Expert', desc: 'Moved to d4 twenty-five times', category: 'Random', points: 300, groupKey: 'moves_to_d4', progress: () => {
          return { current: ((lifetimeStats.movesToD4Multiple || 0) + ((gameStats && gameStats.movesToD4Multiple) || 0)), target: 25 };
        }},
        { id: 'move_to_d4_50', name: 'ðŸŽ¯ D4 Legend', desc: 'Moved to d4 fifty times', category: 'Random', points: 500, groupKey: 'moves_to_d4', progress: () => {
          return { current: ((lifetimeStats.movesToD4Multiple || 0) + ((gameStats && gameStats.movesToD4Multiple) || 0)), target: 50 };
        }},
        { id: 'pawn_to_e4', name: 'â™Ÿï¸ E4 Pawn', desc: 'Moved a pawn to e4', category: 'Random', points: 30, groupKey: 'pawn_to_e4', progress: () => {
          return { current: ((lifetimeStats.pawnToE4 || 0) + ((gameStats && gameStats.pawnToE4) || 0)), target: 1 };
        }},
        { id: 'pawn_to_e4_3', name: 'â™Ÿï¸ E4 Pawn Master', desc: 'Moved a pawn to e4 three times', category: 'Random', points: 100, groupKey: 'pawn_to_e4', progress: () => {
          return { current: ((lifetimeStats.pawnToE4 || 0) + ((gameStats && gameStats.pawnToE4) || 0)), target: 3 };
        }},
        { id: 'pawn_to_e4_10', name: 'â™Ÿï¸ E4 Pawn Expert', desc: 'Moved a pawn to e4 ten times', category: 'Random', points: 250, groupKey: 'pawn_to_e4', progress: () => {
          return { current: ((lifetimeStats.pawnToE4 || 0) + ((gameStats && gameStats.pawnToE4) || 0)), target: 10 };
        }},
        { id: 'pawn_to_e4_25', name: 'â™Ÿï¸ E4 Pawn Legend', desc: 'Moved a pawn to e4 twenty-five times', category: 'Random', points: 500, groupKey: 'pawn_to_e4', progress: () => {
          return { current: ((lifetimeStats.pawnToE4 || 0) + ((gameStats && gameStats.pawnToE4) || 0)), target: 25 };
        }},
        { id: 'pawn_to_d4', name: 'â™Ÿï¸ D4 Pawn', desc: 'Moved a pawn to d4', category: 'Random', points: 30, groupKey: 'pawn_to_d4', progress: () => {
          return { current: ((lifetimeStats.pawnToD4 || 0) + ((gameStats && gameStats.pawnToD4) || 0)), target: 1 };
        }},
        { id: 'pawn_to_d4_3', name: 'â™Ÿï¸ D4 Pawn Master', desc: 'Moved a pawn to d4 three times', category: 'Random', points: 100, groupKey: 'pawn_to_d4', progress: () => {
          return { current: ((lifetimeStats.pawnToD4 || 0) + ((gameStats && gameStats.pawnToD4) || 0)), target: 3 };
        }},
        { id: 'pawn_to_d4_10', name: 'â™Ÿï¸ D4 Pawn Expert', desc: 'Moved a pawn to d4 ten times', category: 'Random', points: 250, groupKey: 'pawn_to_d4', progress: () => {
          return { current: ((lifetimeStats.pawnToD4 || 0) + ((gameStats && gameStats.pawnToD4) || 0)), target: 10 };
        }},
        { id: 'pawn_to_d4_25', name: 'â™Ÿï¸ D4 Pawn Legend', desc: 'Moved a pawn to d4 twenty-five times', category: 'Random', points: 500, groupKey: 'pawn_to_d4', progress: () => {
          return { current: ((lifetimeStats.pawnToD4 || 0) + ((gameStats && gameStats.pawnToD4) || 0)), target: 25 };
        }},
        { id: 'knight_to_f3', name: 'ðŸ´ F3 Knight', desc: 'Moved a knight to f3', category: 'Random', points: 20, groupKey: 'knight_to_f3', progress: () => {
          return { current: (lifetimeStats.knightToF3 || 0), target: 1 };
        }},
        { id: 'knight_to_f3_5', name: 'ðŸ´ F3 Knight Master', desc: 'Moved a knight to f3 five times', category: 'Random', points: 75, groupKey: 'knight_to_f3', progress: () => {
          return { current: (lifetimeStats.knightToF3Multiple || 0), target: 5 };
        }},
        { id: 'knight_to_c3', name: 'ðŸ´ C3 Knight', desc: 'Moved a knight to c3', category: 'Random', points: 20, groupKey: 'knight_to_c3', progress: () => {
          return { current: (lifetimeStats.knightToC3 || 0), target: 1 };
        }},
        { id: 'knight_to_c3_5', name: 'ðŸ´ C3 Knight Master', desc: 'Moved a knight to c3 five times', category: 'Random', points: 75, groupKey: 'knight_to_c3', progress: () => {
          return { current: (lifetimeStats.knightToC3Multiple || 0), target: 5 };
        }},
        { id: 'queen_to_d4', name: 'ðŸ‘¸ Queen to D4', desc: 'Moved queen to d4', category: 'Random', points: 50, groupKey: 'queen_to_d4', progress: () => {
          return { current: (lifetimeStats.queenToD4 || 0), target: 1 };
        }},
        { id: 'queen_to_d4_3', name: 'ðŸ‘¸ Queen to D4 Master', desc: 'Moved queen to d4 three times', category: 'Random', points: 150, groupKey: 'queen_to_d4', progress: () => {
          return { current: (lifetimeStats.queenToD4Multiple || 0), target: 3 };
        }},
        { id: 'queen_to_e4', name: 'ðŸ‘¸ Queen to E4', desc: 'Moved queen to e4', category: 'Random', points: 50, groupKey: 'queen_to_e4', progress: () => {
          return { current: (lifetimeStats.queenToE4 || 0), target: 1 };
        }},
        { id: 'queen_to_e4_3', name: 'ðŸ‘¸ Queen to E4 Master', desc: 'Moved queen to e4 three times', category: 'Random', points: 150, groupKey: 'queen_to_e4', progress: () => {
          return { current: (lifetimeStats.queenToE4 || 0), target: 3 };
        }},
        { id: 'bishop_to_f4', name: 'â™— Bishop to F4', desc: 'Moved bishop to f4', category: 'Random', points: 30, groupKey: 'bishop_to_f4', progress: () => {
          return { current: (lifetimeStats.bishopToF4 || 0), target: 1 };
        }},
        { id: 'bishop_to_f4_3', name: 'â™— Bishop to F4 Master', desc: 'Moved bishop to f4 three times', category: 'Random', points: 100, groupKey: 'bishop_to_f4', progress: () => {
          return { current: (lifetimeStats.bishopToF4 || 0), target: 3 };
        }},
        { id: 'rook_to_e1', name: 'ðŸ° Rook to E1', desc: 'Moved rook to e1', category: 'Random', points: 30, groupKey: 'rook_to_e1', progress: () => {
          return { current: (lifetimeStats.rookToE1 || 0), target: 1 };
        }},
        { id: 'rook_to_e1_3', name: 'ðŸ° Rook to E1 Master', desc: 'Moved rook to e1 three times', category: 'Random', points: 100, groupKey: 'rook_to_e1', progress: () => {
          return { current: (lifetimeStats.rookToE1 || 0), target: 3 };
        }},
        { id: 'king_to_e1', name: 'ðŸ‘‘ King to E1', desc: 'Moved king to e1', category: 'Random', points: 40, groupKey: 'king_to_e1', progress: () => {
          return { current: (lifetimeStats.kingToE1 || 0), target: 1 };
        }},
        { id: 'king_to_e1_3', name: 'ðŸ‘‘ King to E1 Master', desc: 'Moved king to e1 three times', category: 'Random', points: 120, groupKey: 'king_to_e1', progress: () => {
          return { current: (lifetimeStats.kingToE1 || 0), target: 3 };
        }},
        { id: 'move_on_1', name: '1ï¸âƒ£ First Move', desc: 'Made a move on move 1', category: 'Random', points: 15, groupKey: 'moves_on_1', progress: () => {
          return { current: (lifetimeStats.movesOnMove1 || 0), target: 1 };
        }},
        { id: 'move_on_5', name: '5ï¸âƒ£ Fifth Move', desc: 'Made a move on move 5', category: 'Random', points: 20, groupKey: 'moves_on_5', progress: () => {
          return { current: (lifetimeStats.movesOnMove5 || 0), target: 1 };
        }},
        { id: 'move_on_10', name: 'ðŸ”Ÿ Tenth Move', desc: 'Made a move on move 10', category: 'Random', points: 25, groupKey: 'moves_on_10', progress: () => {
          return { current: (lifetimeStats.movesOnMove10 || 0), target: 1 };
        }},
        { id: 'move_on_20', name: '2ï¸âƒ£0ï¸âƒ£ Twentieth Move', desc: 'Made a move on move 20', category: 'Random', points: 30, groupKey: 'moves_on_20', progress: () => {
          return { current: (lifetimeStats.movesOnMove20 || 0), target: 1 };
        }},
        { id: 'move_on_50', name: '5ï¸âƒ£0ï¸âƒ£ Fiftieth Move', desc: 'Made a move on move 50', category: 'Random', points: 50, groupKey: 'moves_on_50', progress: () => {
          return { current: (lifetimeStats.movesOnMove50 || 0), target: 1 };
        }},
        { id: 'castle_on_10', name: 'ðŸ° Castle on 10', desc: 'Castled on your 10th move', category: 'Random', points: 75, groupKey: 'castle_on_10', progress: () => {
          return { current: (lifetimeStats.castledOnMove10 || 0), target: 1 };
        }},
        { id: 'castle_on_20', name: 'ðŸ° Castle on 20', desc: 'Castled on your 20th move', category: 'Random', points: 75, groupKey: 'castle_on_20', progress: () => {
          return { current: (lifetimeStats.castledOnMove20 || 0), target: 1 };
        }},
        { id: 'promote_to_queen', name: 'ðŸ‘¸ Queen Promotion', desc: 'Promoted to queen', category: 'Random', points: 50, groupKey: 'promote_to_queen', progress: () => {
          return { current: (lifetimeStats.promotedToQueen || 0), target: 1 };
        }},
        { id: 'promote_to_queen_3', name: 'ðŸ‘¸ Queen Promoter', desc: 'Promoted to queen three times', category: 'Random', points: 150, groupKey: 'promote_to_queen', progress: () => {
          return { current: (lifetimeStats.promotedToQueenMultiple || 0), target: 3 };
        }},
        { id: 'promote_to_rook', name: 'ðŸ° Rook Promotion', desc: 'Promoted to rook', category: 'Random', points: 100, groupKey: 'promote_to_rook', progress: () => {
          return { current: (lifetimeStats.promotedToRook || 0), target: 1 };
        }},
        { id: 'promote_to_bishop', name: 'â™— Bishop Promotion', desc: 'Promoted to bishop', category: 'Random', points: 100, groupKey: 'promote_to_bishop', progress: () => {
          return { current: (lifetimeStats.promotedToBishop || 0), target: 1 };
        }},
        { id: 'promote_to_knight', name: 'ðŸ´ Knight Promotion', desc: 'Promoted to knight', category: 'Random', points: 100, groupKey: 'promote_to_knight', progress: () => {
          return { current: (lifetimeStats.promotedToKnight || 0), target: 1 };
        }},
        { id: 'check_on_5', name: 'âœ“ Check on 5', desc: 'Gave check on your 5th move', category: 'Random', points: 75, groupKey: 'check_on_5', progress: () => {
          return { current: ((lifetimeStats.checkOnMove5 || 0) + ((gameStats && gameStats.checkOnMove5) || 0)), target: 1 };
        }},
        { id: 'capture_on_10', name: 'âš”ï¸ Capture on 10', desc: 'Captured on your 10th move', category: 'Random', points: 50, groupKey: 'capture_on_10', progress: () => {
          return { current: ((lifetimeStats.captureOnMove10 || 0) + ((gameStats && gameStats.captureOnMove10) || 0)), target: 1 };
        }},
        
        // More random piece-to-square achievements
        { id: 'rook_to_a1', name: 'ðŸ° Rook to A1', desc: 'Moved rook to a1', category: 'Random', points: 30, groupKey: 'rook_to_corners', progress: () => {
          return { current: (lifetimeStats.rookToA1 || 0), target: 1 };
        }},
        { id: 'rook_to_h1', name: 'ðŸ° Rook to H1', desc: 'Moved rook to h1', category: 'Random', points: 30, groupKey: 'rook_to_corners', progress: () => {
          return { current: (lifetimeStats.rookToH1 || 0), target: 1 };
        }},
        { id: 'bishop_to_c1', name: 'â™— Bishop to C1', desc: 'Moved bishop to c1', category: 'Random', points: 25, groupKey: 'bishop_to_start', progress: () => {
          return { current: (lifetimeStats.bishopToC1 || 0), target: 1 };
        }},
        { id: 'bishop_to_f1', name: 'â™— Bishop to F1', desc: 'Moved bishop to f1', category: 'Random', points: 25, groupKey: 'bishop_to_start', progress: () => {
          return { current: (lifetimeStats.bishopToF1 || 0), target: 1 };
        }},
        { id: 'knight_to_g1', name: 'ðŸ´ Knight to G1', desc: 'Moved knight to g1', category: 'Random', points: 20, groupKey: 'knight_to_start', progress: () => {
          return { current: (lifetimeStats.knightToG1 || 0), target: 1 };
        }},
        { id: 'knight_to_b1', name: 'ðŸ´ Knight to B1', desc: 'Moved knight to b1', category: 'Random', points: 20, groupKey: 'knight_to_start', progress: () => {
          return { current: (lifetimeStats.knightToB1 || 0), target: 1 };
        }},
        { id: 'queen_to_a1', name: 'ðŸ‘¸ Queen to A1', desc: 'Moved queen to a1', category: 'Random', points: 40, groupKey: 'queen_to_corners', progress: () => {
          return { current: (lifetimeStats.queenToA1 || 0), target: 1 };
        }},
        { id: 'queen_to_h1', name: 'ðŸ‘¸ Queen to H1', desc: 'Moved queen to h1', category: 'Random', points: 40, groupKey: 'queen_to_corners', progress: () => {
          return { current: (lifetimeStats.queenToH1 || 0), target: 1 };
        }},
        { id: 'king_to_g1', name: 'ðŸ‘‘ King to G1', desc: 'Moved king to g1', category: 'Random', points: 35, groupKey: 'king_to_castle', progress: () => {
          return { current: (lifetimeStats.kingToG1 || 0), target: 1 };
        }},
        { id: 'king_to_c1', name: 'ðŸ‘‘ King to C1', desc: 'Moved king to c1', category: 'Random', points: 35, groupKey: 'king_to_castle', progress: () => {
          return { current: (lifetimeStats.kingToC1 || 0), target: 1 };
        }},
        { id: 'pawn_to_a2', name: 'â™Ÿï¸ Pawn to A2', desc: 'Moved a pawn to a2', category: 'Random', points: 20, groupKey: 'pawn_to_edge', progress: () => {
          return { current: (lifetimeStats.pawnToA2 || 0), target: 1 };
        }},
        { id: 'pawn_to_h2', name: 'â™Ÿï¸ Pawn to H2', desc: 'Moved a pawn to h2', category: 'Random', points: 20, groupKey: 'pawn_to_edge', progress: () => {
          return { current: (lifetimeStats.pawnToH2 || 0), target: 1 };
        }},
        
        // Daily Achievements - ORIGINAL CHALLENGES
        { id: 'daily_explorer', name: 'ðŸ—ºï¸ Daily Explorer', desc: 'Visit 20 unique squares in one day', category: 'Daily', points: 100, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 20 };
          resetDailyStatsIfNeeded();
          const lifetimeCount = lifetimeStats.dailyStats.uniqueSquaresVisitedToday ? 
            (Array.isArray(lifetimeStats.dailyStats.uniqueSquaresVisitedToday) ? lifetimeStats.dailyStats.uniqueSquaresVisitedToday.length : 0) : 0;
          const gameCount = gameStats && gameStats.dailyStats && gameStats.dailyStats.uniqueSquaresVisitedToday ? gameStats.dailyStats.uniqueSquaresVisitedToday.length : 0;
          // Combine unique squares from both (avoid duplicates)
          const combined = new Set([...(lifetimeStats.dailyStats.uniqueSquaresVisitedToday || []), ...((gameStats && gameStats.dailyStats && gameStats.dailyStats.uniqueSquaresVisitedToday) || [])]);
          return { current: combined.size, target: 20 };
        }},
        { id: 'daily_warrior', name: 'âš”ï¸ Daily Warrior', desc: 'Make 5 captures in one day', category: 'Daily', points: 150, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 5 };
          resetDailyStatsIfNeeded();
          return { current: ((lifetimeStats.dailyStats.capturesToday || 0) + ((gameStats && gameStats.dailyStats && gameStats.dailyStats.capturesToday) || 0)), target: 5 };
        }},
        { id: 'daily_lightning', name: 'âš¡ Daily Lightning', desc: 'Win a game in under 15 moves today', category: 'Daily', points: 200, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 1 };
          resetDailyStatsIfNeeded();
          // Check if we've won a game today in under 15 moves
          const fastestWin = lifetimeStats.dailyStats.fastestWinToday === Infinity ? 0 : lifetimeStats.dailyStats.fastestWinToday;
          // Also check current game if it's a win and game is over (with safety checks)
          let currentGameWin = 0;
          try {
            if (typeof gameOver !== 'undefined' && gameOver && typeof game !== 'undefined' && game && typeof game.in_checkmate === 'function' && game.in_checkmate() && game.turn() !== (playerColor === 'white' ? 'w' : 'b')) {
              const currentMoveCount = game.history().length;
              if (currentMoveCount > 0 && currentMoveCount <= 15) {
                currentGameWin = 1;
              }
            }
          } catch (e) {
            // If there's an error accessing game, just use lifetimeStats
          }
          return { current: (fastestWin > 0 && fastestWin <= 15) || currentGameWin ? 1 : 0, target: 1 };
        }},
        { id: 'daily_capturer', name: 'ðŸŽ¯ Daily Capturer', desc: 'Make 10 captures in one day', category: 'Daily', points: 180, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 10 };
          resetDailyStatsIfNeeded();
          return { current: ((lifetimeStats.dailyStats.capturesToday || 0) + ((gameStats && gameStats.dailyStats && gameStats.dailyStats.capturesToday) || 0)), target: 10 };
        }},
        { id: 'daily_checker', name: 'âœ“ Daily Checker', desc: 'Give 8 checks in one day', category: 'Daily', points: 120, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 8 };
          resetDailyStatsIfNeeded();
          return { current: ((lifetimeStats.dailyStats.checksGivenToday || 0) + ((gameStats && gameStats.dailyStats && gameStats.dailyStats.checksGivenToday) || 0)), target: 8 };
        }},
        { id: 'daily_longgame', name: 'â±ï¸ Daily Marathon', desc: 'Play a game with 80+ moves today', category: 'Daily', points: 150, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 1 };
          resetDailyStatsIfNeeded();
          const longestGame = lifetimeStats.dailyStats.longestGameToday || 0;
          const currentGameMoves = (game && game.history && game.history().length) || 0;
          return { current: (longestGame >= 80 || currentGameMoves >= 80) ? 1 : 0, target: 1 };
        }},
        { id: 'daily_promoter', name: 'ðŸ‘‘ Daily Promoter', desc: 'Promote 3 pawns in one day', category: 'Daily', points: 160, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 3 };
          resetDailyStatsIfNeeded();
          return { current: ((lifetimeStats.dailyStats.promotionsToday || 0) + ((gameStats && gameStats.dailyStats && gameStats.dailyStats.promotionsToday) || 0)), target: 3 };
        }},
        { id: 'daily_castler', name: 'ðŸ° Daily Castler', desc: 'Castle 2 times in one day', category: 'Daily', points: 110, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 2 };
          resetDailyStatsIfNeeded();
          return { current: ((lifetimeStats.dailyStats.castlingToday || 0) + ((gameStats && gameStats.dailyStats && gameStats.dailyStats.castlingToday) || 0)), target: 2 };
        }},
        { id: 'daily_comeback', name: 'ðŸ’ª Daily Comeback', desc: 'Win 3 games in one day', category: 'Daily', points: 250, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 3 };
          resetDailyStatsIfNeeded();
          return { current: (lifetimeStats.dailyStats.gamesWonToday || 0), target: 3 };
        }},
        
        // Daily Achievements - UNIQUE AND CREATIVE CHALLENGES
        { id: 'daily_blindfold_bishop', name: 'ðŸ‘ï¸â™— Blindfold Bishop Master', desc: 'Make 5 bishop moves in blindfold games today', category: 'Daily', points: 250, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 5 };
          resetDailyStatsIfNeeded();
          const lifetimeCount = lifetimeStats.dailyStats.bishopMovesInBlindfoldToday || 0;
          const gameCount = (gameStats && gameStats.dailyStats && gameStats.dailyStats.bishopMovesInBlindfoldToday) || 0;
          return { current: lifetimeCount + gameCount, target: 5 };
        }},
        { id: 'daily_blindfold_knight', name: 'ðŸ‘ï¸ðŸ´ Blindfold Knight Rider', desc: 'Make 7 knight moves in blindfold games without move history today', category: 'Daily', points: 400, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 7 };
          resetDailyStatsIfNeeded();
          const lifetimeCount = lifetimeStats.dailyStats.knightMovesInPureBlindfoldToday || 0;
          const gameCount = (gameStats && gameStats.dailyStats && gameStats.dailyStats.knightMovesInPureBlindfoldToday) || 0;
          return { current: lifetimeCount + gameCount, target: 7 };
        }},
        { id: 'daily_pawn_promotion_chain', name: 'â™Ÿï¸â™Ÿï¸â™Ÿï¸ Triple Pawn Promotion', desc: 'Promote 3 pawns in a single game today', category: 'Daily', points: 450, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 1 };
          resetDailyStatsIfNeeded();
          const triplePromotionGames = (lifetimeStats.dailyStats.triplePromotionGamesToday || 0);
          return { current: triplePromotionGames, target: 1 };
        }},
        { id: 'daily_queen_tour', name: 'ðŸ‘¸ Queen World Tour', desc: 'Move your queen to all 4 corner squares (a1, h1, a8, h8) in one game today', category: 'Daily', points: 500, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 1 };
          resetDailyStatsIfNeeded();
          const queenTourGames = (lifetimeStats.dailyStats.queenTourGamesToday || 0);
          return { current: queenTourGames, target: 1 };
        }},
        { id: 'daily_rook_ladder', name: 'ðŸ° Rook Ladder', desc: 'Move both rooks to the 7th rank (or 2nd rank if black) in one game today', category: 'Daily', points: 380, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 1 };
          resetDailyStatsIfNeeded();
          const rookLadderGames = (lifetimeStats.dailyStats.rookLadderGamesToday || 0);
          return { current: rookLadderGames, target: 1 };
        }},
        { id: 'daily_bishop_pair', name: 'â™—â™— Bishop Pair Power', desc: 'Win a game where you kept both bishops until the end today', category: 'Daily', points: 350, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 1 };
          resetDailyStatsIfNeeded();
          const bishopPairWins = (lifetimeStats.dailyStats.bishopPairWinsToday || 0);
          return { current: bishopPairWins, target: 1 };
        }},
        { id: 'daily_pawn_storm', name: 'â™Ÿï¸ Pawn Storm', desc: 'Advance 5 different pawns to the 6th rank (or 3rd if black) in one game today', category: 'Daily', points: 400, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 1 };
          resetDailyStatsIfNeeded();
          const pawnStormGames = (lifetimeStats.dailyStats.pawnStormGamesToday || 0);
          return { current: pawnStormGames, target: 1 };
        }},
        { id: 'daily_king_walk', name: 'ðŸ‘‘ King Walk', desc: 'Move your king 10+ squares in one game today', category: 'Daily', points: 320, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 1 };
          resetDailyStatsIfNeeded();
          const kingWalkGames = (lifetimeStats.dailyStats.kingWalkGamesToday || 0);
          return { current: kingWalkGames, target: 1 };
        }},
        { id: 'daily_piece_cycle', name: 'ðŸ”„ Piece Cycle', desc: 'Move all 6 piece types (pawn, knight, bishop, rook, queen, king) in one game today', category: 'Daily', points: 450, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 1 };
          resetDailyStatsIfNeeded();
          const pieceCycleGames = (lifetimeStats.dailyStats.pieceCycleGamesToday || 0);
          return { current: pieceCycleGames, target: 1 };
        }},
        { id: 'daily_square_master', name: 'ðŸŽ¯ Square Master', desc: 'Visit all 8 squares on the e-file (e1-e8) in one game today', category: 'Daily', points: 500, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 1 };
          resetDailyStatsIfNeeded();
          const squareMasterGames = (lifetimeStats.dailyStats.squareMasterGamesToday || 0);
          return { current: squareMasterGames, target: 1 };
        }},
        { id: 'daily_blindfold_win_no_history', name: 'ðŸ‘ï¸âŒ Pure Blindfold Victory', desc: 'Win a blindfold game without move history today', category: 'Daily', points: 600, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 1 };
          resetDailyStatsIfNeeded();
          const pureBlindfoldWinsToday = (lifetimeStats.dailyStats.pureBlindfoldWinsToday || 0);
          return { current: pureBlindfoldWinsToday, target: 1 };
        }},
        { id: 'daily_piece_sacrifice_chain', name: 'ðŸ’Ž Sacrifice Chain', desc: 'Sacrifice 3 different pieces (not pawns) in one game today', category: 'Daily', points: 550, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 1 };
          resetDailyStatsIfNeeded();
          const sacrificeChainGames = (lifetimeStats.dailyStats.sacrificeChainGamesToday || 0);
          return { current: sacrificeChainGames, target: 1 };
        }},
        { id: 'daily_center_control', name: 'ðŸŽ¯ Center Control', desc: 'Occupy all 4 center squares (d4, d5, e4, e5) with your pieces in one game today', category: 'Daily', points: 480, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 1 };
          resetDailyStatsIfNeeded();
          const centerControlGames = (lifetimeStats.dailyStats.centerControlGamesToday || 0);
          return { current: centerControlGames, target: 1 };
        }},
        { id: 'daily_pawn_island', name: 'ðŸï¸ Pawn Island', desc: 'Create 3 isolated pawn islands in one game today', category: 'Daily', points: 380, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 1 };
          resetDailyStatsIfNeeded();
          const pawnIslandGames = (lifetimeStats.dailyStats.pawnIslandGamesToday || 0);
          return { current: pawnIslandGames, target: 1 };
        }},
        { id: 'daily_rook_battery', name: 'ðŸ° Rook Battery', desc: 'Create a rook battery (2 rooks on same file/rank) in one game today', category: 'Daily', points: 350, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 1 };
          resetDailyStatsIfNeeded();
          const rookBatteryGames = (lifetimeStats.dailyStats.rookBatteryGamesToday || 0);
          return { current: rookBatteryGames, target: 1 };
        }},
        { id: 'daily_personality_master', name: 'ðŸŽ­ Personality Master', desc: 'Beat 3 different engine personalities in one day', category: 'Daily', points: 350, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 3 };
          resetDailyStatsIfNeeded();
          const uniquePersonalities = lifetimeStats.dailyStats.personalitiesWonToday || [];
          return { current: uniquePersonalities.length, target: 3 };
        }},
        { id: 'daily_survivor', name: 'ðŸ›¡ï¸ Daily Survivor', desc: 'Make 10 consecutive moves in one game without losing a piece', category: 'Daily', points: 225, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 10 };
          resetDailyStatsIfNeeded();
          const longestStreak = lifetimeStats.dailyStats.longestStreakNoPiecesLostToday || 0;
          const currentStreak = (gameStats && gameStats.dailyStats && gameStats.dailyStats.currentStreakNoPiecesLost) || 0;
          return { current: Math.max(longestStreak, currentStreak), target: 10 };
        }},
        { id: 'daily_blitz_king', name: 'âš¡âš¡ Blitz King', desc: 'Win 2 games with 1-minute time control today', category: 'Daily', points: 300, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 2 };
          resetDailyStatsIfNeeded();
          const winsByTime = lifetimeStats.dailyStats.winsByTimeControlToday || {};
          // Time control '60' is for 1 minute
          const wins1Min = winsByTime['60'] || 0;
          return { current: wins1Min, target: 2 };
        }},
        { id: 'daily_time_master', name: 'â±ï¸ Time Master', desc: 'Win games with 3 different time controls today', category: 'Daily', points: 280, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 3 };
          resetDailyStatsIfNeeded();
          const timeControlsWon = lifetimeStats.dailyStats.winsByTimeControlToday || {};
          const uniqueTimeControls = Object.keys(timeControlsWon).filter(tc => timeControlsWon[tc] > 0);
          return { current: uniqueTimeControls.length, target: 3 };
        }},
        { id: 'daily_king_safety', name: "ðŸ‘‘ King's Guard", desc: 'Castle in 3 different games today', category: 'Daily', points: 200, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 3 };
          resetDailyStatsIfNeeded();
          const gamesWithCastling = (lifetimeStats.dailyStats.gamesCastledToday || 0);
          return { current: gamesWithCastling, target: 3 };
        }},
        { id: 'daily_promotion_royalty', name: 'ðŸ‘¸ Promotion Royalty', desc: 'Promote a pawn in 2 different games today', category: 'Daily', points: 240, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 2 };
          resetDailyStatsIfNeeded();
          const gamesWithPromotion = (lifetimeStats.dailyStats.gamesPromotedToday || 0);
          return { current: gamesWithPromotion, target: 2 };
        }},
        { id: 'daily_material_advantage', name: 'âš–ï¸ Material Master', desc: 'Win 2 games where you had a material advantage of 3+ points', category: 'Daily', points: 275, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 2 };
          resetDailyStatsIfNeeded();
          const winsWithAdvantage = (lifetimeStats.dailyStats.winsWithMaterialAdvantageToday || 0);
          return { current: winsWithAdvantage, target: 2 };
        }},
        { id: 'daily_openings_expert', name: 'ðŸ“š Opening Expert', desc: 'Play 3 different detected openings today', category: 'Daily', points: 220, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 3 };
          resetDailyStatsIfNeeded();
          const uniqueOpenings = lifetimeStats.dailyStats.uniqueOpeningsPlayedToday || [];
          return { current: uniqueOpenings.length, target: 3 };
        }},
        { id: 'daily_checkmate_artist', name: 'ðŸŽ¨ Checkmate Artist', desc: 'Checkmate with 3 different pieces today (queen, rook, knight, bishop, or pawn)', category: 'Daily', points: 400, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 3 };
          resetDailyStatsIfNeeded();
          const uniqueCheckmatePieces = lifetimeStats.dailyStats.uniqueCheckmatePiecesToday || [];
          return { current: uniqueCheckmatePieces.length, target: 3 };
        }},
        { id: 'daily_en_passant_master', name: 'ðŸŽ¯ En Passant Master', desc: 'Perform en passant in 2 different games today', category: 'Daily', points: 300, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 2 };
          resetDailyStatsIfNeeded();
          const gamesWithEnPassant = (lifetimeStats.dailyStats.gamesWithEnPassantToday || 0);
          return { current: gamesWithEnPassant, target: 2 };
        }},
        { id: 'daily_underpromotion', name: 'â™Ÿï¸ Underpromotion Specialist', desc: 'Underpromote a pawn (to rook, bishop, or knight) in one game today', category: 'Daily', points: 350, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 1 };
          resetDailyStatsIfNeeded();
          const underpromotions = (lifetimeStats.dailyStats.underpromotionsToday || 0);
          return { current: underpromotions, target: 1 };
        }},
        { id: 'daily_queen_sacrifice', name: 'ðŸ‘‘ Queen Sacrifice', desc: 'Win a game after sacrificing your queen today', category: 'Daily', points: 500, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 1 };
          resetDailyStatsIfNeeded();
          const queenSacrificeWins = (lifetimeStats.dailyStats.queenSacrificeWinsToday || 0);
          return { current: queenSacrificeWins, target: 1 };
        }},
        { id: 'daily_time_pressure', name: 'â° Time Pressure Hero', desc: 'Win a game with less than 10 seconds remaining on your clock', category: 'Daily', points: 450, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 1 };
          resetDailyStatsIfNeeded();
          const timePressureWins = (lifetimeStats.dailyStats.timePressureWinsToday || 0);
          return { current: timePressureWins, target: 1 };
        }},
        { id: 'daily_opening_trap', name: 'ðŸª¤ Opening Trap Master', desc: 'Win a game in under 20 moves today', category: 'Daily', points: 320, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 1 };
          resetDailyStatsIfNeeded();
          const fastestWin = lifetimeStats.dailyStats.fastestWinToday === Infinity ? 0 : lifetimeStats.dailyStats.fastestWinToday;
          return { current: (fastestWin > 0 && fastestWin <= 20) ? 1 : 0, target: 1 };
        }},
        { id: 'daily_endgame_grinder', name: 'ðŸ”¨ Endgame Grinder', desc: 'Win a game that lasted 100+ moves today', category: 'Daily', points: 380, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 1 };
          resetDailyStatsIfNeeded();
          return { current: (lifetimeStats.dailyStats.longestGameToday >= 100) ? 1 : 0, target: 1 };
        }},
        { id: 'daily_perfect_defense', name: 'ðŸ›¡ï¸ Perfect Defense', desc: 'Win a game without losing any pieces today', category: 'Daily', points: 400, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 1 };
          resetDailyStatsIfNeeded();
          const perfectWins = (lifetimeStats.dailyStats.perfectWinsToday || 0);
          return { current: perfectWins, target: 1 };
        }},
        { id: 'daily_check_storm', name: 'âš¡ Check Storm', desc: 'Give 10 checks in a single game today', category: 'Daily', points: 280, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 1 };
          resetDailyStatsIfNeeded();
          const maxChecksInGame = (lifetimeStats.dailyStats.maxChecksInSingleGameToday || 0);
          return { current: (maxChecksInGame >= 10) ? 1 : 0, target: 1 };
        }},
        { id: 'daily_double_castle', name: 'ðŸ° Double Castle', desc: 'Castle both kingside and queenside in the same game today', category: 'Daily', points: 350, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 1 };
          resetDailyStatsIfNeeded();
          const doubleCastleGames = (lifetimeStats.dailyStats.doubleCastleGamesToday || 0);
          return { current: doubleCastleGames, target: 1 };
        }},
        { id: 'daily_promotion_variety', name: 'ðŸ‘¸ Promotion Variety', desc: 'Promote to 2 different pieces (queen, rook, bishop, knight) in one game today', category: 'Daily', points: 420, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 1 };
          resetDailyStatsIfNeeded();
          const varietyPromotionGames = (lifetimeStats.dailyStats.varietyPromotionGamesToday || 0);
          return { current: varietyPromotionGames, target: 1 };
        }},
        { id: 'daily_comeback_king', name: 'ðŸ’ª Comeback King', desc: 'Win a game after being down by 5+ material points today', category: 'Daily', points: 500, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 1 };
          resetDailyStatsIfNeeded();
          const comebackWins = (lifetimeStats.dailyStats.comebackWinsToday || 0);
          return { current: comebackWins, target: 1 };
        }},
        { id: 'daily_piece_hunter', name: 'ðŸŽ¯ Piece Hunter', desc: 'Capture 5 different types of pieces (queen, rook, bishop, knight, pawn) in one game today', category: 'Daily', points: 450, isDaily: true, progress: () => {
          if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: 1 };
          resetDailyStatsIfNeeded();
          const pieceHunterGames = (lifetimeStats.dailyStats.pieceHunterGamesToday || 0);
          return { current: pieceHunterGames, target: 1 };
        }},
        
        // ========================================================================
        // ADD NEW DAILY CHALLENGES HERE
        // ========================================================================
        // Template for creating a new daily challenge:
        // { id: 'daily_your_challenge_id', name: 'ðŸŽ¯ Your Challenge Name', desc: 'Your challenge description', category: 'Daily', points: 150, isDaily: true, progress: () => {
        //   if (!lifetimeStats || !lifetimeStats.dailyStats) return { current: 0, target: YOUR_TARGET };
        //   resetDailyStatsIfNeeded();
        //   // Track your stat from lifetimeStats.dailyStats.YOUR_STAT or gameStats.dailyStats.YOUR_STAT
        //   return { current: ((lifetimeStats.dailyStats.YOUR_STAT || 0) + ((gameStats && gameStats.dailyStats && gameStats.dailyStats.YOUR_STAT) || 0)), target: YOUR_TARGET };
        // }},
        //
        // After adding a new daily challenge:
        // 1. Add its ID to getAllDailyChallengeIds() function (see above)
        // 2. Add it to one or more arrays in DAILY_CHALLENGES_CONFIG to include it in rotation
        // 3. Make sure to track the stat in lifetimeStats.dailyStats and gameStats.dailyStats
        // 4. Update resetDailyStatsIfNeeded() to reset your stat when day changes
        // ========================================================================
        
        // Time Control Achievements
        { id: 'win_no_time', name: 'â° Untimed Victory', desc: 'Win 5 games with no time control', category: 'Creative', points: 100, groupKey: 'time_control_wins', progress: () => {
          return { current: (lifetimeStats.winsByTimeControl && lifetimeStats.winsByTimeControl.none) || 0, target: 5 };
        }},
        { id: 'win_1min', name: 'âš¡ Lightning Victory', desc: 'Win 3 games with 1 minute time control', category: 'Creative', points: 150, groupKey: 'time_control_wins', progress: () => {
          return { current: (lifetimeStats.winsByTimeControl && lifetimeStats.winsByTimeControl['60']) || 0, target: 3 };
        }},
        { id: 'win_3min', name: 'ðŸš€ Rapid Victory', desc: 'Win 5 games with 3|2 time control', category: 'Creative', points: 120, groupKey: 'time_control_wins', progress: () => {
          return { current: (lifetimeStats.winsByTimeControl && lifetimeStats.winsByTimeControl['180|2']) || 0, target: 5 };
        }},
        { id: 'win_5min', name: 'â±ï¸ Five Minute Master', desc: 'Win 10 games with 5 minute time control', category: 'Creative', points: 200, groupKey: 'time_control_wins', progress: () => {
          return { current: (lifetimeStats.winsByTimeControl && lifetimeStats.winsByTimeControl['300|0']) || 0, target: 10 };
        }},
        { id: 'win_10min', name: 'ðŸŽ¯ Ten Minute Expert', desc: 'Win 10 games with 10 minute time control', category: 'Creative', points: 180, groupKey: 'time_control_wins', progress: () => {
          return { current: (lifetimeStats.winsByTimeControl && lifetimeStats.winsByTimeControl['600|0']) || 0, target: 10 };
        }},
        { id: 'win_15min', name: 'ðŸ† Classic Player', desc: 'Win 8 games with 15|5 time control', category: 'Creative', points: 160, groupKey: 'time_control_wins', progress: () => {
          return { current: (lifetimeStats.winsByTimeControl && lifetimeStats.winsByTimeControl['900|5']) || 0, target: 8 };
        }},
        { id: 'win_60min', name: 'â™Ÿï¸ Long Game Champion', desc: 'Win 5 games with 60 minute time control', category: 'Creative', points: 300, groupKey: 'time_control_wins', progress: () => {
          return { current: (lifetimeStats.winsByTimeControl && lifetimeStats.winsByTimeControl['3600|0']) || 0, target: 5 };
        }},
        
        // Personality Achievements
        { id: 'beat_balanced', name: 'âš–ï¸ Balance Breaker', desc: 'Win 5 games against Balanced personality', category: 'Creative', points: 100, groupKey: 'personality_wins', progress: () => {
          return { current: (lifetimeStats.winsByPersonality && lifetimeStats.winsByPersonality.balanced) || 0, target: 5 };
        }},
        { id: 'beat_aggressive', name: 'ðŸ›¡ï¸ Defense Master', desc: 'Win 3 games against Aggressive personality', category: 'Creative', points: 150, groupKey: 'personality_wins', progress: () => {
          return { current: (lifetimeStats.winsByPersonality && lifetimeStats.winsByPersonality.aggressive) || 0, target: 3 };
        }},
        { id: 'beat_defensive', name: 'âš”ï¸ Offensive Expert', desc: 'Win 3 games against Defensive personality', category: 'Creative', points: 150, groupKey: 'personality_wins', progress: () => {
          return { current: (lifetimeStats.winsByPersonality && lifetimeStats.winsByPersonality.defensive) || 0, target: 3 };
        }},
        { id: 'beat_positional', name: 'ðŸŽ¯ Tactical Genius', desc: 'Win 3 games against Positional personality', category: 'Creative', points: 180, groupKey: 'personality_wins', progress: () => {
          return { current: (lifetimeStats.winsByPersonality && lifetimeStats.winsByPersonality.positional) || 0, target: 3 };
        }},
        { id: 'beat_material', name: 'ðŸ’Ž Material Overcome', desc: 'Win 3 games against Material-Focused personality', category: 'Creative', points: 160, groupKey: 'personality_wins', progress: () => {
          return { current: (lifetimeStats.winsByPersonality && lifetimeStats.winsByPersonality.material) || 0, target: 3 };
        }},
        { id: 'beat_tactical', name: 'ðŸ§  Strategy Master', desc: 'Win 3 games against Tactical personality', category: 'Creative', points: 200, groupKey: 'personality_wins', progress: () => {
          return { current: (lifetimeStats.winsByPersonality && lifetimeStats.winsByPersonality.tactical) || 0, target: 3 };
        }},
        { id: 'beat_custom', name: 'ðŸŽ›ï¸ Custom Conqueror', desc: 'Win 5 games against Custom personality', category: 'Creative', points: 120, groupKey: 'personality_wins', progress: () => {
          return { current: (lifetimeStats.winsByPersonality && lifetimeStats.winsByPersonality.custom) || 0, target: 5 };
        }},
        { id: 'beat_all_personalities', name: 'ðŸ‘‘ Personality Slayer', desc: 'Win at least 1 game against all 7 personalities', category: 'Creative', points: 500, requiredPoints: 5000, groupKey: 'personality_wins', progress: () => {
          if (!lifetimeStats.winsByPersonality) return { current: 0, target: 7 };
          const personalities = ['balanced', 'aggressive', 'defensive', 'positional', 'material', 'tactical', 'custom'];
          const beaten = personalities.filter(p => (lifetimeStats.winsByPersonality[p] || 0) >= 1).length;
          return { current: beaten, target: 7 };
        }},
        
        // Creative Speed Achievements
        { id: 'speed_demon', name: 'âš¡ Speed Demon', desc: 'Win 5 games in under 10 moves', category: 'Creative', points: 300, groupKey: 'speed_wins', progress: () => {
          return { current: (lifetimeStats.winsInUnder10Moves || 0), target: 5 };
        }},
        { id: 'blitz_master', name: 'ðŸš€ Blitz Master', desc: 'Win 10 games in under 20 moves', category: 'Creative', points: 400, groupKey: 'speed_wins', progress: () => {
          return { current: (lifetimeStats.winsInUnder20Moves || 0), target: 10 };
        }},
        { id: 'marathon_winner', name: 'ðŸƒ Marathon Winner', desc: 'Win 3 games with 100+ moves', category: 'Creative', points: 350, groupKey: 'marathon_wins', progress: () => {
          return { current: (lifetimeStats.winsInOver100Moves || 0), target: 3 };
        }},
        
        // Win Streak Achievements
        { id: 'streak_5', name: 'ðŸ”¥ Hot Streak', desc: 'Win 5 games in a row', category: 'Creative', points: 200, groupKey: 'win_streaks', progress: () => {
          return { current: (lifetimeStats.currentWinStreak || 0), target: 5 };
        }},
        { id: 'streak_10', name: 'ðŸ”¥ðŸ”¥ On Fire', desc: 'Win 10 games in a row', category: 'Creative', points: 400, groupKey: 'win_streaks', progress: () => {
          return { current: (lifetimeStats.currentWinStreak || 0), target: 10 };
        }},
        { id: 'streak_20', name: 'ðŸ”¥ðŸ”¥ðŸ”¥ Unstoppable', desc: 'Win 20 games in a row', category: 'Creative', points: 800, requiredPoints: 10000, groupKey: 'win_streaks', progress: () => {
          return { current: (lifetimeStats.currentWinStreak || 0), target: 20 };
        }},
        { id: 'longest_streak_10', name: 'â­ Best Streak', desc: 'Achieve a longest win streak of 10+', category: 'Creative', points: 300, groupKey: 'win_streaks', progress: () => {
          return { current: (lifetimeStats.longestWinStreak || 0), target: 10 };
        }},
        { id: 'longest_streak_25', name: 'ðŸŒŸ Legendary Streak', desc: 'Achieve a longest win streak of 25+', category: 'Creative', points: 1000, requiredPoints: 15000, groupKey: 'win_streaks', progress: () => {
          return { current: (lifetimeStats.longestWinStreak || 0), target: 25 };
        }},
        
        // Additional Creative Achievements
        { id: 'win_as_white', name: 'âšª White Specialist', desc: 'Win 20 games playing as White', category: 'Creative', points: 150, groupKey: 'color_wins', progress: () => {
          // This would require tracking wins by color - placeholder for now
          return { current: 0, target: 20 };
        }},
        { id: 'win_as_black', name: 'âš« Black Specialist', desc: 'Win 20 games playing as Black', category: 'Creative', points: 150, groupKey: 'color_wins', progress: () => {
          // This would require tracking wins by color - placeholder for now
          return { current: 0, target: 20 };
        }},
        { id: 'time_pressure', name: 'â³ Time Pressure', desc: 'Win 5 games with less than 10 seconds remaining', category: 'Creative', points: 400, groupKey: 'time_pressure', progress: () => {
          // This would require tracking time remaining at win - placeholder
          return { current: 0, target: 5 };
        }},
        { id: 'perfect_opening', name: 'ðŸ“– Theory Master', desc: 'Win 10 games where opening was detected', category: 'Creative', points: 250, groupKey: 'opening_wins', progress: () => {
          // This would require tracking games with detected openings - placeholder
          return { current: 0, target: 10 };
        }},
        
        // Milestone Win Achievements (High Engagement Drivers)
        { id: 'hundred_wins', name: 'ðŸ’¯ Century of Wins', desc: 'Win 100 games', category: 'General', points: 500, groupKey: 'milestone_wins', progress: () => {
          return { current: playerStats.wins || 0, target: 100 };
        }},
        { id: 'five_hundred_wins', name: 'ðŸ† Five Hundred Wins', desc: 'Win 500 games', category: 'General', points: 2000, requiredPoints: 5000, groupKey: 'milestone_wins', progress: () => {
          return { current: playerStats.wins || 0, target: 500 };
        }},
        { id: 'thousand_wins', name: 'ðŸ‘‘ Thousand Wins', desc: 'Win 1000 games', category: 'General', points: 5000, requiredPoints: 15000, groupKey: 'milestone_wins', progress: () => {
          return { current: playerStats.wins || 0, target: 1000 };
        }},
        
        // Consistency Achievements (Daily Engagement)
        { id: 'daily_player_3', name: 'ðŸ“… Three Day Streak', desc: 'Play 3 days in a row', category: 'Creative', points: 150, groupKey: 'consistency', progress: () => {
          return { current: (lifetimeStats.daysPlayedInARow || 0), target: 3 };
        }},
        { id: 'daily_player_7', name: 'ðŸ“… Week Warrior', desc: 'Play 7 days in a row', category: 'Creative', points: 300, groupKey: 'consistency', progress: () => {
          return { current: (lifetimeStats.daysPlayedInARow || 0), target: 7 };
        }},
        { id: 'daily_player_14', name: 'ðŸ“… Two Week Champion', desc: 'Play 14 days in a row', category: 'Creative', points: 600, groupKey: 'consistency', progress: () => {
          return { current: (lifetimeStats.daysPlayedInARow || 0), target: 14 };
        }},
        { id: 'daily_player_30', name: 'ðŸ“… Monthly Master', desc: 'Play 30 days in a row', category: 'Creative', points: 1500, requiredPoints: 10000, groupKey: 'consistency', progress: () => {
          return { current: (lifetimeStats.daysPlayedInARow || 0), target: 30 };
        }},
        
        // Perfect Game Achievements
        { id: 'perfect_game_1', name: 'âœ¨ Perfect Game', desc: 'Win a game without losing any pieces', category: 'Creative', points: 400, groupKey: 'perfect_games', progress: () => {
          return { current: (lifetimeStats.perfectGames || 0), target: 1 };
        }},
        { id: 'perfect_game_5', name: 'âœ¨âœ¨ Perfect Master', desc: 'Win 5 games without losing pieces', category: 'Creative', points: 1000, requiredPoints: 8000, groupKey: 'perfect_games', progress: () => {
          return { current: (lifetimeStats.perfectGames || 0), target: 5 };
        }},
        
        // Special Checkmate Achievements (points increase with difficulty - pawn is hardest, queen is easiest)
        { id: 'checkmate_pawn', name: 'â™Ÿï¸ Pawn Checkmate', desc: 'Checkmate with a pawn', category: 'Creative', points: 1000, requiredPoints: 3000, groupKey: 'special_checkmates', progress: () => {
          return { current: (lifetimeStats.checkmateWithPawn || 0), target: 1 };
        }},
        { id: 'checkmate_knight', name: 'ðŸ´ Knight Checkmate', desc: 'Checkmate with a knight', category: 'Creative', points: 800, groupKey: 'special_checkmates', progress: () => {
          return { current: (lifetimeStats.checkmateWithKnight || 0), target: 1 };
        }},
        { id: 'checkmate_bishop', name: 'â™— Bishop Checkmate', desc: 'Checkmate with a bishop', category: 'Creative', points: 750, groupKey: 'special_checkmates', progress: () => {
          return { current: (lifetimeStats.checkmateWithBishop || 0), target: 1 };
        }},
        { id: 'checkmate_rook', name: 'ðŸ° Rook Checkmate', desc: 'Checkmate with a rook', category: 'Creative', points: 500, groupKey: 'special_checkmates', progress: () => {
          return { current: (lifetimeStats.checkmateWithRook || 0), target: 1 };
        }},
        { id: 'checkmate_queen', name: 'ðŸ‘¸ Queen Checkmate', desc: 'Checkmate with a queen', category: 'Creative', points: 300, groupKey: 'special_checkmates', progress: () => {
          return { current: (lifetimeStats.checkmateWithQueen || 0), target: 1 };
        }},
        
        // Multiple Checkmate Achievements - Knight (hard, high points)
        { id: 'checkmate_knight_5', name: 'ðŸ´ðŸ´ Knight Specialist', desc: 'Checkmate with a knight 5 times', category: 'Creative', points: 2000, requiredPoints: 2000, groupKey: 'multiple_checkmates_knight', progress: () => {
          return { current: (lifetimeStats.checkmateWithKnight || 0), target: 5 };
        }},
        { id: 'checkmate_knight_10', name: 'ðŸ´ðŸ´ðŸ´ Knight Master', desc: 'Checkmate with a knight 10 times', category: 'Creative', points: 4000, requiredPoints: 5000, groupKey: 'multiple_checkmates_knight', progress: () => {
          return { current: (lifetimeStats.checkmateWithKnight || 0), target: 10 };
        }},
        { id: 'checkmate_knight_25', name: 'ðŸ´ðŸ´ðŸ´ðŸ´ Knight Legend', desc: 'Checkmate with a knight 25 times', category: 'Creative', points: 8000, requiredPoints: 15000, groupKey: 'multiple_checkmates_knight', progress: () => {
          return { current: (lifetimeStats.checkmateWithKnight || 0), target: 25 };
        }},
        { id: 'checkmate_knight_50', name: 'ðŸ´ðŸ´ðŸ´ðŸ´ðŸ´ Knight Grandmaster', desc: 'Checkmate with a knight 50 times', category: 'Creative', points: 15000, requiredPoints: 30000, groupKey: 'multiple_checkmates_knight', progress: () => {
          return { current: (lifetimeStats.checkmateWithKnight || 0), target: 50 };
        }},
        
        // Multiple Checkmate Achievements - Bishop (hard, high points)
        { id: 'checkmate_bishop_5', name: 'â™—â™— Bishop Specialist', desc: 'Checkmate with a bishop 5 times', category: 'Creative', points: 1800, requiredPoints: 2000, groupKey: 'multiple_checkmates_bishop', progress: () => {
          return { current: (lifetimeStats.checkmateWithBishop || 0), target: 5 };
        }},
        { id: 'checkmate_bishop_10', name: 'â™—â™—â™— Bishop Master', desc: 'Checkmate with a bishop 10 times', category: 'Creative', points: 3500, requiredPoints: 5000, groupKey: 'multiple_checkmates_bishop', progress: () => {
          return { current: (lifetimeStats.checkmateWithBishop || 0), target: 10 };
        }},
        { id: 'checkmate_bishop_25', name: 'â™—â™—â™—â™— Bishop Legend', desc: 'Checkmate with a bishop 25 times', category: 'Creative', points: 7000, requiredPoints: 15000, groupKey: 'multiple_checkmates_bishop', progress: () => {
          return { current: (lifetimeStats.checkmateWithBishop || 0), target: 25 };
        }},
        { id: 'checkmate_bishop_50', name: 'â™—â™—â™—â™—â™— Bishop Grandmaster', desc: 'Checkmate with a bishop 50 times', category: 'Creative', points: 14000, requiredPoints: 30000, groupKey: 'multiple_checkmates_bishop', progress: () => {
          return { current: (lifetimeStats.checkmateWithBishop || 0), target: 50 };
        }},
        
        // Multiple Checkmate Achievements - Rook (medium difficulty, medium points)
        { id: 'checkmate_rook_5', name: 'ðŸ°ðŸ° Rook Specialist', desc: 'Checkmate with a rook 5 times', category: 'Creative', points: 1200, requiredPoints: 1500, groupKey: 'multiple_checkmates_rook', progress: () => {
          return { current: (lifetimeStats.checkmateWithRook || 0), target: 5 };
        }},
        { id: 'checkmate_rook_10', name: 'ðŸ°ðŸ°ðŸ° Rook Master', desc: 'Checkmate with a rook 10 times', category: 'Creative', points: 2200, requiredPoints: 4000, groupKey: 'multiple_checkmates_rook', progress: () => {
          return { current: (lifetimeStats.checkmateWithRook || 0), target: 10 };
        }},
        { id: 'checkmate_rook_25', name: 'ðŸ°ðŸ°ðŸ°ðŸ° Rook Legend', desc: 'Checkmate with a rook 25 times', category: 'Creative', points: 4500, requiredPoints: 12000, groupKey: 'multiple_checkmates_rook', progress: () => {
          return { current: (lifetimeStats.checkmateWithRook || 0), target: 25 };
        }},
        { id: 'checkmate_rook_50', name: 'ðŸ°ðŸ°ðŸ°ðŸ°ðŸ° Rook Grandmaster', desc: 'Checkmate with a rook 50 times', category: 'Creative', points: 8500, requiredPoints: 25000, groupKey: 'multiple_checkmates_rook', progress: () => {
          return { current: (lifetimeStats.checkmateWithRook || 0), target: 50 };
        }},
        
        // Multiple Checkmate Achievements - Queen (easiest, lower points)
        { id: 'checkmate_queen_5', name: 'ðŸ‘¸ðŸ‘¸ Queen Specialist', desc: 'Checkmate with a queen 5 times', category: 'Creative', points: 500, requiredPoints: 1000, groupKey: 'multiple_checkmates_queen', progress: () => {
          return { current: (lifetimeStats.checkmateWithQueen || 0), target: 5 };
        }},
        { id: 'checkmate_queen_10', name: 'ðŸ‘¸ðŸ‘¸ðŸ‘¸ Queen Master', desc: 'Checkmate with a queen 10 times', category: 'Creative', points: 800, requiredPoints: 3000, groupKey: 'multiple_checkmates_queen', progress: () => {
          return { current: (lifetimeStats.checkmateWithQueen || 0), target: 10 };
        }},
        { id: 'checkmate_queen_25', name: 'ðŸ‘¸ðŸ‘¸ðŸ‘¸ðŸ‘¸ Queen Legend', desc: 'Checkmate with a queen 25 times', category: 'Creative', points: 1500, requiredPoints: 10000, groupKey: 'multiple_checkmates_queen', progress: () => {
          return { current: (lifetimeStats.checkmateWithQueen || 0), target: 25 };
        }},
        { id: 'checkmate_queen_50', name: 'ðŸ‘¸ðŸ‘¸ðŸ‘¸ðŸ‘¸ðŸ‘¸ Queen Grandmaster', desc: 'Checkmate with a queen 50 times', category: 'Creative', points: 2800, requiredPoints: 20000, groupKey: 'multiple_checkmates_queen', progress: () => {
          return { current: (lifetimeStats.checkmateWithQueen || 0), target: 50 };
        }},
        { id: 'checkmate_queen_100', name: 'ðŸ‘¸ðŸ‘¸ðŸ‘¸ðŸ‘¸ðŸ‘¸ðŸ‘¸ Queen Supreme', desc: 'Checkmate with a queen 100 times', category: 'Creative', points: 5000, requiredPoints: 40000, groupKey: 'multiple_checkmates_queen', progress: () => {
          return { current: (lifetimeStats.checkmateWithQueen || 0), target: 100 };
        }},
        
        // Multiple Checkmate Achievements - Pawn (Hardest, highest points!)
        { id: 'checkmate_pawn_3', name: 'â™Ÿï¸â™Ÿï¸â™Ÿï¸ Pawn Master', desc: 'Checkmate with a pawn 3 times', category: 'Creative', points: 4000, requiredPoints: 5000, groupKey: 'multiple_checkmates_pawn', progress: () => {
          return { current: (lifetimeStats.checkmateWithPawn || 0), target: 3 };
        }},
        { id: 'checkmate_pawn_5', name: 'â™Ÿï¸â™Ÿï¸â™Ÿï¸â™Ÿï¸ Pawn Legend', desc: 'Checkmate with a pawn 5 times', category: 'Creative', points: 8000, requiredPoints: 15000, groupKey: 'multiple_checkmates_pawn', progress: () => {
          return { current: (lifetimeStats.checkmateWithPawn || 0), target: 5 };
        }},
        { id: 'checkmate_pawn_10', name: 'â™Ÿï¸â™Ÿï¸â™Ÿï¸â™Ÿï¸â™Ÿï¸ Pawn Grandmaster', desc: 'Checkmate with a pawn 10 times', category: 'Creative', points: 18000, requiredPoints: 30000, groupKey: 'multiple_checkmates_pawn', progress: () => {
          return { current: (lifetimeStats.checkmateWithPawn || 0), target: 10 };
        }},
        
        // Variety Achievements (Encourage Trying Different Settings)
        { id: 'play_all_time_controls', name: 'â° Time Control Explorer', desc: 'Play games with all 7 time controls', category: 'Creative', points: 400, groupKey: 'variety', progress: () => {
          if (!lifetimeStats.winsByTimeControl) return { current: 0, target: 7 };
          const timeControls = ['none', '60', '180|2', '300|0', '600|0', '900|5', '3600|0'];
          const played = timeControls.filter(tc => (lifetimeStats.winsByTimeControl[tc] || 0) > 0).length;
          return { current: played, target: 7 };
        }},
        { id: 'play_all_personalities', name: 'ðŸŽ­ Personality Explorer', desc: 'Play games against all 7 personalities', category: 'Creative', points: 500, groupKey: 'variety', progress: () => {
          if (!lifetimeStats.winsByPersonality) return { current: 0, target: 7 };
          const personalities = ['balanced', 'aggressive', 'defensive', 'positional', 'material', 'tactical', 'custom'];
          const played = personalities.filter(p => (lifetimeStats.winsByPersonality[p] || 0) > 0).length;
          return { current: played, target: 7 };
        }},
        { id: 'win_both_colors', name: 'âšªâš« Color Master', desc: 'Win 10 games as White and 10 as Black', category: 'Creative', points: 300, groupKey: 'variety', progress: () => {
          const whiteWins = (lifetimeStats.winsAsWhite || 0);
          const blackWins = (lifetimeStats.winsAsBlack || 0);
          const minWins = Math.min(whiteWins, blackWins);
          return { current: minWins, target: 10 };
        }},
        
        // Collection Achievements (Unlock All in Category)
        { id: 'collect_all_general', name: 'ðŸ“š General Collector', desc: 'Unlock all General achievements', category: 'Creative', points: 1000, requiredPoints: 5000, groupKey: 'collections', progress: () => {
          const allAchievements = getAllAchievementsList();
          const generalAchs = allAchievements.filter(a => a.category === 'General' && !a.isDaily);
          const unlocked = generalAchs.filter(a => achievements.includes(a.id)).length;
          return { current: unlocked, target: generalAchs.length };
        }},
        { id: 'collect_all_ingame', name: 'âš”ï¸ In-Game Collector', desc: 'Unlock all In-Game achievements', category: 'Creative', points: 1000, requiredPoints: 5000, groupKey: 'collections', progress: () => {
          const allAchievements = getAllAchievementsList();
          const ingameAchs = allAchievements.filter(a => a.category === 'In-Game' && !a.isDaily);
          const unlocked = ingameAchs.filter(a => achievements.includes(a.id)).length;
          return { current: unlocked, target: ingameAchs.length };
        }},
        { id: 'collect_all_random', name: 'ðŸŽ² Random Collector', desc: 'Unlock all Random achievements', category: 'Creative', points: 1000, requiredPoints: 5000, groupKey: 'collections', progress: () => {
          const allAchievements = getAllAchievementsList();
          const randomAchs = allAchievements.filter(a => a.category === 'Random' && !a.isDaily);
          const unlocked = randomAchs.filter(a => achievements.includes(a.id)).length;
          return { current: unlocked, target: randomAchs.length };
        }},
        { id: 'collect_all_creative', name: 'ðŸŽ¨ Creative Collector', desc: 'Unlock all Creative achievements', category: 'Creative', points: 2000, requiredPoints: 20000, groupKey: 'collections', progress: () => {
          const allAchievements = getAllAchievementsList();
          const creativeAchs = allAchievements.filter(a => a.category === 'Creative' && !a.isDaily);
          const unlocked = creativeAchs.filter(a => achievements.includes(a.id)).length;
          return { current: unlocked, target: creativeAchs.length };
        }},
        { id: 'collect_all', name: 'ðŸŒŸ Master Collector', desc: 'Unlock ALL achievements (except daily)', category: 'Creative', points: 10000, requiredPoints: 50000, groupKey: 'collections', progress: () => {
          const allAchievements = getAllAchievementsList();
          const nonDailyAchs = allAchievements.filter(a => !a.isDaily);
          const unlocked = nonDailyAchs.filter(a => achievements.includes(a.id)).length;
          return { current: unlocked, target: nonDailyAchs.length };
        }},
        
        // Progress Achievements (Win Rate Milestones)
        { id: 'winrate_50_20', name: 'ðŸ“ˆ Above Average', desc: 'Achieve 50%+ win rate (20+ games)', category: 'Creative', points: 200, groupKey: 'winrate', progress: () => {
          const total = playerStats.wins + playerStats.losses + playerStats.draws;
          if (total < 20) return { current: 0, target: 1 };
          const winRate = total > 0 ? (playerStats.wins / total) * 100 : 0;
          return { current: winRate >= 50 ? 1 : 0, target: 1 };
        }},
        { id: 'winrate_60_30', name: 'ðŸ“ˆ Strong Player', desc: 'Achieve 60%+ win rate (30+ games)', category: 'Creative', points: 400, groupKey: 'winrate', progress: () => {
          const total = playerStats.wins + playerStats.losses + playerStats.draws;
          if (total < 30) return { current: 0, target: 1 };
          const winRate = total > 0 ? (playerStats.wins / total) * 100 : 0;
          return { current: winRate >= 60 ? 1 : 0, target: 1 };
        }},
        { id: 'winrate_70_50', name: 'ðŸ“ˆ Excellent Player', desc: 'Achieve 70%+ win rate (50+ games)', category: 'Creative', points: 800, requiredPoints: 5000, groupKey: 'winrate', progress: () => {
          const total = playerStats.wins + playerStats.losses + playerStats.draws;
          if (total < 50) return { current: 0, target: 1 };
          const winRate = total > 0 ? (playerStats.wins / total) * 100 : 0;
          return { current: winRate >= 70 ? 1 : 0, target: 1 };
        }},
        { id: 'winrate_80_100', name: 'ðŸ“ˆ Master Level', desc: 'Achieve 80%+ win rate (100+ games)', category: 'Creative', points: 2000, requiredPoints: 15000, groupKey: 'winrate', progress: () => {
          const total = playerStats.wins + playerStats.losses + playerStats.draws;
          if (total < 100) return { current: 0, target: 1 };
          const winRate = total > 0 ? (playerStats.wins / total) * 100 : 0;
          return { current: winRate >= 80 ? 1 : 0, target: 1 };
        }},
        
        // Underpromotion Achievement
        { id: 'underpromote', name: 'ðŸŽ­ Underpromoter', desc: 'Promote to rook, bishop, or knight', category: 'Creative', points: 200, groupKey: 'underpromotions', progress: () => {
          return { current: (lifetimeStats.underpromotions || 0), target: 1 };
        }},
        { id: 'underpromote_5', name: 'ðŸŽ­ Master Underpromoter', desc: 'Underpromote 5 times', category: 'Creative', points: 600, requiredPoints: 3000, groupKey: 'underpromotions', progress: () => {
          return { current: (lifetimeStats.underpromotions || 0), target: 5 };
        }},
        
        // Blindfold Achievements
        { id: 'blindfold_win_1', name: 'ðŸ‘ï¸ First Blindfold Win', desc: 'Beat the engine in blindfold mode once', category: 'Creative', points: 300, groupKey: 'blindfold', progress: () => {
          return { current: (lifetimeStats.blindfoldWins || 0), target: 1 };
        }},
        { id: 'blindfold_win_5', name: 'ðŸ‘ï¸ Blindfold Player', desc: 'Beat the engine in blindfold mode 5 times', category: 'Creative', points: 800, requiredPoints: 2000, groupKey: 'blindfold', progress: () => {
          return { current: (lifetimeStats.blindfoldWins || 0), target: 5 };
        }},
        { id: 'blindfold_win_10', name: 'ðŸ‘ï¸ Blindfold Expert', desc: 'Beat the engine in blindfold mode 10 times', category: 'Creative', points: 1500, requiredPoints: 5000, groupKey: 'blindfold', progress: () => {
          return { current: (lifetimeStats.blindfoldWins || 0), target: 10 };
        }},
        { id: 'blindfold_win_25', name: 'ðŸ‘ï¸ Blindfold Master', desc: 'Beat the engine in blindfold mode 25 times', category: 'Creative', points: 3000, requiredPoints: 15000, groupKey: 'blindfold', progress: () => {
          return { current: (lifetimeStats.blindfoldWins || 0), target: 25 };
        }},
        { id: 'blindfold_win_50', name: 'ðŸ‘ï¸ Blindfold Legend', desc: 'Beat the engine in blindfold mode 50 times', category: 'Creative', points: 6000, requiredPoints: 30000, groupKey: 'blindfold', progress: () => {
          return { current: (lifetimeStats.blindfoldWins || 0), target: 50 };
        }},
        { id: 'blindfold_no_history_1', name: 'ðŸŽ¯ Pure Blindfold Win', desc: 'Beat the engine in blindfold mode without move history once', category: 'Creative', points: 500, requiredPoints: 1000, groupKey: 'blindfold_no_history', progress: () => {
          return { current: (lifetimeStats.blindfoldWinsNoHistory || 0), target: 1 };
        }},
        { id: 'blindfold_no_history_5', name: 'ðŸŽ¯ Pure Blindfold Expert', desc: 'Beat the engine in blindfold mode without move history 5 times', category: 'Creative', points: 1500, requiredPoints: 5000, groupKey: 'blindfold_no_history', progress: () => {
          return { current: (lifetimeStats.blindfoldWinsNoHistory || 0), target: 5 };
        }},
        { id: 'blindfold_no_history_10', name: 'ðŸŽ¯ Pure Blindfold Master', desc: 'Beat the engine in blindfold mode without move history 10 times', category: 'Creative', points: 3000, requiredPoints: 15000, groupKey: 'blindfold_no_history', progress: () => {
          return { current: (lifetimeStats.blindfoldWinsNoHistory || 0), target: 10 };
        }},
        { id: 'blindfold_no_history_25', name: 'ðŸŽ¯ Pure Blindfold Legend', desc: 'Beat the engine in blindfold mode without move history 25 times', category: 'Creative', points: 6000, requiredPoints: 30000, groupKey: 'blindfold_no_history', progress: () => {
          return { current: (lifetimeStats.blindfoldWinsNoHistory || 0), target: 25 };
        }},
        
        // Total Games Milestones
        { id: 'five_hundred_games', name: 'ðŸŽ® Five Hundred Games', desc: 'Play 500 total games', category: 'General', points: 600, groupKey: 'total_games', progress: () => {
          const total = playerStats.wins + playerStats.losses + playerStats.draws;
          return { current: total, target: 500 };
        }},
        { id: 'thousand_games', name: 'ðŸŽ® Thousand Games', desc: 'Play 1000 total games', category: 'General', points: 1500, requiredPoints: 10000, groupKey: 'total_games', progress: () => {
          const total = playerStats.wins + playerStats.losses + playerStats.draws;
          return { current: total, target: 1000 };
        }},
        { id: 'five_thousand_games', name: 'ðŸŽ® Five Thousand Games', desc: 'Play 5000 total games', category: 'General', points: 5000, requiredPoints: 30000, groupKey: 'total_games', progress: () => {
          const total = playerStats.wins + playerStats.losses + playerStats.draws;
          return { current: total, target: 5000 };
        }}
      ];
    }

    function updateTotalPoints() {
      const allAchievements = getAllAchievementsList();
      let totalPoints = 0;
      achievements.forEach(achId => {
        const ach = allAchievements.find(a => a.id === achId);
        if (ach && ach.points) {
          totalPoints += ach.points;
        }
      });
      const pointsEl = document.getElementById('total-achievement-points');
      if (pointsEl) {
        pointsEl.textContent = totalPoints.toLocaleString();
      }
    }

    function updateAchievementsDisplay() {
      const container = document.getElementById("achievements-list");
      container.innerHTML = '';
      
      const allAchievements = getAllAchievementsList();
      const unlocked = allAchievements.filter(ach => achievements.includes(ach.id));
      
      // Show only unlocked achievements in the small panel
      unlocked.slice(0, 6).forEach(ach => {
        const div = document.createElement('div');
        div.className = 'stats-row';
        const pointsText = ach.points ? ` <span style="color: #f39c12; font-weight: 700;">(${ach.points} pts)</span>` : '';
        div.innerHTML = `
          <span class="stats-label">${ach.name}:</span>
          <span class="stats-value" style="font-size: 0.85em;">${ach.desc}${pointsText}</span>
        `;
        container.appendChild(div);
      });
      
      if (unlocked.length === 0) {
        const div = document.createElement('div');
        div.className = 'stats-row';
        div.style.opacity = '0.6';
        div.innerHTML = '<span class="stats-value" style="font-size: 0.9em; font-style: italic;">No achievements unlocked yet</span>';
        container.appendChild(div);
      }
    }

    function showAllAchievements() {
      try {
        const modal = document.getElementById('all-achievements-modal');
        if (!modal) {
          console.error('Achievements modal not found');
          return;
        }
        const container = document.getElementById('all-achievements-list');
        if (!container) {
          console.error('Achievements list container not found');
          return;
        }
        container.innerHTML = '';
        container.style.width = '100%';
        container.style.height = '100%';
        container.style.boxSizing = 'border-box';
        
        const allAchievements = getAllAchievementsList();
        
        // Get today's daily achievements (random selection)
        resetDailyStatsIfNeeded();
        const todayDailyIds = getTodayDailyAchievements();
        const dailyAchievements = allAchievements.filter(ach => todayDailyIds.includes(ach.id));
        const otherAchievements = allAchievements.filter(ach => !todayDailyIds.includes(ach.id));
        
        // Create a master 3-column grid that contains daily achievements at top, then regular achievements
        const masterGrid = document.createElement('div');
        masterGrid.style.display = 'grid';
        masterGrid.style.gridTemplateColumns = 'repeat(3, 1fr)';
        masterGrid.style.width = '100%';
        masterGrid.style.gap = '20px';
        masterGrid.style.marginBottom = '0';
        masterGrid.style.overflowY = 'auto';
        masterGrid.style.paddingRight = '10px';
        masterGrid.style.boxSizing = 'border-box';
        
        // Daily title and achievements section - only if we have daily achievements
        if (dailyAchievements.length > 0) {
          // Daily title section - spans all 3 columns
          const dailyTitleCard = document.createElement('div');
          dailyTitleCard.style.gridColumn = 'span 3';
          dailyTitleCard.style.textAlign = 'center';
          dailyTitleCard.style.marginBottom = '15px';
          dailyTitleCard.style.paddingBottom = '15px';
          dailyTitleCard.style.borderBottom = '3px solid #f39c12';
          
          const dailyTitle = document.createElement('h2');
          dailyTitle.textContent = 'ðŸ“… Daily Challenges';
          dailyTitle.style.cssText = 'font-family: "Inter", sans-serif; font-size: 1.3em; font-weight: 800; color: #e67e22; margin: 0 0 5px 0;';
          dailyTitleCard.appendChild(dailyTitle);
          
          const dailySubtitle = document.createElement('div');
          dailySubtitle.textContent = 'These reset and change every day at midnight!';
          dailySubtitle.style.cssText = 'color: #d35400; font-style: italic; font-size: 0.85em;';
          dailyTitleCard.appendChild(dailySubtitle);
          
          masterGrid.appendChild(dailyTitleCard);
        
          // Add exactly 3 daily achievements as the first row (one per column)
        dailyAchievements.slice(0, 3).forEach(ach => {
          const isUnlocked = achievements.includes(ach.id);
          let progress, progressPercent;
          try {
            progress = ach.progress();
            progressPercent = progress.target > 0 ? Math.min(100, (progress.current / progress.target) * 100) : 0;
          } catch (e) {
            console.error('Error calculating progress for', ach.id, e);
            progress = { current: 0, target: 1 };
            progressPercent = 0;
          }
          
          // Use EXACT same card styling as regular achievements
          const card = document.createElement('div');
          card.className = `achievement-card ${isUnlocked ? 'unlocked' : ''}`;
          
          const allAchievementsForDaily = getAllAchievementsList();
          const totalPoints = allAchievementsForDaily.reduce((sum, a) => {
            if (achievements.includes(a.id) && a.points) {
              return sum + a.points;
            }
            return sum;
          }, 0);
          const requiredPoints = ach.requiredPoints || 0;
          const hasEnoughPoints = totalPoints >= requiredPoints;
          
          // Check if achievement is locked due to game count requirements
          const meetsRequirements = progress.needsTotal !== false;
          const meetsNoLosses = progress.needsNoLosses !== false;
          let lockedMessage = '';
          if (!meetsRequirements) {
            const desc = ach.desc || '';
            const gameMatch = desc.match(/(\d+)\+.*games?/i);
            if (gameMatch) {
              lockedMessage = `ðŸ”’ Locked - Need ${gameMatch[1]}+ games`;
            } else {
              lockedMessage = 'ðŸ”’ Locked - Requirements not met';
            }
          } else if (!meetsNoLosses) {
            lockedMessage = 'ðŸ”’ Locked - Must win without losing pieces';
          }
          
          const pointsText = ach.points ? `<div style="font-size: 0.9em; color: #f39c12; font-weight: 700; margin-top: 5px;">${ach.points} points</div>` : '';
          
          const progressDisplay = 
            lockedMessage ? `<div class="achievement-progress" style="margin-top: 8px; color: #e74c3c;">${lockedMessage}</div>` :
            requiredPoints > 0 && !hasEnoughPoints ? `<div class="achievement-progress" style="margin-top: 8px; color: #e74c3c;">ðŸ”’ Locked - Need ${requiredPoints} points (You have ${totalPoints})</div>` :
            isUnlocked ? `<div class="achievement-progress" style="margin-top: 8px;">${progress.current} / ${progress.target} <span style="color: #2ecc71;">âœ“</span></div>
              <div class="achievement-progress-bar">
                <div class="achievement-progress-fill" style="width: 100%; background: #2ecc71;"></div>
              </div>` :
            `<div class="achievement-progress" style="margin-top: 8px;">${progress.current} / ${progress.target}</div>
              <div class="achievement-progress-bar">
                <div class="achievement-progress-fill" style="width: ${progressPercent}%"></div>
              </div>`;
          
          card.innerHTML = `
            <div class="achievement-name">${ach.name} ${isUnlocked ? '<span style="color: #2ecc71; font-size: 0.9em;">âœ“</span>' : ''}</div>
            <div class="achievement-desc">${ach.desc}</div>
            ${pointsText}
            ${progressDisplay}
          `;
          
            masterGrid.appendChild(card);
          });
        
          // Add divider line - spans all 3 columns
          const divider = document.createElement('div');
          divider.style.gridColumn = 'span 3';
          divider.style.height = '3px';
          divider.style.background = '#e9ecef';
          divider.style.marginTop = '20px';
          divider.style.marginBottom = '20px';
          masterGrid.appendChild(divider);
        }
      
      // First group other achievements by category - these continue in the same 3-column grid
      const byCategory = {};
      otherAchievements.forEach(ach => {
        // Skip Daily category achievements - they're already shown above
        if (ach.category === 'Daily') return;
        if (!byCategory[ach.category]) {
          byCategory[ach.category] = [];
        }
        byCategory[ach.category].push(ach);
      });
      
      // Render by category - each category title spans 3 columns, achievements continue in grid
      Object.keys(byCategory).forEach(category => {
        // Category title spans all 3 columns
        const categoryTitleCard = document.createElement('div');
        categoryTitleCard.style.gridColumn = 'span 3';
        categoryTitleCard.style.marginTop = '20px';
        categoryTitleCard.style.marginBottom = '15px';
        
        const categoryTitle = document.createElement('h3');
        categoryTitle.textContent = category;
        categoryTitle.style.cssText = 'font-family: "Inter", sans-serif; font-size: 1.3em; font-weight: 700; color: #2c3e50; padding-bottom: 8px; border-bottom: 2px solid #3498db;';
        categoryTitleCard.appendChild(categoryTitle);
        
        masterGrid.appendChild(categoryTitleCard);
        
        // Group achievements within category by groupKey
        const grouped = {};
        const ungrouped = [];
        
        byCategory[category].forEach(ach => {
          if (ach.groupKey) {
            if (!grouped[ach.groupKey]) {
              grouped[ach.groupKey] = [];
            }
            grouped[ach.groupKey].push(ach);
          } else {
            ungrouped.push(ach);
          }
        });
        
        // Sort grouped achievements by target value
        Object.keys(grouped).forEach(key => {
          grouped[key].sort((a, b) => {
            try {
              const aTarget = a.progress().target;
              const bTarget = b.progress().target;
              return aTarget - bTarget;
            } catch (e) {
              console.error('Error sorting achievements:', e);
              return 0;
            }
          });
        });
        
        // Render grouped achievements - add them to the master grid
        Object.keys(grouped).forEach(groupKey => {
          const group = grouped[groupKey];
          const groupDiv = document.createElement('div');
          groupDiv.className = 'achievement-group';
          // Don't set width - let grid handle it
          // gridColumn span 1 is the default, so no need to set it
          
          // Find the next achievement to work on
          let nextAchievement = null;
          let nextIndex = -1;
          for (let i = 0; i < group.length; i++) {
            const ach = group[i];
            const isUnlocked = achievements.includes(ach.id);
            if (!isUnlocked) {
              nextAchievement = ach;
              nextIndex = i;
              break;
            }
          }
          
          // If all are unlocked, show the last one
          if (!nextAchievement && group.length > 0) {
            nextAchievement = group[group.length - 1];
            nextIndex = group.length - 1;
          }
          
          // Create the visible card (next achievement)
          if (nextAchievement) {
            const isUnlocked = achievements.includes(nextAchievement.id);
            let progress, progressPercent;
            try {
              progress = nextAchievement.progress();
              progressPercent = progress.target > 0 ? Math.min(100, (progress.current / progress.target) * 100) : 0;
            } catch (e) {
              console.error('Error calculating progress for', nextAchievement.id, e);
              progress = { current: 0, target: 1 };
              progressPercent = 0;
            }
            const showProgress = !isUnlocked && progressPercent < 100;
            // needsTotal should be true or undefined (not false) to meet requirements
            const meetsRequirements = progress.needsTotal !== false;
            // needsNoLosses should be true or undefined (not false) to meet requirements  
            const meetsNoLosses = progress.needsNoLosses !== false;
            
            // Check if achievement requires points to unlock
            const allAchievements = getAllAchievementsList();
            const totalPoints = allAchievements.reduce((sum, ach) => {
              if (achievements.includes(ach.id) && ach.points) {
                return sum + ach.points;
              }
              return sum;
            }, 0);
            const requiredPoints = nextAchievement.requiredPoints || 0;
            const hasEnoughPoints = totalPoints >= requiredPoints;
            
            const card = document.createElement('div');
            card.className = `achievement-card ${isUnlocked ? 'unlocked' : ''}`;
            card.style.position = 'relative';
            
            const pointsText = nextAchievement.points ? `<div style="font-size: 0.9em; color: #f39c12; font-weight: 700; margin-top: 5px;">${nextAchievement.points} points</div>` : '';
            
            // Add expand button if there are more achievements in the group
            const expandButton = group.length > 1 ? `
              <button class="expand-group-btn" onclick="toggleAchievementGroup('${groupKey}')" style="
                position: absolute;
                top: 10px;
                right: 10px;
                background: rgba(52, 152, 219, 0.1);
                border: 2px solid #3498db;
                border-radius: 50%;
                width: 30px;
                height: 30px;
                cursor: pointer;
                font-size: 1.2em;
                color: #3498db;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.3s ease;
                font-weight: 700;
              " onmouseover="this.style.background='rgba(52, 152, 219, 0.2)'" onmouseout="this.style.background='rgba(52, 152, 219, 0.1)'">
                <span id="expand-icon-${groupKey}">â–¼</span>
              </button>
            ` : '';
            
            // Check if achievement is locked due to game count requirements
            let lockedMessage = '';
            if (!meetsRequirements) {
              const desc = nextAchievement.desc || '';
              const gameMatch = desc.match(/(\d+)\+.*games?/i);
              if (gameMatch) {
                lockedMessage = `ðŸ”’ Locked - Need ${gameMatch[1]}+ games`;
              } else {
                lockedMessage = 'ðŸ”’ Locked - Requirements not met';
              }
            } else if (!meetsNoLosses) {
              lockedMessage = 'ðŸ”’ Locked - Must win without losing pieces';
            }
            
            const progressDisplay = 
              lockedMessage ? `<div class="achievement-progress" style="margin-top: 8px; color: #e74c3c;">${lockedMessage}</div>` :
              requiredPoints > 0 && !hasEnoughPoints ? `<div class="achievement-progress" style="margin-top: 8px; color: #e74c3c;">ðŸ”’ Locked - Need ${requiredPoints} points (You have ${totalPoints})</div>` :
              isUnlocked ? `<div class="achievement-progress" style="margin-top: 8px;">${progress.current} / ${progress.target} <span style="color: #2ecc71;">âœ“</span></div>
                <div class="achievement-progress-bar">
                  <div class="achievement-progress-fill" style="width: 100%; background: #2ecc71;"></div>
                </div>` :
              `<div class="achievement-progress" style="margin-top: 8px;">${progress.current} / ${progress.target}</div>
                <div class="achievement-progress-bar">
                  <div class="achievement-progress-fill" style="width: ${progressPercent}%"></div>
                </div>`;
            
            card.innerHTML = `
              ${expandButton}
              <div class="achievement-name">${nextAchievement.name} ${isUnlocked ? '<span style="color: #2ecc71; font-size: 0.9em;">âœ“</span>' : ''}</div>
              <div class="achievement-desc">${nextAchievement.desc}</div>
              ${pointsText}
              ${progressDisplay}
            `;
            
            groupDiv.appendChild(card);
            
            // Create hidden container for all achievements in group
            const allGroupAchievements = document.createElement('div');
            allGroupAchievements.id = `group-${groupKey}`;
            allGroupAchievements.className = 'achievement-group-all';
            allGroupAchievements.style.display = 'none';
            allGroupAchievements.style.marginTop = '10px';
            allGroupAchievements.style.paddingTop = '10px';
            allGroupAchievements.style.borderTop = '2px solid #e9ecef';
            
            group.forEach((ach, idx) => {
              if (idx === nextIndex) return; // Skip the one already shown
              
              const isUnlocked = achievements.includes(ach.id);
              let progress, progressPercent;
              try {
                progress = ach.progress();
                progressPercent = progress.target > 0 ? Math.min(100, (progress.current / progress.target) * 100) : 0;
              } catch (e) {
                console.error('Error calculating progress for', ach.id, e);
                progress = { current: 0, target: 1 };
                progressPercent = 0;
              }
              const showProgress = !isUnlocked && progressPercent < 100;
              // needsTotal should be true or undefined (not false) to meet requirements
              const meetsRequirements = progress.needsTotal !== false;
              // needsNoLosses should be true or undefined (not false) to meet requirements
              const meetsNoLosses = progress.needsNoLosses !== false;
              
              const subCard = document.createElement('div');
              subCard.className = `achievement-card ${isUnlocked ? 'unlocked' : ''}`;
              subCard.style.marginBottom = '10px';
              
              const pointsText = ach.points ? `<div style="font-size: 0.9em; color: #f39c12; font-weight: 700; margin-top: 5px;">${ach.points} points</div>` : '';
              const allAchievements = getAllAchievementsList();
              const totalPoints = allAchievements.reduce((sum, a) => {
                if (achievements.includes(a.id) && a.points) {
                  return sum + a.points;
                }
                return sum;
              }, 0);
              const requiredPoints = ach.requiredPoints || 0;
              const hasEnoughPoints = totalPoints >= requiredPoints;
              
              // Check if achievement is locked due to game count requirements
              let lockedMessage = '';
              if (!meetsRequirements) {
                // Extract game requirement from description or check specific achievements
                const desc = ach.desc || '';
                const gameMatch = desc.match(/(\d+)\+.*games?/i);
                if (gameMatch) {
                  lockedMessage = `ðŸ”’ Locked - Need ${gameMatch[1]}+ games`;
                } else {
                  lockedMessage = 'ðŸ”’ Locked - Requirements not met';
                }
              } else if (!meetsNoLosses) {
                lockedMessage = 'ðŸ”’ Locked - Must win without losing pieces';
              }
              
              const progressDisplay = 
                lockedMessage ? `<div class="achievement-progress" style="margin-top: 8px; color: #e74c3c;">${lockedMessage}</div>` :
                requiredPoints > 0 && !hasEnoughPoints ? `<div class="achievement-progress" style="margin-top: 8px; color: #e74c3c;">ðŸ”’ Locked - Need ${requiredPoints} points (You have ${totalPoints})</div>` :
                isUnlocked ? `<div class="achievement-progress" style="margin-top: 8px;">${progress.current} / ${progress.target} <span style="color: #2ecc71;">âœ“</span></div>
                  <div class="achievement-progress-bar">
                    <div class="achievement-progress-fill" style="width: 100%; background: #2ecc71;"></div>
                  </div>` :
                `<div class="achievement-progress" style="margin-top: 8px;">${progress.current} / ${progress.target}</div>
                  <div class="achievement-progress-bar">
                    <div class="achievement-progress-fill" style="width: ${progressPercent}%"></div>
                  </div>`;
              subCard.innerHTML = `
                <div class="achievement-name">${ach.name} ${isUnlocked ? '<span style="color: #2ecc71; font-size: 0.9em;">âœ“</span>' : ''}</div>
                <div class="achievement-desc">${ach.desc}</div>
                ${pointsText}
                ${progressDisplay}
              `;
              
              allGroupAchievements.appendChild(subCard);
            });
            
            groupDiv.appendChild(allGroupAchievements);
            masterGrid.appendChild(groupDiv); // Add directly to master grid
          }
        });
        
        // Render ungrouped achievements - add directly to master grid
        ungrouped.forEach(ach => {
          const isUnlocked = achievements.includes(ach.id);
          let progress, progressPercent;
          try {
            progress = ach.progress();
            progressPercent = progress.target > 0 ? Math.min(100, (progress.current / progress.target) * 100) : 0;
          } catch (e) {
            console.error('Error calculating progress for', ach.id, e);
            progress = { current: 0, target: 1 };
            progressPercent = 0;
          }
          
          const card = document.createElement('div');
          card.className = `achievement-card ${isUnlocked ? 'unlocked' : ''}`;
          
          const pointsText = ach.points ? `<div style="font-size: 0.9em; color: #f39c12; font-weight: 700; margin-top: 5px;">${ach.points} points</div>` : '';
          const allAchievementsList = getAllAchievementsList();
          const totalPoints = allAchievementsList.reduce((sum, a) => {
            if (achievements.includes(a.id) && a.points) {
              return sum + a.points;
            }
            return sum;
          }, 0);
          const requiredPoints = ach.requiredPoints || 0;
          const hasEnoughPoints = totalPoints >= requiredPoints;
          
          // Check if achievement is locked due to game count requirements
          const meetsRequirements = progress.needsTotal !== false;
          const meetsNoLosses = progress.needsNoLosses !== false;
          let lockedMessage = '';
          if (!meetsRequirements) {
            const desc = ach.desc || '';
            const gameMatch = desc.match(/(\d+)\+.*games?/i);
            if (gameMatch) {
              lockedMessage = `ðŸ”’ Locked - Need ${gameMatch[1]}+ games`;
            } else {
              lockedMessage = 'ðŸ”’ Locked - Requirements not met';
            }
          } else if (!meetsNoLosses) {
            lockedMessage = 'ðŸ”’ Locked - Must win without losing pieces';
          }
          
          const progressDisplay = 
            lockedMessage ? `<div class="achievement-progress" style="margin-top: 8px; color: #e74c3c;">${lockedMessage}</div>` :
            requiredPoints > 0 && !hasEnoughPoints ? `<div class="achievement-progress" style="margin-top: 8px; color: #e74c3c;">ðŸ”’ Locked - Need ${requiredPoints} points (You have ${totalPoints})</div>` :
            isUnlocked ? `<div class="achievement-progress" style="margin-top: 8px;">${progress.current} / ${progress.target} <span style="color: #2ecc71;">âœ“</span></div>
              <div class="achievement-progress-bar">
                <div class="achievement-progress-fill" style="width: 100%; background: #2ecc71;"></div>
              </div>` :
            `<div class="achievement-progress" style="margin-top: 8px;">${progress.current} / ${progress.target}</div>
              <div class="achievement-progress-bar">
                <div class="achievement-progress-fill" style="width: ${progressPercent}%"></div>
              </div>`;
          card.innerHTML = `
            <div class="achievement-name">${ach.name} ${isUnlocked ? '<span style="color: #2ecc71; font-size: 0.9em;">âœ“</span>' : ''}</div>
            <div class="achievement-desc">${ach.desc}</div>
            ${pointsText}
            ${progressDisplay}
          `;
          
          masterGrid.appendChild(card);
        });
      });
      
      // Append the master grid to container
      container.appendChild(masterGrid);
      
      // Add event listener for reset button
      const resetBtn = document.getElementById('reset-achievements-btn');
      if (resetBtn) {
        // Remove any existing listeners
        resetBtn.replaceWith(resetBtn.cloneNode(true));
        const newResetBtn = document.getElementById('reset-achievements-btn');
        newResetBtn.addEventListener('click', function(e) {
          e.preventDefault();
          e.stopPropagation();
          console.log('Reset button clicked');
          resetAllAchievements();
        });
      }
      
      modal.classList.add('show');
      } catch (e) {
        console.error('Error in showAllAchievements:', e);
        alert('Error loading achievements. Please check the console for details.');
      }
    }

    function toggleAchievementGroup(groupKey) {
      const groupDiv = document.getElementById(`group-${groupKey}`);
      const icon = document.getElementById(`expand-icon-${groupKey}`);
      
      if (groupDiv.style.display === 'none') {
        groupDiv.style.display = 'block';
        icon.textContent = 'â–²';
      } else {
        groupDiv.style.display = 'none';
        icon.textContent = 'â–¼';
      }
    }

    function closeAllAchievements() {
      document.getElementById('all-achievements-modal').classList.remove('show');
    }
    
    // Reset confirmation state
    let resetConfirmStage = 0; // 0 = not started, 1 = first warning, 2 = second warning, 3 = code input
    
    // Make reset function globally accessible
    function resetAllAchievements() {
      console.log('resetAllAchievements called');
      resetConfirmStage = 1;
      showResetConfirmModal(1);
    }
    
    function showResetConfirmModal(stage) {
      const modal = document.getElementById('reset-confirm-modal');
      const titleEl = document.getElementById('reset-confirm-title');
      const messageEl = document.getElementById('reset-confirm-message');
      const listContainer = document.getElementById('reset-confirm-list-container');
      const inputEl = document.getElementById('reset-confirm-input');
      const yesBtn = document.getElementById('reset-confirm-yes-btn');
      const noBtn = document.getElementById('reset-confirm-no-btn');
      
      if (!modal || !titleEl || !messageEl) {
        console.error('Reset modal elements not found');
        return;
      }
      
      resetConfirmStage = stage;
      
      if (stage === 1) {
        // First warning
        titleEl.textContent = 'âš ï¸ Warning';
        messageEl.textContent = 'This will reset ALL achievements and points to zero!\n\nThis action cannot be undone.';
        messageEl.style.color = '#555';
        listContainer.innerHTML = '';
        inputEl.style.display = 'none';
        yesBtn.textContent = 'Continue';
        yesBtn.onclick = () => showResetConfirmModal(2);
        noBtn.onclick = closeResetConfirmModal;
      } else if (stage === 2) {
        // Second warning with list
        titleEl.textContent = 'âš ï¸ Are you ABSOLUTELY SURE?';
        messageEl.textContent = 'This will delete:';
        messageEl.style.color = '#555';
        listContainer.innerHTML = '<ul><li>All unlocked achievements</li><li>All achievement points</li><li>All game statistics</li></ul>';
        inputEl.style.display = 'none';
        yesBtn.textContent = 'Continue';
        yesBtn.onclick = () => showResetConfirmModal(3);
        noBtn.onclick = closeResetConfirmModal;
      } else if (stage === 3) {
        // Code input
        titleEl.textContent = 'âš ï¸ Final Confirmation';
        messageEl.textContent = 'Type "RESET" (all caps) to confirm:';
        messageEl.style.color = '#555';
        listContainer.innerHTML = '';
        inputEl.style.display = 'block';
        inputEl.value = '';
        setTimeout(() => inputEl.focus(), 100);
        yesBtn.textContent = 'Confirm Reset';
        yesBtn.onclick = performReset;
        noBtn.onclick = closeResetConfirmModal;
        
        // Allow Enter key to confirm
        const handleKeyPress = function(e) {
          if (e.key === 'Enter') {
            performReset();
          }
        };
        inputEl.onkeypress = handleKeyPress;
      }
      
      modal.classList.add('show');
    }
    
    function closeResetConfirmModal() {
      const modal = document.getElementById('reset-confirm-modal');
      const inputEl = document.getElementById('reset-confirm-input');
      const messageEl = document.getElementById('reset-confirm-message');
      const yesBtn = document.getElementById('reset-confirm-yes-btn');
      const titleEl = document.getElementById('reset-confirm-title');
      const dialog = modal ? modal.querySelector('.reset-confirm-dialog') : null;
      
      if (modal) {
        modal.classList.remove('show');
        resetConfirmStage = 0;
      }
      if (inputEl) {
        inputEl.value = '';
        inputEl.style.display = 'none';
        inputEl.onkeypress = null;
      }
      if (messageEl) {
        messageEl.style.color = '#555';
      }
      if (yesBtn) {
        yesBtn.style.display = 'block';
      }
      if (titleEl) {
        titleEl.style.color = '#e74c3c';
      }
      if (dialog) {
        dialog.style.borderColor = '#e74c3c';
      }
    }
    
    function performReset() {
      const inputEl = document.getElementById('reset-confirm-input');
      const resetCode = inputEl ? inputEl.value.trim().toUpperCase() : '';
      
      if (resetCode !== 'RESET') {
        const messageEl = document.getElementById('reset-confirm-message');
        if (messageEl) {
          messageEl.textContent = 'âŒ Invalid code. Type "RESET" (all caps) to confirm:';
          messageEl.style.color = '#e74c3c';
        }
        if (inputEl) {
          inputEl.value = '';
          inputEl.focus();
        }
        return;
      }
      
      closeResetConfirmModal();
      
      // Reset all achievements and stats
      achievements = [];
      playerStats = { wins: 0, losses: 0, draws: 0 };
      lifetimeStats = {
        capturesByQueen: 0,
        capturesByRook: 0,
        capturesByBishop: 0,
        capturesByKnight: 0,
        capturesByPawn: 0,
        totalCaptures: 0,
        checksGiven: 0,
        castlingMoves: 0,
        promotions: 0,
        enPassants: 0,
        longestGame: 0,
        shortestWin: Infinity,
        capturedQueens: 0,
        capturedRooks: 0,
        capturedBishops: 0,
        capturedKnights: 0,
        capturedPawns: 0,
        movesToE4: 0,
        movesToD4: 0,
        movesToE5: 0,
        movesToD5: 0,
        knightToF3: 0,
        knightToC3: 0,
        knightToF6: 0,
        knightToC6: 0,
        movesOnMove1: 0,
        movesOnMove5: 0,
        movesOnMove10: 0,
        movesOnMove20: 0,
        movesOnMove50: 0,
        pawnToE4: 0,
        pawnToD4: 0,
        queenToD4: 0,
        queenToE4: 0,
        bishopToF4: 0,
        rookToE1: 0,
        kingToE1: 0,
        consecutiveSamePiece: 0,
        castledOnMove10: 0,
        castledOnMove20: 0,
        promotedToQueen: 0,
        promotedToRook: 0,
        promotedToBishop: 0,
        promotedToKnight: 0,
        checkOnMove5: 0,
        captureOnMove10: 0,
        movesToE4Multiple: 0,
        movesToD4Multiple: 0,
        knightToF3Multiple: 0,
        knightToC3Multiple: 0,
        queenToD4Multiple: 0,
        promotedToQueenMultiple: 0,
        rookToA1: 0, rookToH1: 0, rookToA8: 0, rookToH8: 0,
        bishopToC1: 0, bishopToF1: 0, bishopToC8: 0, bishopToF8: 0,
        knightToG1: 0, knightToB1: 0, knightToG8: 0, knightToB8: 0,
        queenToA1: 0, queenToH1: 0, queenToA8: 0, queenToH8: 0,
        kingToG1: 0, kingToC1: 0, kingToG8: 0, kingToC8: 0,
        pawnToA2: 0, pawnToH2: 0, pawnToA7: 0, pawnToH7: 0,
        dailyStats: {
          lastResetDate: null,
          gamesPlayedToday: 0,
          gamesWonToday: 0,
          movesMadeToday: 0,
          capturesToday: 0,
          checksGivenToday: 0,
          uniqueSquaresVisitedToday: [],
          longestGameToday: 0,
          fastestWinToday: Infinity,
          promotionsToday: 0,
          castlingToday: 0,
          todayDailyIds: []
        },
        winsByTimeControl: {
          none: 0,
          '60': 0,
          '180|2': 0,
          '300|0': 0,
          '600|0': 0,
          '900|5': 0,
          '3600|0': 0
        },
        winsByPersonality: {
          balanced: 0,
          aggressive: 0,
          defensive: 0,
          positional: 0,
          material: 0,
          tactical: 0,
          custom: 0
        },
        winsInUnder10Moves: 0,
        winsInUnder20Moves: 0,
        winsInOver100Moves: 0,
        perfectGames: 0,
        comebackWins: 0,
        longestWinStreak: 0,
        currentWinStreak: 0,
        // Engagement tracking
        daysPlayedInARow: 0,
        lastPlayDate: null,
        totalGamesPlayed: 0,
        gamesWithoutLosingPieces: 0,
        winsWithOnlyPawns: 0,
        checkmateWithKnight: 0,
        checkmateWithBishop: 0,
        checkmateWithRook: 0,
        checkmateWithQueen: 0,
        checkmateWithPawn: 0,
        underpromotions: 0,
        gamesAsWhite: 0,
        gamesAsBlack: 0,
        winsAsWhite: 0,
        winsAsBlack: 0,
        blindfoldWins: 0,
        blindfoldWinsNoHistory: 0
      };
      
      // Save everything
      saveAchievements();
      savePlayerStats();
      saveLifetimeStats();
      
      // Update displays
      updateAchievementsDisplay();
      updatePlayerStatsDisplay();
      updateTotalPoints();
      
      // Refresh the achievements modal if it's open
      if (document.getElementById('all-achievements-modal').classList.contains('show')) {
        showAllAchievements();
      }
      
      // Show success message in modal style
      setTimeout(() => {
        const modal = document.getElementById('reset-confirm-modal');
        const titleEl = document.getElementById('reset-confirm-title');
        const messageEl = document.getElementById('reset-confirm-message');
        const listContainer = document.getElementById('reset-confirm-list-container');
        const inputEl = document.getElementById('reset-confirm-input');
        const yesBtn = document.getElementById('reset-confirm-yes-btn');
        const noBtn = document.getElementById('reset-confirm-no-btn');
        
        if (modal && titleEl && messageEl) {
          const dialog = modal.querySelector('.reset-confirm-dialog');
          titleEl.textContent = 'âœ… Success!';
          titleEl.style.color = '#2ecc71';
          messageEl.textContent = 'All achievements and statistics have been reset successfully!';
          messageEl.style.color = '#555';
          listContainer.innerHTML = '';
          inputEl.style.display = 'none';
          yesBtn.style.display = 'none';
          noBtn.textContent = 'Close';
          noBtn.onclick = closeResetConfirmModal;
          if (dialog) {
            dialog.style.borderColor = '#2ecc71';
          }
          modal.classList.add('show');
          
          // Auto-close after 2 seconds
          setTimeout(() => {
            closeResetConfirmModal();
          }, 2000);
        }
      }, 100);
    }
    
    // Make it globally accessible
    window.resetAllAchievements = resetAllAchievements;

    // ========================================================================
    // DAILY CHALLENGES CONFIGURATION
    // ========================================================================
    // This function returns all available daily challenge IDs.
    // To add a new daily challenge:
    // 1. Add the challenge definition in getAllAchievementsList() with isDaily: true
    // 2. Add its ID to the array below
    // 3. The system will automatically include it in validation and make it available
    // ========================================================================
    function getAllDailyChallengeIds() {
      // Keep a hardcoded fallback list, but ALSO derive IDs from the
      // achievement definitions so new daily challenges can't be forgotten here.
      const fallbackIds = [
        // ORIGINAL DAILY CHALLENGES
        'daily_explorer',              // Visit 20 unique squares
        'daily_checker',               // Give 8 checks
        'daily_warrior',               // Make 5 captures
        'daily_lightning',              // Win in under 15 moves
        'daily_capturer',              // Make 10 captures
        'daily_longgame',              // Play 80+ move game
        'daily_promoter',              // Promote 3 pawns
        'daily_castler',               // Castle 2 times
        'daily_comeback',              // Win 3 games
        'daily_blindfold_bishop',      // Make 5 bishop moves in blindfold games
        'daily_personality_master',    // Beat 3 different personalities
        'daily_survivor',              // Make 10 consecutive moves without losing a piece
        'daily_blitz_king',            // Win 2 games with 1-minute time control
        'daily_time_master',           // Win games with 3 different time controls
        'daily_king_safety',           // Castle in 3 different games
        'daily_promotion_royalty',     // Promote a pawn in 2 different games
        'daily_material_advantage',    // Win 2 games with 3+ material advantage
        'daily_openings_expert',       // Play 3 different detected openings
        'daily_checkmate_artist',      // Checkmate with 3 different pieces
        'daily_en_passant_master',     // Perform en passant in 2 different games
        'daily_underpromotion',        // Underpromote a pawn in one game
        'daily_queen_sacrifice',       // Win after sacrificing queen
        'daily_time_pressure',         // Win with less than 10 seconds remaining
        'daily_opening_trap',          // Win in under 20 moves
        'daily_endgame_grinder',       // Win a game that lasted 100+ moves
        'daily_perfect_defense',       // Win without losing any pieces
        'daily_check_storm',           // Give 10 checks in a single game
        'daily_double_castle',         // Castle both sides in same game
        'daily_promotion_variety',     // Promote to 2 different pieces in one game
        'daily_comeback_king',         // Win after being down 5+ material points
        'daily_piece_hunter',          // Capture 5 different piece types in one game
        // UNIQUE AND CREATIVE DAILY CHALLENGES
        'daily_blindfold_knight',      // Make 7 knight moves in pure blindfold (no history)
        'daily_pawn_promotion_chain',  // Promote 3 pawns in a single game
        'daily_queen_tour',           // Move queen to all 4 corner squares in one game
        'daily_rook_ladder',           // Move both rooks to 7th/2nd rank in one game
        'daily_bishop_pair',           // Win keeping both bishops until end
        'daily_pawn_storm',            // Advance 5 pawns to 6th/3rd rank in one game
        'daily_king_walk',             // Move king 10+ squares in one game
        'daily_piece_cycle',          // Move all 6 piece types in one game
        'daily_square_master',         // Visit all 8 squares on e-file in one game
        'daily_blindfold_win_no_history', // Win blindfold without move history
        'daily_piece_sacrifice_chain', // Sacrifice 3 different pieces in one game
        'daily_center_control',        // Occupy all 4 center squares in one game
        'daily_pawn_island',           // Create 3 isolated pawn islands in one game
        'daily_rook_battery'          // Create rook battery in one game
        // ADD NEW DAILY CHALLENGE IDs HERE:
        // 'daily_your_new_challenge',
      ];

      try {
        const all = (typeof getAllAchievementsList === 'function') ? getAllAchievementsList() : [];
        const derivedIds = (Array.isArray(all) ? all : [])
          .filter(a => a && a.isDaily === true && typeof a.id === 'string' && a.id.length > 0)
          .map(a => a.id);

        return Array.from(new Set([...fallbackIds, ...derivedIds]));
      } catch (e) {
        return fallbackIds;
      }
    }
    
    // ========================================================================
    // DAILY CHALLENGES SCHEDULE CONFIGURATION
    // ========================================================================
    // Easy-to-edit configuration: Each array contains 3 daily challenge IDs
    // that will be active on that day. The system cycles through these sets
    // based on the day of year (0-365), so if you have N sets, they will
    // repeat every N days.
    //
    // To add new challenges to the schedule:
    // 1. Add the challenge ID to getAllDailyChallengeIds() above
    // 2. Add the challenge definition in getAllAchievementsList() with isDaily: true
    // 3. Add it to one or more arrays below to include it in the rotation
    // ========================================================================
    const DAILY_CHALLENGES_CONFIG = [
      // Day 0 (and cycles every 10 days)
      ['daily_explorer', 'daily_warrior', 'daily_lightning'],
      // Day 1
      ['daily_capturer', 'daily_checker', 'daily_longgame'],
      // Day 2
      ['daily_promoter', 'daily_castler', 'daily_comeback'],
      // Day 3
      ['daily_blindfold_bishop', 'daily_queen_tour', 'daily_bishop_pair'],
      // Day 4
      ['daily_blindfold_knight', 'daily_pawn_promotion_chain', 'daily_rook_ladder'],
      // Day 5
      ['daily_bishop_pair', 'daily_pawn_storm', 'daily_king_walk'],
      // Day 6
      ['daily_piece_cycle', 'daily_square_master', 'daily_blindfold_win_no_history'],
      // Day 7
      ['daily_piece_sacrifice_chain', 'daily_center_control', 'daily_pawn_island'],
      // Day 8
      ['daily_rook_battery', 'daily_piece_sacrifice_chain', 'daily_center_control'],
      // Day 9
      ['daily_pawn_island', 'daily_square_master', 'daily_piece_cycle'],
      // ADD MORE DAYS HERE (each array should have exactly 3 challenge IDs):
      // ['daily_challenge1', 'daily_challenge2', 'daily_challenge3'],
    ];
    
    // Optional: Override specific dates with custom challenge sets
    // Format: 'YYYY-MM-DD': ['challenge1', 'challenge2', 'challenge3']
    // Example: '2024-12-25': ['daily_comeback', 'daily_lightning', 'daily_warrior']
    const DAILY_CHALLENGES_SPECIFIC_DATES = {
      // Add specific date overrides here, e.g.:
      // '2024-12-25': ['daily_comeback', 'daily_lightning', 'daily_warrior'],
      '2026-01-20': ['daily_king_walk', 'daily_time_pressure', 'daily_double_castle'],
      '2026-01-21': ['daily_queen_tour', 'daily_rook_ladder', 'daily_time_pressure']
    };
    // ========================================================================

    function getTodayDailyAchievements() {
      try {
        if (!lifetimeStats) {
          // If lifetimeStats isn't initialized yet, return empty array
          return [];
        }
        
        resetDailyStatsIfNeeded();
        if (!lifetimeStats.dailyStats) return [];
        
        // Get today's date string (YYYY-MM-DD format) for specific date lookups
        const today = new Date();
        const dateString = today.getFullYear() + '-' + 
                          String(today.getMonth() + 1).padStart(2, '0') + '-' + 
                          String(today.getDate()).padStart(2, '0');
        
        // Check for specific date override first
        let selected;
        if (DAILY_CHALLENGES_SPECIFIC_DATES[dateString]) {
          selected = DAILY_CHALLENGES_SPECIFIC_DATES[dateString];
        } else {
          // Use cycling pattern based on day of year
          const startOfYear = new Date(today.getFullYear(), 0, 1);
          const dayOfYear = Math.floor((today - startOfYear) / (1000 * 60 * 60 * 24));
          
          // Use day of year modulo number of challenge sets to cycle through them
          const challengeSetIndex = dayOfYear % DAILY_CHALLENGES_CONFIG.length;
          selected = DAILY_CHALLENGES_CONFIG[challengeSetIndex];
        }
        
        // Validate that all IDs exist (automatically uses all available daily challenge IDs)
        const validDailyIds = getAllDailyChallengeIds();
        const validatedSelected = selected.filter(id => validDailyIds.includes(id));
        
        // Ensure we have exactly 3 challenges (fallback if config is wrong)
        if (validatedSelected.length !== 3) {
          console.warn('Daily challenges config error: Expected 3 challenges, got', validatedSelected.length, 'for date', dateString);
          return ['daily_explorer', 'daily_warrior', 'daily_lightning']; // Fallback to default
        }
        
        // Always save today's selection (ensures consistency and handles day changes)
        if (lifetimeStats.dailyStats) {
          lifetimeStats.dailyStats.todayDailyIds = validatedSelected;
          saveLifetimeStats();
        }
        
        return validatedSelected;
      } catch (e) {
        console.error('Error in getTodayDailyAchievements:', e);
        return ['daily_explorer', 'daily_warrior', 'daily_lightning']; // Fallback to default
      }
    }

    function resetDailyStatsIfNeeded() {
      const today = new Date().toDateString();
      const todayDate = new Date();
      todayDate.setHours(0, 0, 0, 0);
      
      if (!lifetimeStats.dailyStats || lifetimeStats.dailyStats.lastResetDate !== today) {
        // Track days played in a row
        if (lifetimeStats.lastPlayDate) {
          const lastPlayDate = new Date(lifetimeStats.lastPlayDate);
          lastPlayDate.setHours(0, 0, 0, 0);
          const daysDiff = Math.floor((todayDate - lastPlayDate) / (1000 * 60 * 60 * 24));
          
          if (daysDiff === 1) {
            // Consecutive day
            lifetimeStats.daysPlayedInARow = (lifetimeStats.daysPlayedInARow || 0) + 1;
          } else if (daysDiff > 1) {
            // Streak broken
            lifetimeStats.daysPlayedInARow = 1;
          } else if (daysDiff === 0) {
            // Same day, don't change streak
          } else {
            // First time playing
            lifetimeStats.daysPlayedInARow = 1;
          }
        } else {
          // First time playing
          lifetimeStats.daysPlayedInARow = 1;
        }
        lifetimeStats.lastPlayDate = todayDate.toISOString();
        
        // Clear ALL daily achievements when date changes
        const allDailyIds = getAllDailyChallengeIds();
        allDailyIds.forEach(id => {
          const index = achievements.indexOf(id);
          if (index > -1) {
            achievements.splice(index, 1);
          }
        });
        saveAchievements();
        
        lifetimeStats.dailyStats = {
          lastResetDate: today,
          todayDailyIds: null, // Will be set by getTodayDailyAchievements
          gamesPlayedToday: 0,
          gamesWonToday: 0,
          movesMadeToday: 0,
          capturesToday: 0,
          checksGivenToday: 0,
          uniqueSquaresVisitedToday: [],
          longestGameToday: 0,
          fastestWinToday: Infinity,
          promotionsToday: 0,
          castlingToday: 0,
          checksToday: 0,
          // New daily challenge tracking
          bishopMovesInBlindfoldToday: 0,
          personalitiesWonToday: [],
          longestStreakNoPiecesLostToday: 0,
          winsByTimeControlToday: {},
          gamesCastledToday: 0,
          gamesPromotedToday: 0,
          winsWithMaterialAdvantageToday: 0,
          uniqueOpeningsPlayedToday: [],
          uniqueCheckmatePiecesToday: [],
          gamesWithEnPassantToday: 0,
          underpromotionsToday: 0,
          queenSacrificeWinsToday: 0,
          timePressureWinsToday: 0,
          perfectWinsToday: 0,
          maxChecksInSingleGameToday: 0,
          doubleCastleGamesToday: 0,
          varietyPromotionGamesToday: 0,
          comebackWinsToday: 0,
          pieceHunterGamesToday: 0,
          // New unique daily challenge tracking
          knightMovesInPureBlindfoldToday: 0,
          triplePromotionGamesToday: 0,
          queenTourGamesToday: 0,
          rookLadderGamesToday: 0,
          bishopPairWinsToday: 0,
          knightForkGamesToday: 0,
          pawnStormGamesToday: 0,
          kingWalkGamesToday: 0,
          pieceCycleGamesToday: 0,
          squareMasterGamesToday: 0,
          pureBlindfoldWinsToday: 0,
          sacrificeChainGamesToday: 0,
          centerControlGamesToday: 0,
          pawnIslandGamesToday: 0,
          rookBatteryGamesToday: 0,
          pinMasterGamesToday: 0,
          skewerKingGamesToday: 0,
          discoveredAttackGamesToday: 0,
          windmillGamesToday: 0,
          zwischenzugGamesToday: 0
        };
        saveLifetimeStats();
      } else {
        // Same day - update last play date but don't reset streak
        lifetimeStats.lastPlayDate = todayDate.toISOString();
        saveLifetimeStats();
      }
    }
    
    function loadLifetimeStats() {
      const saved = localStorage.getItem('lifetimeStats');
      if (saved) {
        const loaded = JSON.parse(saved);
        // Merge with default stats to ensure all properties exist
        lifetimeStats = {
          ...lifetimeStats,
          ...loaded
        };
      }
      // Check if daily stats need reset
      resetDailyStatsIfNeeded();
    }

    function saveLifetimeStats() {
      localStorage.setItem('lifetimeStats', JSON.stringify(lifetimeStats));
    }

    function showAchievementNotification(newAchievements) {
      // Legacy function - redirects to sequential version
      showAchievementNotificationsSequentially(newAchievements);
    }
    
    function showAchievementNotificationsSequentially(newAchievements) {
      // Show achievements one at a time after game completion
      newAchievements.forEach((ach, index) => {
        setTimeout(() => {
          const notification = document.createElement('div');
          notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #2ecc71, #27ae60);
            color: white;
            padding: 20px 25px;
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(46, 204, 113, 0.4);
            z-index: 10004;
            font-family: 'Inter', sans-serif;
            font-weight: 600;
            animation: slideInRight 0.5s ease-out;
            max-width: 300px;
          `;
          const pointsText = ach.points ? `<div style="font-size: 0.85em; opacity: 0.9; margin-top: 5px;">+${ach.points} points</div>` : '';
          notification.innerHTML = `
            <div style="font-size: 1.5em; margin-bottom: 8px;">${ach.name}</div>
            <div style="font-size: 0.9em; opacity: 0.95;">${ach.desc}</div>
            ${pointsText}
          `;
          document.body.appendChild(notification);
          
          setTimeout(() => {
            notification.style.animation = 'slideOutRight 0.5s ease-in forwards';
            setTimeout(() => notification.remove(), 500);
          }, 3500); // Show each notification for 3.5 seconds
        }, index * 4000); // 4 second delay between each notification
      });
    }

    function setupTimerDisplayOrder() {
      // Get the parent container
      const container = document.getElementById('timers-container');
      
      // Get the individual time slots
      const whiteSlot = document.getElementById('time-slot-white');
      const blackSlot = document.getElementById('time-slot-black');

      // Determine player and engine colors
      const playerIsWhite = playerColor === 'white';
      const playerSlot = playerIsWhite ? whiteSlot : blackSlot;
      const engineSlot = playerIsWhite ? blackSlot : whiteSlot;

      // Remove existing children
      container.innerHTML = '';

      // Engine time always on top, Player time always on bottom
      container.appendChild(engineSlot);
      container.appendChild(playerSlot);
    }

    async function startGame() {
      gameOver = false;
      
      const side = document.getElementById("color-select").value;
      const timeOption = document.getElementById("time-control").value;
      blindfoldMode = document.getElementById("blindfold-mode").checked;
      showHistoryInBlindfold = document.getElementById("show-history").checked;
      playerColor = side === "random" ? (Math.random() < 0.5 ? "white" : "black") : side;
      
      // Track current game settings for achievements
      currentTimeControl = timeOption;
      
      // Track games as white/black
      if (playerColor === 'white') {
        lifetimeStats.gamesAsWhite = (lifetimeStats.gamesAsWhite || 0) + 1;
      } else {
        lifetimeStats.gamesAsBlack = (lifetimeStats.gamesAsBlack || 0) + 1;
      }
      saveLifetimeStats();
      
      const [base, inc] =
        timeOption === "none" ? [null, null] : timeOption.split("|").map(Number);

      timeLimited = timeOption !== "none";
      increment = inc || 0;
      whiteTime = base ? base * 1000 : 0;
      blackTime = base ? base * 1000 : 0;

      // Show or hide timers based on time control
      const timersContainer = document.getElementById("timers-container");
      if (timeLimited) {
        timersContainer.style.display = "flex";
      } else {
        timersContainer.style.display = "none";
      }

      // Reset game (don't create new, just reset existing)
      if (!game) {
        game = new Chess();
      } else {
        game.reset();
      }
      moveHistory = [];
      currentMoveIndex = -1;
      capturedPieces = { white: [], black: [] };
      lastMoveSquares = { from: null, to: null };
      gameStartTime = new Date();
      resetGameStats();
      premoves = []; // Clear any premoves
      selectedSquare = null; // Clear any selection
      
      // Hide the options panel with fade effect
      const choosePanel = document.getElementById("choose-side");
      choosePanel.style.transition = "opacity 0.3s ease, transform 0.3s ease";
      choosePanel.style.opacity = "0";
      choosePanel.style.transform = "scale(0.95)";
      setTimeout(() => {
        choosePanel.style.display = "none";
      }, 300);
      
      document.getElementById("move-timer-container").innerHTML = 'Time for this move: <span id="timer">00:00.00</span>';

      updateLastMove(null, "00:00.00", 0, 0);
      updateTurnDisplay();

      // Destroy preview board and create game board
      if (board) {
        board.destroy();
      }
      
      board = Chessboard("board", {
        draggable: true,
        position: "start",
        orientation: playerColor,
        snapSpeed: 50,
        snapbackSpeed: 50,
        appearSpeed: 0,
        moveSpeed: 100,
        trashSpeed: 50,
        dragThrottleRate: 0,
        sparePieces: false,
        dropOffBoard: 'snapback',
        onDragStart: (source, piece, position, orientation) => {
          console.log('onDragStart called for:', source, 'selectedSquare before:', selectedSquare);
          
          // Store the drag start square and time for click detection
          window.dragStartSquare = source;
          window.dragStartTime = Date.now();
          
          // Clear any previous highlights when starting to drag a new piece
          $("#board .square-55d63").removeClass("highlight-legal");
          
          // Don't allow dragging if game is over
          if (game.game_over() || gameOver) {
            return false;
          }
          
          const turn = game.turn();
          const isPlayerTurn = (playerColor === "white" && turn === "w") || (playerColor === "black" && turn === "b");
          
          // Allow dragging opponent's pieces for premove, or own pieces on player's turn
          if (!isPlayerTurn) {
            // This is a premove - allow dragging player's pieces only
            if ((playerColor === "white" && piece.search(/^w/) === -1) || 
                (playerColor === "black" && piece.search(/^b/) === -1)) {
              return false; // Can't premove opponent's pieces
            }
            return true; // Allow premove
          }
          
          // Don't allow dragging opponent's pieces on player's turn
          if ((turn === 'w' && piece.search(/^b/) !== -1) || (turn === 'b' && piece.search(/^w/) !== -1)) {
            return false;
          }
          
          // Highlight legal moves when starting to drag
          highlightLegalMoves(source);
        },
        onDragMove: (newLocation, oldLocation, source, piece, position, orientation) => {
          // Remove previous legal-target class
          $("#board .square-55d63").removeClass("legal-target");
          
          // Only add yellow border if hovering over a legal move square
          const moves = game.moves({ square: source, verbose: true });
          const isLegal = moves.some(move => move.to === newLocation);
          
          if (isLegal) {
            $(`#board .square-${newLocation}`).addClass("legal-target");
          }
        },
        onMouseoutSquare: (square, piece) => {
          // Only remove legal-target class (yellow hover border during drag)
          $("#board .square-55d63").removeClass("legal-target");
          // Don't remove legal move dots - they stay until piece is deselected or moved
        },
        onDrop: (source, target) => {
          console.log('onDrop called:', source, '->', target);
          
          // Detect click-to-move: if dropped on same square, it's a click
          if (source === target) {
            console.log('Click detected (drop on same square):', source);
            handleSquareClick(source);
            return 'snapback'; // Return piece to original position
          }
          
          const turn = game.turn();
          const isPlayerTurn = (playerColor === "white" && turn === "w") || (playerColor === "black" && turn === "b");
          
          // Handle premove (during opponent's turn)
          if (!isPlayerTurn) {
            // Verify there's a piece at the source that belongs to the player
            const sourcePiece = game.get(source);
            if (!sourcePiece || sourcePiece.color !== (playerColor === 'white' ? 'w' : 'b')) {
              return 'snapback';
            }
            
            // Validate premove is theoretically legal for this piece type
            if (!isPremoveLegal(source, target, sourcePiece)) {
              console.log('Premove not valid for piece type:', sourcePiece.type, source, '->', target);
              return 'snapback';
            }
            
            // Add new premove to the array (chain of premoves)
            const newPremove = { from: source, to: target };
            premoves.push(newPremove);
            premoveJustSet = true;
            console.log('Premove added via drag:', newPremove, 'Total premoves:', premoves.length);
            
            // Update visual to show all premoves in the chain
            updatePremoveVisual();
            
            // Don't snapback - keep the piece moved
            return;
          }
          
          // Clear premove if player makes a manual move
          clearPremove();
          
          // Validate move synchronously first
          if (gameOver) {
            return 'snapback';
          }
          
          // Check if move is legal
          const move = game.move({ from: source, to: target, promotion: 'q' });
          if (!move) {
            return 'snapback';
          }
          
          // Move is legal - undo it and let handleMove process it properly
          game.undo();
          handleMove(source, target);
        },
        onSnapEnd: () => {
          // Clean up after drag/drop (clicks are handled in onDrop)
          $("#board .square-55d63").removeClass("legal-target");
          
          // Only remove highlights if not in click-to-move mode
          if (!selectedSquare) {
            removeHighlights();
          }
        },
        onClick: (square) => {
          const turn = game.turn();
          const isPlayerTurn = (playerColor === "white" && turn === "w") || (playerColor === "black" && turn === "b");
          const position = board.position();
          const piece = position[square];
          
          // If there's a selected piece
          if (selectedSquare) {
            // If clicking the same square, deselect
            if (selectedSquare === square) {
              selectedSquare = null;
              removeHighlights();
              return;
            }
            
            // Check if this is a legal move or premove
            if (!isPlayerTurn) {
              // Handle premove click
              if (!piece || (playerColor === "white" && piece.search(/^w/) !== -1) || 
                  (playerColor === "black" && piece.search(/^b/) !== -1)) {
                // Clicking empty square or own piece - try to premove
                const premoveFrom = selectedSquare;
                const premoveTo = square;
                
                // Clear highlights and selection
                selectedSquare = null;
                removeHighlights();
                
                // If clicking own piece, select it instead
                if (piece) {
                  selectedSquare = square;
                  highlightLegalMoves(square);
                } else {
                  // Add new premove to the array (chain of premoves)
                  const newPremove = { from: premoveFrom, to: premoveTo };
                  premoves.push(newPremove);
                  premoveJustSet = true;
                  console.log('Premove added via onClick:', newPremove, 'Total premoves:', premoves.length);
                  
                  // Update visual to show all premoves in the chain
                  updatePremoveVisual();
                }
                return;
              }
            } else {
              // Try to make a normal move
              const move = game.move({ from: selectedSquare, to: square, promotion: 'q' });
              
              if (move) {
                // Legal move
                clearPremove();
                selectedSquare = null;
                removeHighlights();
                game.undo();
                handleMove(move.from, move.to);
                return;
              } else if (piece) {
                // Illegal move but clicked on own piece - change selection
                const pieceColor = piece.search(/^w/) !== -1 ? 'w' : 'b';
                if ((turn === 'w' && pieceColor === 'w') || (turn === 'b' && pieceColor === 'b')) {
                  selectedSquare = square;
                  removeHighlights();
                  highlightLegalMoves(square);
                  return;
                }
              }
              
              // Invalid move, deselect
              selectedSquare = null;
              removeHighlights();
              return;
            }
          }
          
          // No piece selected - select clicked piece if valid
          if (piece) {
            if (!isPlayerTurn) {
              // During opponent's turn, allow selecting own pieces for premove
              if ((playerColor === "white" && piece.search(/^w/) !== -1) || 
                  (playerColor === "black" && piece.search(/^b/) !== -1)) {
                selectedSquare = square;
                highlightLegalMoves(square);
              }
            } else {
              // During player's turn, select own pieces
              const pieceColor = piece.search(/^w/) !== -1 ? 'w' : 'b';
              if ((turn === 'w' && pieceColor === 'w') || (turn === 'b' && pieceColor === 'b')) {
                selectedSquare = square;
                highlightLegalMoves(square);
              }
            }
          } else {
            // Clicked on empty square with no piece selected
            // Cancel all premoves if it's the opponent's turn (when premoves can be set)
            if (!isPlayerTurn && premoves.length > 0) {
              console.log('Empty square clicked during opponent turn, canceling all premoves');
              clearPremove();
            }
          }
        },
        pieceTheme: pieceThemes[currentPieceStyle],
      });

      // Add click-to-move functionality using mousedown/mouseup to avoid drag interference
      setTimeout(() => {
        let mouseDownSquare = null;
        
        $('#board').off('mousedown mouseup').on('mousedown', function(e) {
          // Only handle left click
          if (e.button !== 0) return;
          
          let $square = $(e.target);
          
          // If clicked on a piece image, get the parent square
          if ($square.hasClass('piece-417db') || $square.prop('tagName') === 'IMG') {
            $square = $square.parent();
          }
          
          // Make sure we have a square element
          if (!$square.hasClass('square-55d63')) {
            $square = $square.closest('.square-55d63');
          }
          
          if ($square.length === 0) return;
          
          const square = $square.data('square');
          if (square) {
            mouseDownSquare = square;
          }
        }).on('mouseup', function(e) {
          // Only handle left click
          if (e.button !== 0) return;
          
          if (!mouseDownSquare) return;
          
          let $square = $(e.target);
          
          // If released on a piece image, get the parent square
          if ($square.hasClass('piece-417db') || $square.prop('tagName') === 'IMG') {
            $square = $square.parent();
          }
          
          // Make sure we have a square element
          if (!$square.hasClass('square-55d63')) {
            $square = $square.closest('.square-55d63');
          }
          
          if ($square.length === 0) {
            mouseDownSquare = null;
            return;
          }
          
          const square = $square.data('square');
          
          // Only treat as click if mousedown and mouseup on same square
          if (square && square === mouseDownSquare) {
            console.log('Click detected on square:', square);
            handleSquareClick(square);
          }
          
          mouseDownSquare = null;
        });
      }, 100);

      // Cancel premoves on mousedown/touchstart outside of pieces/board
      let premoveJustSet = false;
      $(document).on('mousedown touchstart', function(e) {
        // Don't cancel if we just set a premove in the same event cycle
        if (premoves.length > 0 && !premoveJustSet) {
          // Check if the click is on the board or a piece
          const $target = $(e.target);
          const isOnBoard = $target.closest('#board').length > 0;
          const isOnPiece = $target.hasClass('piece-417db') || $target.hasClass('square-55d63') || $target.closest('.square-55d63').length > 0;
          
          // Only cancel if clicking outside the board/pieces
          if (!isOnBoard && !isOnPiece) {
            console.log('Click detected outside board/pieces, canceling all premoves');
          clearPremove();
          }
        }
        premoveJustSet = false;
      });

      // Prevent native HTML5 drag on piece images
      setTimeout(() => {
        $('#board img').on('dragstart', function(e) {
          e.preventDefault();
          return false;
        });
        // Also set draggable attribute to false
        $('#board img').attr('draggable', 'false');
        
        // Use MutationObserver to handle dynamically added images
        const observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            mutation.addedNodes.forEach(function(node) {
              if (node.tagName === 'IMG') {
                $(node).attr('draggable', 'false');
                $(node).on('dragstart', function(e) {
                  e.preventDefault();
                  return false;
                });
              }
              if (node.querySelectorAll) {
                $(node).find('img').attr('draggable', 'false');
                $(node).find('img').on('dragstart', function(e) {
                  e.preventDefault();
                  return false;
                });
              }
            });
          });
        });
        
        observer.observe(document.getElementById('board'), {
          childList: true,
          subtree: true
        });
      }, 200);
      
      // Add event delegation for dynamically added images
      $('#board').on('dragstart', 'img', function(e) {
        e.preventDefault();
        return false;
      });

      document.getElementById("move-timer-container").style.display = "block";
      document.getElementById("last-move-container").style.display = "block";
      document.getElementById("notation-container").style.display = "block";
      document.getElementById("notation-container").textContent = "";
      document.getElementById("game-stats-panel").style.display = "block";
      document.getElementById("export-pgn-btn").style.display = "block";
      document.getElementById("resign-btn").style.display = "block";
      document.getElementById("flip-board-btn").style.display = "block";
      document.getElementById("player-stats-panel").style.display = "block";
      document.getElementById("achievements-panel").style.display = "block";
      document.getElementById("opening-display").style.display = "none";
      
      // Load sound settings
      soundEnabled = document.getElementById("sound-effects").checked;
      
      // Load and display statistics
      loadPlayerStats();
      loadAchievements();
      loadLifetimeStats();
      updatePlayerStatsDisplay();
      updateAchievementsDisplay();
      updateTotalPoints();
      
      // Initialize stats
      updateGameStats();
      
      // Handle blindfold mode
      if (blindfoldMode) {
        document.getElementById("board").classList.add("blindfold-hidden");
        document.getElementById("timers-container").classList.add("blindfold-hidden");
        document.getElementById("move-input-container").style.display = "block";
        
        // Handle move history visibility in blindfold mode
        if (showHistoryInBlindfold) {
          document.getElementById("notation-container").classList.remove("blindfold-hidden");
        } else {
          document.getElementById("notation-container").classList.add("blindfold-hidden");
        }
      } else {
        document.getElementById("board").classList.remove("blindfold-hidden");
        document.getElementById("timers-container").classList.remove("blindfold-hidden");
        document.getElementById("notation-container").classList.remove("blindfold-hidden");
        document.getElementById("move-input-container").style.display = "none";
      }
      
      startTimer();
      
      // Initialize engine and apply modifiers before allowing moves
      await sendEngineCommand("start");
      await applyEngineModifiers(currentEngineStyle);
      
      if (playerColor === "black") {
        engineMove();
      }
    }

    // Check for insufficient material (draw condition)
    function isInsufficientMaterial() {
      const board = game.board();
      const pieces = [];
      
      // Count all pieces on the board
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          if (board[i][j]) {
            pieces.push(board[i][j]);
          }
        }
      }
      
      // Only kings = insufficient material
      if (pieces.length === 2) {
        return true;
      }
      
      // King + one minor piece (bishop or knight) = insufficient material
      if (pieces.length === 3) {
        const minors = pieces.filter(p => p.type === 'b' || p.type === 'n');
        if (minors.length === 1) {
          return true;
        }
      }
      
      // King + bishop vs King + bishop (same color bishops) = insufficient material
      if (pieces.length === 4) {
        const bishops = pieces.filter(p => p.type === 'b');
        if (bishops.length === 2) {
          // Check if bishops are on same color squares
          const bishopSquares = [];
          for (let i = 0; i < 8; i++) {
            for (let j = 0; j < 8; j++) {
              if (board[i][j] && board[i][j].type === 'b') {
                const square = String.fromCharCode(97 + j) + (8 - i);
                const isLight = (square.charCodeAt(0) - 97 + parseInt(square[1])) % 2 === 0;
                bishopSquares.push(isLight);
              }
            }
          }
          if (bishopSquares.length === 2 && bishopSquares[0] === bishopSquares[1]) {
            return true;
          }
        }
      }
      
      return false;
    }
    
    // Check for draw conditions and handle them
    function checkDrawConditions() {
      if (gameOver) return false;
      
      let drawReason = null;
      
      // Check for threefold repetition
      if (game.in_threefold_repetition()) {
        drawReason = "Draw by Threefold Repetition";
      }
      // Check for insufficient material
      else if (isInsufficientMaterial()) {
        drawReason = "Draw by Insufficient Material";
      }
      // Check for stalemate
      else if (game.in_stalemate()) {
        drawReason = "Draw by Stalemate";
      }
      // Check for 50-move rule (chess.js handles this as in_draw)
      else if (game.in_draw() && !game.in_checkmate() && !game.in_stalemate() && !game.in_threefold_repetition()) {
        drawReason = "Draw by 50-Move Rule";
      }
      
      if (drawReason) {
        const moveContainer = document.getElementById("move-timer-container");
        moveContainer.innerHTML = `<span style="color:#f39c12;">${drawReason}</span>`;
        playSound('move');
        gameOver = true;
        clearPremove();
        
        // Celebrate draw with animation
        celebrateDraw(drawReason);
        
        // Update statistics
        playerStats.draws++;
        savePlayerStats();
        updatePlayerStatsDisplay();
        resetDailyStatsIfNeeded();
        lifetimeStats.dailyStats.gamesPlayedToday++;
        const moveCount = game.history().length;
        if (moveCount > lifetimeStats.dailyStats.longestGameToday) {
          lifetimeStats.dailyStats.longestGameToday = moveCount;
        }
        commitGameStatsToLifetime();
        checkAndUnlockAchievements();
        
        // Show rematch modal
        setTimeout(() => showRematchModal("ðŸ¤ Draw", `${drawReason}. Play again?`), 2000);
        return true;
      }
      
      return false;
    }

    async function handleMove(source, target) {
      console.log('handleMove called:', source, 'to', target);
      
      removeHighlights();
      const move = game.move({ from: source, to: target, promotion: "q" });
      if (!move) {
        console.log('Move was invalid in handleMove (should not happen)');
        return;
      }

      // Play sound effects
      if (move.captured) {
        playSound('capture');
      } else {
        playSound('move');
      }

      trackCapturedPiece(move);
      trackRandomAchievements(move, source, target);
      // Don't check achievements during moves - only after game completion
      lastMoveSquares = { from: source, to: target };
      
      const prevTurn = game.turn() === "w" ? "b" : "w";
      const moveTimeMs = stopTimerAndUpdateTotal(prevTurn);
      updateLastMove(move.san, formatTime(moveTimeMs), game.turn() === "w" ? "black" : "white", game.history().length/2 + 0.5);
      board.position(game.fen());
      highlightLastMove(source, target);
      highlightCheck();
      updateTurnDisplay();
      updateOpeningDisplay();
      updateGameStats();

      // Check for draw conditions
      if (checkDrawConditions()) {
        return; // Draw handling is done in checkDrawConditions
      }

      if (game.in_checkmate()) {
        // Replaced alert() with UI message
        const moveContainer = document.getElementById("move-timer-container");
        moveContainer.innerHTML = 'CHECKMATE! <span style="color:#2ECC71;">You Win!</span>'; // Green text for win
        playSound('checkmate');
        celebrateCheckmate(true);
        gameOver = true;
        
        // Update statistics and achievements
        playerStats.wins++;
        savePlayerStats();
        updatePlayerStatsDisplay();
        resetDailyStatsIfNeeded();
        lifetimeStats.dailyStats.gamesPlayedToday++;
        lifetimeStats.dailyStats.gamesWonToday++;
        const moveCount = game.history().length;
        if (moveCount < lifetimeStats.dailyStats.fastestWinToday) {
          lifetimeStats.dailyStats.fastestWinToday = moveCount;
        }
        if (moveCount > lifetimeStats.dailyStats.longestGameToday) {
          lifetimeStats.dailyStats.longestGameToday = moveCount;
        }
        // Get checkmate piece from last move (the move that caused checkmate)
        let checkmatePiece = null;
        try {
          const history = game.history({ verbose: true });
          if (history.length > 0) {
            const lastMove = history[history.length - 1];
            // The piece that delivered checkmate is the piece that moved
            checkmatePiece = lastMove ? lastMove.piece : null;
          }
        } catch (e) {
          console.error('Error getting checkmate piece:', e);
        }
        
        // Track time pressure wins (less than 10 seconds remaining)
        try {
          const timeEl = document.getElementById(playerColor === 'white' ? 'white-time' : 'black-time');
          if (timeEl) {
            const timeText = timeEl.textContent.trim();
            // Parse time format (MM:SS or SS.SS)
            const timeMatch = timeText.match(/(\d+):(\d+)/);
            if (timeMatch) {
              const minutes = parseInt(timeMatch[1]);
              const seconds = parseInt(timeMatch[2]);
              const totalSeconds = minutes * 60 + seconds;
              if (totalSeconds < 10 && lifetimeStats.dailyStats) {
                lifetimeStats.dailyStats.timePressureWinsToday = (lifetimeStats.dailyStats.timePressureWinsToday || 0) + 1;
              }
            } else {
              // Try SS.SS format
              const secondsMatch = timeText.match(/(\d+)\.(\d+)/);
              if (secondsMatch) {
                const totalSeconds = parseFloat(timeText);
                if (totalSeconds < 10 && lifetimeStats.dailyStats) {
                  lifetimeStats.dailyStats.timePressureWinsToday = (lifetimeStats.dailyStats.timePressureWinsToday || 0) + 1;
                }
              }
            }
          }
        } catch (e) {
          console.error('Error tracking time pressure:', e);
        }
        
        trackWinStats(moveCount, checkmatePiece);
        commitGameStatsToLifetime();
        checkAndUnlockAchievements();
        
        // Show rematch modal
        setTimeout(() => showRematchModal("ðŸŽ‰ Victory!", "Congratulations! You won! Play again?"), 2000);
        return;
      }

      startTimer(); // Start move timer for engine
      await engineMove();
    }
    async function engineMove() {
      console.log('=== engineMove START ===');
      console.log('Game over status:', gameOver);
      console.log('Current position:', game.fen());
      try {
        const lastMove = game.history().slice(-1)[0];
        console.log('Last move:', lastMove, 'Game turn:', game.turn());
        console.log('Sending request to engine...');
        const response = await fetch("https://hedgehoglover23.pythonanywhere.com/move", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            move: lastMove,
            color: game.turn() === "w" ? "black" : "white",
          }),
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        console.log('Engine response:', data);
        if (!data.move) {
          console.log('ERROR: No move returned from engine');
          // Replaced alert() with UI message
          const moveContainer = document.getElementById("move-timer-container");
          moveContainer.innerHTML = 'ENGINE ERROR: <span style="color:red;">No move returned.</span>';
          return;
        }

        console.log('Engine move:', data.move);
        // Stop timer *before* making the move on the game object
        const moveTimeMs = stopTimerAndUpdateTotal(game.turn()); 
        const move = game.move(data.move);
        
        if (!move) {
          console.error('ERROR: Invalid move returned from engine:', data.move);
          const moveContainer = document.getElementById("move-timer-container");
          moveContainer.innerHTML = 'ENGINE ERROR: <span style="color:red;">Invalid move returned.</span>';
          return;
        }
        
        console.log('Move applied to game. New position:', game.fen());
        console.log('Is checkmate?', game.in_checkmate());
        console.log('Is check?', game.in_check());
        console.log('Is game over?', game.game_over());
        
        trackCapturedPiece(move);
        lastMoveSquares = { from: move.from, to: move.to };
        
        updateLastMove(data.move, formatTime(moveTimeMs), game.turn() === "w" ? "black" : "white", game.history().length/2 + 0.5);
        
        // Show opponent's move first
        board.position(game.fen());
        
        highlightLastMove(move.from, move.to);
        highlightCheck();
        updateTurnDisplay();
        updateOpeningDisplay();
        updateGameStats();
        
        // Re-apply premove highlights if there are any (shouldn't be, but just in case)
        if (premoves.length > 0) {
          updatePremoveVisual();
        }

        // Play sound for engine move
        if (move.captured) {
          playSound('capture');
        } else {
          playSound('move');
        }
        if (game.in_check()) {
          playSound('check');
        }

        // Check for draw conditions
        if (checkDrawConditions()) {
          return; // Draw handling is done in checkDrawConditions
        }

        if (game.in_checkmate()) {
          console.log('CHECKMATE DETECTED - Player Lost');
          // Replaced alert() with UI message
          const moveContainer = document.getElementById("move-timer-container");
          moveContainer.innerHTML = 'CHECKMATE! <span style="color:red;">You Lose!</span>';
          playSound('checkmate');
          console.log('About to call celebrateCheckmate(false)');
          try {
            celebrateCheckmate(false);
            console.log('celebrateCheckmate call completed');
          } catch (err) {
            console.error('Error in celebrateCheckmate:', err);
          }
          gameOver = true;
          clearPremove();
          
          // Update statistics and achievements
          playerStats.losses++;
          savePlayerStats();
          updatePlayerStatsDisplay();
          resetDailyStatsIfNeeded();
          lifetimeStats.dailyStats.gamesPlayedToday++;
          const moveCount = game.history().length;
          if (moveCount > lifetimeStats.dailyStats.longestGameToday) {
            lifetimeStats.dailyStats.longestGameToday = moveCount;
          }
          commitGameStatsToLifetime();
          checkAndUnlockAchievements();
          
          // Show rematch modal
          setTimeout(() => showRematchModal("ðŸ’” Defeat", "You were checkmated! Play again?"), 2000);
          return;
        }
        
        // Check if there are premoves and execute the first one if legal
        console.log('Checking for premoves...', premoves);
        if (premoves.length > 0) {
          const firstPremove = premoves[0];
          console.log('Attempting to execute first premove:', firstPremove);
          
          const premoveAttempt = game.move({ from: firstPremove.from, to: firstPremove.to, promotion: 'q' });
          console.log('Premove attempt result:', premoveAttempt);
          
          if (premoveAttempt) {
            // Premove is legal - it's been executed, remove it from the array
            console.log('Premove was legal and executed!');
            premoves.shift(); // Remove the executed premove
            
            const from = premoveAttempt.from;
            const to = premoveAttempt.to;
            
            trackCapturedPiece(premoveAttempt);
            lastMoveSquares = { from, to };
            
            const premoveMoveTimeMs = 0; // Instant premove
            updateLastMove(premoveAttempt.san, "00:00.00", game.turn() === "w" ? "black" : "white", game.history().length/2 + 0.5);
            board.position(game.fen());
            
            // Remove red highlights for this executed premove
            $("#board .square-55d63").removeClass("premove-highlight premove-source");
            
            // Update visual to show remaining premoves if any
            if (premoves.length > 0) {
              updatePremoveVisual();
            }
            
            // Highlight with normal last-move highlight (not red premove highlight)
            highlightLastMove(from, to);
            highlightCheck();
            updateTurnDisplay();
            updateOpeningDisplay();
            updateGameStats();
            
            // Check for draw conditions after premove
            if (checkDrawConditions()) {
              return; // Draw handling is done in checkDrawConditions
            }
            
            if (game.in_checkmate()) {
              const moveContainer = document.getElementById("move-timer-container");
              moveContainer.innerHTML = 'CHECKMATE! <span style="color:#2ECC71;">You Win!</span>';
              playSound('checkmate');
              celebrateCheckmate(true);
              gameOver = true;
              clearPremove();
              
              // Update statistics and achievements
              playerStats.wins++;
              savePlayerStats();
              updatePlayerStatsDisplay();
              resetDailyStatsIfNeeded();
              lifetimeStats.dailyStats.gamesPlayedToday++;
              const moveCount = game.history().length;
              if (moveCount < lifetimeStats.dailyStats.fastestWinToday) {
                lifetimeStats.dailyStats.fastestWinToday = moveCount;
              }
              if (moveCount > lifetimeStats.dailyStats.longestGameToday) {
                lifetimeStats.dailyStats.longestGameToday = moveCount;
              }
              // Get checkmate piece from the premove that was just executed
              let checkmatePiece = premoveAttempt ? premoveAttempt.piece : null;
              trackWinStats(moveCount, checkmatePiece);
              commitGameStatsToLifetime();
              checkAndUnlockAchievements();
              
              // Show rematch modal
              setTimeout(() => showRematchModal("ðŸŽ‰ Victory!", "Congratulations! You won! Play again?"), 2000);
              return;
            }
            
            // After executing premove, get engine response
            // The next premove in the chain will be executed after the engine moves
            console.log('Premove executed, now getting engine response...', premoves.length, 'premoves remaining');
            startTimer();
            await engineMove();
            return;
          } else {
            // First premove is no longer legal - clear all premoves and restore board position
            console.log('First premove was not legal, clearing all premoves');
            clearPremove();
          }
        }

        startTimer(); // Start move timer for player
      } catch (err) {
        // Replaced alert() with UI message
        const moveContainer = document.getElementById("move-timer-container");
        moveContainer.innerHTML = `CONNECTION ERROR: <span style="color:red;">${err.message || 'Could not reach engine.'}</span>`;
        console.error('Engine connection error:', err);
        gameOver = true;
        
        // Show rematch modal for connection errors
        setTimeout(() => showRematchModal("âš ï¸ Connection Error", "Lost connection to engine. Try again?"), 2000);
      }
    }
    function submitMove() {
      if (gameOver) return;
      
      const moveInput = document.getElementById("move-input");
      const moveStr = moveInput.value.trim();
      
      if (!moveStr) {
        moveInput.style.borderColor = "red";
        setTimeout(() => { moveInput.style.borderColor = "#3498db"; }, 500);
        return;
      }
      
      removeHighlights();
      const move = game.move(moveStr, { sloppy: true });
      
      if (!move) {
        moveInput.style.borderColor = "red";
        setTimeout(() => { moveInput.style.borderColor = "#3498db"; }, 500);
        return;
      }
      
      moveInput.value = "";
      moveInput.style.borderColor = "#3498db";
      
      trackCapturedPiece(move);
      lastMoveSquares = { from: move.from, to: move.to };
      
      const prevTurn = game.turn() === "w" ? "b" : "w";
      const moveTimeMs = stopTimerAndUpdateTotal(prevTurn);
      updateLastMove(move.san, formatTime(moveTimeMs), game.turn() === "w" ? "black" : "white", game.history().length/2 + 0.5);
      
      if (!blindfoldMode) {
        board.position(game.fen());
        highlightLastMove(move.from, move.to);
        highlightCheck();
      }
      
      updateTurnDisplay();
      updateOpeningDisplay();
      updateGameStats();

      if (game.in_checkmate()) {
        const moveContainer = document.getElementById("move-timer-container");
        moveContainer.innerHTML = 'CHECKMATE! <span style="color:#2ECC71;">You Win!</span>';
        playSound('checkmate');
        celebrateCheckmate(true);
        gameOver = true;
        
        // Update statistics and achievements
        playerStats.wins++;
        savePlayerStats();
        updatePlayerStatsDisplay();
        resetDailyStatsIfNeeded();
        lifetimeStats.dailyStats.gamesPlayedToday++;
        lifetimeStats.dailyStats.gamesWonToday++;
        const moveCount = game.history().length;
        if (moveCount < lifetimeStats.dailyStats.fastestWinToday) {
          lifetimeStats.dailyStats.fastestWinToday = moveCount;
        }
        if (moveCount > lifetimeStats.dailyStats.longestGameToday) {
          lifetimeStats.dailyStats.longestGameToday = moveCount;
        }
        // Get checkmate piece from last move (the move that caused checkmate)
        let checkmatePiece = null;
        try {
          const history = game.history({ verbose: true });
          if (history.length > 0) {
            const lastMove = history[history.length - 1];
            // The piece that delivered checkmate is the piece that moved
            checkmatePiece = lastMove ? lastMove.piece : null;
          }
        } catch (e) {
          console.error('Error getting checkmate piece:', e);
        }
        trackWinStats(moveCount, checkmatePiece);
        commitGameStatsToLifetime();
        checkAndUnlockAchievements();
        
        // Show rematch modal
        setTimeout(() => showRematchModal("ðŸŽ‰ Victory!", "Congratulations! You won! Play again?"), 2000);
        return;
      }

      startTimer();
      engineMove();
    }  </script>
  <div class="push"></div>
    </div>
  <footer>
        <p>&copy; 2025 Ahrens Labs. All rights reserved.</p>
    </footer>
</body>
</html>
