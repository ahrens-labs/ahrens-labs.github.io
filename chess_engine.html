<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Chess Game against TrifangX</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Orbitron&family=Roboto+Mono&display=swap" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">
    <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <link rel="stylesheet" href="css/style.css">
    <script src="js/script.js"></script>

  <style>
    /* Chess Engine Page - Enhanced Clean Theme */
    body {
      background: linear-gradient(135deg, #f0f4f8 0%, #e8f2f7 50%, #f0f4f8 100%);
      background-attachment: fixed;
      color: #333;
      min-height: 100vh;
      overflow-x: hidden;
      position: relative;
    }

    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: 
          radial-gradient(circle at 20% 80%, rgba(52, 152, 219, 0.03) 0%, transparent 50%),
          radial-gradient(circle at 80% 20%, rgba(46, 204, 113, 0.02) 0%, transparent 50%);
      background-size: 600px 600px;
      animation: subtleFloat 15s ease-in-out infinite;
      pointer-events: none;
      z-index: -1;
    }

    /* Main content container */
    main {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      max-width: 1200px;
      margin: 0 auto;
    }

    /* Main Title Styling */
    h2 {
      text-align: center;
      font-family: "Inter", sans-serif;
      font-size: 2.5rem;
      font-weight: 700;
      margin-bottom: 2rem;
      color: #2c3e50;
      margin-top: 1rem;
      position: relative;
    }

    h2::after {
      content: '';
      position: absolute;
      bottom: -10px;
      left: 50%;
      transform: translateX(-50%);
      width: 100px;
      height: 3px;
      background: linear-gradient(90deg, #3498db, #2ecc71);
      border-radius: 2px;
    }

    .sharp {
      background: linear-gradient(135deg, #3498db, #2ecc71);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      font-weight: 800;
      animation: shimmer 3s ease-in-out infinite;
    }

    /* Game Controls Container */
    #choose-side {
      background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
      padding: 30px;
      border-radius: 20px;
      box-shadow: 
          0 10px 30px rgba(0, 0, 0, 0.1),
          0 1px 8px rgba(0, 0, 0, 0.1),
          inset 0 1px 0 rgba(255, 255, 255, 0.8);
      max-width: 800px;
      margin: 0 auto 30px auto;
      display: flex;
      flex-direction: column;
      gap: 20px;
      align-items: center;
      text-align: center;
      border: 1px solid rgba(52, 152, 219, 0.1);
      position: relative;
      overflow: hidden;
    }

    #choose-side::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, #3498db, #2ecc71, #3498db);
      background-size: 200% 100%;
      animation: shimmer 3s ease-in-out infinite;
    }

    /* Individual control rows */
    .control-row {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      width: 100%;
      flex-wrap: wrap;
    }

    /* Keep label and select together on same line */
    .control-row label:not([for="blindfold-mode"]):not([for="show-history"]) {
      white-space: nowrap;
    }

    .control-row > label,
    .control-row > select {
      flex-shrink: 0;
    }

    /* Less prominent style options */
    .control-row.style-option {
      font-size: 0.9em;
      opacity: 0.8;
    }

    .control-row.style-option label {
      font-size: 0.95em;
      font-weight: 500;
      color: #5a6c7d;
    }

    .control-row.style-option select {
      font-size: 0.9em;
      min-width: 130px;
      padding: 10px 16px;
    }

    /* Labels */
    label {
      font-family: "Inter", sans-serif;
      color: #2c3e50;
      font-weight: 600;
      margin-right: 10px;
      font-size: 1.1em;
    }

    /* Select Dropdowns */
    select {
      background-color: white;
      color: #333;
      border: 2px solid #3498db;
      border-radius: 20px;
      padding: 12px 18px;
      font-family: "Inter", sans-serif;
      font-size: 1em;
      margin: 0;
      transition: all 0.3s ease;
      box-shadow: 0 2px 8px rgba(52, 152, 219, 0.1);
      min-width: 140px;
      max-width: 160px;
      cursor: pointer;
    }

    /* Engine personality selector - make it stand out */
    #engine-style {
      border: 3px solid #6c757d;
      background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
      font-weight: 600;
      min-width: 180px;
      box-shadow: 0 3px 10px rgba(108, 117, 125, 0.15);
      position: relative;
      transition: all 0.4s ease;
    }

    /* Personality color classes */
    #engine-style.personality-balanced {
      border-color: #6c757d;
      box-shadow: 0 3px 10px rgba(108, 117, 125, 0.3), 0 0 15px rgba(108, 117, 125, 0.2);
      background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
    }

    #engine-style.personality-aggressive {
      border-color: #e74c3c;
      box-shadow: 0 3px 12px rgba(231, 76, 60, 0.4), 0 0 20px rgba(231, 76, 60, 0.3);
      background: linear-gradient(145deg, #ffffff 0%, #fff5f5 100%);
    }

    #engine-style.personality-defensive {
      border-color: #3498db;
      box-shadow: 0 3px 12px rgba(52, 152, 219, 0.4), 0 0 20px rgba(52, 152, 219, 0.3);
      background: linear-gradient(145deg, #ffffff 0%, #f0f8ff 100%);
    }

    #engine-style.personality-positional {
      border-color: #9b59b6;
      box-shadow: 0 3px 12px rgba(155, 89, 182, 0.4), 0 0 20px rgba(155, 89, 182, 0.3);
      background: linear-gradient(145deg, #ffffff 0%, #f8f0ff 100%);
    }

    #engine-style.personality-material {
      border-color: #f39c12;
      box-shadow: 0 3px 12px rgba(243, 156, 18, 0.4), 0 0 20px rgba(243, 156, 18, 0.3);
      background: linear-gradient(145deg, #ffffff 0%, #fffaf0 100%);
    }

    #engine-style.personality-tactical {
      border-color: #1abc9c;
      box-shadow: 0 3px 12px rgba(26, 188, 156, 0.4), 0 0 20px rgba(26, 188, 156, 0.3);
      background: linear-gradient(145deg, #ffffff 0%, #f0fff8 100%);
    }

    #engine-style:hover {
      transform: translateY(-2px) scale(1.02);
      filter: brightness(1.05);
    }

    #engine-style:focus {
      outline: none;
      transform: scale(1.03);
    }

    /* Custom personality class */
    #engine-style.personality-custom {
      border-color: #34495e;
      box-shadow: 0 3px 12px rgba(52, 73, 94, 0.4), 0 0 20px rgba(52, 73, 94, 0.3);
      background: linear-gradient(145deg, #ffffff 0%, #f5f6fa 100%);
    }

    /* Custom modifiers panel */
    #custom-modifiers-panel {
      background: linear-gradient(145deg, #f8f9fa 0%, #ffffff 100%);
      border: 2px solid #34495e;
      border-radius: 15px;
      padding: 20px;
      margin: 15px 0;
      box-shadow: 0 4px 15px rgba(52, 73, 94, 0.15);
      animation: slideDown 0.3s ease;
    }

    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .modifier-input-group {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .modifier-input-group label {
      flex: 1;
      font-size: 0.95em;
      font-weight: 500;
      color: #2c3e50;
      text-align: left;
    }

    .modifier-input-group input[type="number"] {
      width: 80px;
      padding: 8px 12px;
      border: 2px solid #34495e;
      border-radius: 10px;
      font-family: "Roboto Mono", monospace;
      font-size: 0.95em;
      text-align: center;
      transition: all 0.3s ease;
      background: white;
    }

    .modifier-input-group input[type="number"]:hover {
      border-color: #5d6d7e;
      box-shadow: 0 2px 8px rgba(52, 73, 94, 0.2);
    }

    .modifier-input-group input[type="number"]:focus {
      outline: none;
      border-color: #3498db;
      box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.15);
    }

    /* Option elements styling */
    select option {
      background: white;
      color: #333;
      font-family: "Inter", sans-serif;
      padding: 8px;
    }

    select:hover {
      border-color: #2980b9;
      box-shadow: 0 4px 12px rgba(52, 152, 219, 0.2);
      transform: translateY(-1px);
    }

    select:focus {
      outline: none;
      border-color: #3498db;
      box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
    }

    /* Start Game Button */
    button {
      width: 100%;
      padding: 15px 20px;
      font-size: 1.1em;
      background-color: #3498db;
      color: white;
      border: none;
      border-radius: 20px;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      font-family: "Inter", sans-serif;
      font-weight: 600;
      box-shadow: 0 4px 12px rgba(52, 152, 219, 0.2);
      margin: 10px 0;
      max-width: 200px;
    }

    button:hover {
      background-color: #2980b9;
      transform: translateY(-2px) scale(1.02);
      box-shadow: 0 6px 16px rgba(52, 152, 219, 0.3);
    }

    button:active {
      transform: translateY(0) scale(1);
      box-shadow: 0 2px 8px rgba(52, 152, 219, 0.2);
    }

    /* Chess Board Container */
    #board-timers-container {
      display: flex !important;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      height: 450px;
      justify-content: flex-start;
      align-self: flex-start;
    }

    /* Chess Board Styling */
    #board {
      width: 450px;
      height: 450px;
      border-radius: 15px;
      box-shadow: 
          0 15px 35px rgba(0, 0, 0, 0.15),
          0 5px 15px rgba(0, 0, 0, 0.1);
      border: 3px solid #e9ecef;
      overflow: hidden;
      position: relative;
      background-color: white;
      transition: all 0.3s ease;
    }

    #board:hover {
      transform: translateY(-2px);
      box-shadow: 
          0 20px 40px rgba(0, 0, 0, 0.2),
          0 8px 20px rgba(0, 0, 0, 0.1);
    }

    /* Board Color Themes */
    .board-theme-classic .white-1e1d7 { background-color: #f0d9b5 !important; }
    .board-theme-classic .black-3c85d { background-color: #b58863 !important; }

    .board-theme-blue .white-1e1d7 { background-color: #dee3e6 !important; }
    .board-theme-blue .black-3c85d { background-color: #8ca2ad !important; }

    .board-theme-green .white-1e1d7 { background-color: #ffffdd !important; }
    .board-theme-green .black-3c85d { background-color: #86a666 !important; }

    .board-theme-gray .white-1e1d7 { background-color: #e8e8e8 !important; }
    .board-theme-gray .black-3c85d { background-color: #999999 !important; }

    .board-theme-purple .white-1e1d7 { background-color: #e8d4f2 !important; }
    .board-theme-purple .black-3c85d { background-color: #9b6db5 !important; }

    .board-theme-wood .white-1e1d7 { background-color: #f4dec4 !important; }
    .board-theme-wood .black-3c85d { background-color: #8b5a2b !important; }

    .board-theme-coral .white-1e1d7 { background-color: #ffebcd !important; }
    .board-theme-coral .black-3c85d { background-color: #cd853f !important; }

    /* Legal Move Highlights */
    .highlight-legal {
      position: relative;
    }
    .highlight-legal::after {
      content: "";
      position: absolute;
      top: 50%;
      left: 50%;
      width: 20px;
      height: 20px;
      background: radial-gradient(circle, #3498db, transparent);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 10;
      animation: legalMovePulse 1.5s ease-in-out infinite;
    }

    /* Hide default drag-over border */
    #board .square-55d63 {
      box-shadow: none !important;
    }

    /* Enable pointer events for dragging */
    #board img {
      pointer-events: auto !important;
      cursor: grab;
      user-select: none;
      -webkit-user-drag: none;
      -khtml-user-drag: none;
      -moz-user-drag: none;
      -o-user-drag: none;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
    }
    
    #board img[draggable] {
      -webkit-user-drag: none !important;
    }

    #board img:active {
      cursor: grabbing;
    }

    /* Only show yellow border on legal move targets during drag */
    .legal-target {
      box-shadow: inset 0 0 0 3px rgba(255, 235, 59, 0.8) !important;
    }

    @keyframes legalMovePulse {
      0%, 100% { 
        opacity: 0.6; 
        transform: translate(-50%, -50%) scale(1);
      }
      50% { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1.2);
      }
    }

    /* Timers Container */
    #timers-container {
      font-family: "Inter", sans-serif;
      color: #333;
      display: none;
      flex-direction: column;
      justify-content: center;
      gap: 15px;
      user-select: none;
      background-color: white;
      border-radius: 15px;
      padding: 25px;
      border: 1px solid #e9ecef;
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.1);
      min-width: 250px;
      min-height: 150px;
      visibility: visible !important;
    }

    #timers-container div {
      font-size: 1.2em;
      font-weight: 600;
      padding: 15px;
      background-color: #f8f9fa;
      border-radius: 10px;
      border-left: 4px solid #3498db;
      transition: all 0.3s ease;
    }
    
    .time-slot {
      display: block !important;
      visibility: visible !important;
    }

    #timers-container div:hover {
      background-color: #e9ecef;
      transform: translateX(3px);
    }

    /* Move Timer */
    #move-timer-container {
      text-align: center;
      margin: 0;
      font-family: "Inter", sans-serif;
      font-size: 1.3em;
      font-weight: 600;
      user-select: none;
      color: #2c3e50;
      background-color: white;
      border-radius: 15px;
      padding: 20px;
      border: 1px solid #e9ecef;
      max-width: 300px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    /* Last Move Container */
    #last-move-container {
      text-align: center;
      margin: 0;
      font-family: "Inter", sans-serif;
      font-size: 1.2em;
      font-weight: 600;
      color: #2c3e50;
      user-select: none;
      background-color: white;
      border-radius: 15px;
      padding: 20px;
      border: 1px solid #e9ecef;
      max-width: 500px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    #turn-color {
      color: #3498db;
      font-weight: 700;
    }

    #last-move {
      color: #e74c3c;
      font-weight: 700;
    }

    /* Game Statistics Panel */
    #game-stats-panel {
      background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
      padding: 15px;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
      margin: 15px auto;
      max-width: 600px;
      border: 1px solid rgba(52, 152, 219, 0.1);
      font-family: 'Inter', sans-serif;
      display: none;
    }

    #game-stats-panel h3 {
      text-align: center;
      font-size: 1.05rem;
      font-weight: 600;
      color: #2c3e50;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 2px solid #e9ecef;
    }

    .stats-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 10px;
      margin-bottom: 6px;
      background: white;
      border-radius: 6px;
      border-left: 2px solid #3498db;
    }

    .stats-label {
      font-weight: 600;
      color: #2c3e50;
      font-size: 0.9em;
    }

    .stats-value {
      font-weight: 500;
      color: #7f8c8d;
      font-size: 0.9em;
    }

    .captured-pieces {
      display: flex;
      gap: 5px;
      align-items: center;
      flex-wrap: wrap;
    }

    .captured-piece {
      width: 30px;
      height: 30px;
      display: inline-block;
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
    }

    /* Main game container with vertical layout */
    #game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
      margin: 20px auto;
      max-width: 1400px;
    }

    #board-row {
      display: flex;
      justify-content: center;
      align-items: flex-start;
      gap: 25px;
      align-items: flex-start;
    }
    
    /* Ensure board container has fixed height */
    #board-timers-container {
      height: 450px;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;
    }

    /* Captured pieces beside board */
    #board-with-captures {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 20px;
    }

    #captured-pieces-left {
      display: flex;
      flex-direction: column;
      gap: 30px;
      min-width: 80px;
    }

    #right-panel {
      display: flex;
      flex-direction: column;
      gap: 15px;
      min-width: 350px;
      max-width: 400px;
      height: 450px;
      overflow-y: auto;
      overflow-x: hidden;
      align-self: flex-start;
    }

    #right-panel > div,
    #right-panel > button {
      margin: 0;
    }

    #game-buttons {
      display: flex;
      gap: 10px;
      justify-content: center;
    }

    #game-buttons button {
      flex: 1;
      min-width: 0;
    }
    
    #board-timers-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      height: 450px;
      justify-content: flex-start;
      align-self: flex-start;
    }

    .captured-section {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
      background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
      border-radius: 10px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
    }

    .captured-section-title {
      font-family: 'Inter', sans-serif;
      font-size: 0.75em;
      font-weight: 600;
      color: #7f8c8d;
      margin-bottom: 8px;
      text-align: center;
    }

    .captured-pieces-display {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      max-width: 70px;
      justify-content: center;
    }

    .material-advantage {
      font-weight: 700;
      font-size: 1.1em;
    }

    .material-advantage.positive {
      color: #2ecc71;
    }

    .material-advantage.negative {
      color: #e74c3c;
    }

    #right-panel {
      display: flex;
      flex-direction: column;
      gap: 15px;
      min-width: 350px;
      max-width: 400px;
      height: 450px;
      overflow-y: auto;
      overflow-x: hidden;
      align-self: flex-start;
    }

    #right-panel > div,
    #right-panel > button {
      margin: 0;
    }

    .material-advantage.equal {
      color: #7f8c8d;
    }

    /* Opening Book Display */
    #opening-display {
      background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
      padding: 12px 15px;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
      margin: 15px auto;
      max-width: 600px;
      text-align: center;
      border: 1px solid rgba(52, 152, 219, 0.1);
      display: none;
    }

    #opening-display .opening-label {
      font-family: 'Inter', sans-serif;
      font-size: 0.8em;
      font-weight: 500;
      color: #7f8c8d;
      margin-bottom: 4px;
    }

    #opening-display .opening-name {
      font-family: 'Inter', sans-serif;
      font-size: 1.1em;
      font-weight: 700;
      color: #3498db;
    }

    /* Export PGN Button */
    #export-pgn-btn {
      background-color: #2ecc71;
      color: white;
      padding: 12px 24px;
      border: none;
      border-radius: 20px;
      cursor: pointer;
      font-family: 'Inter', sans-serif;
      font-weight: 600;
      font-size: 1em;
      box-shadow: 0 4px 12px rgba(46, 204, 113, 0.2);
      transition: all 0.3s ease;
      margin: 10px auto;
      display: none;
    }

    #export-pgn-btn:hover {
      background-color: #27ae60;
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(46, 204, 113, 0.3);
    }
    
    /* Resign Button */
    #resign-btn {
      background-color: #e74c3c;
      color: white;
      padding: 12px 24px;
      border: none;
      border-radius: 20px;
      cursor: pointer;
      font-family: 'Inter', sans-serif;
      font-weight: 600;
      font-size: 1em;
      box-shadow: 0 4px 12px rgba(231, 76, 60, 0.2);
      transition: all 0.3s ease;
      margin: 10px auto;
      display: none;
    }

    #resign-btn:hover {
      background-color: #c0392b;
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(231, 76, 60, 0.3);
    }

    /* Board square highlighting */
    .highlight-last-move {
      background-color: rgba(255, 235, 59, 0.4) !important;
    }

    .highlight-check {
      background-color: rgba(231, 76, 60, 0.5) !important;
      animation: checkPulse 1s ease-in-out infinite;
    }

    @keyframes checkPulse {
      0%, 100% { 
        background-color: rgba(231, 76, 60, 0.5) !important;
      }
      50% { 
        background-color: rgba(231, 76, 60, 0.7) !important;
      }
    }

    /* Illegal move animation */
    @keyframes illegalMoveBlink {
      0%, 100% { 
        background-color: transparent;
        box-shadow: none;
      }
      50% {
        background-color: rgba(231, 76, 60, 0.4) !important;
        box-shadow: inset 0 0 10px rgba(231, 76, 60, 0.5) !important;
      }
    }

    .square-55d63.illegal-move {
      animation: illegalMoveBlink 0.4s ease-in-out !important;
    }

    /* Premove highlighting */
    .square-55d63.premove-highlight {
      background-color: rgba(215, 57, 65, 0.65) !important; /* Medium red between dark and light */
      box-shadow: inset 0 0 0 4px rgba(190, 40, 47, 0.9) !important;
    }
    
    div.premove-highlight {
      background-color: rgba(215, 57, 65, 0.65) !important;
      box-shadow: inset 0 0 0 4px rgba(190, 40, 47, 0.9) !important;
    }
    
    /* Premove source highlighting (same color as destination) */
    .square-55d63.premove-source {
      background-color: rgba(215, 57, 65, 0.65) !important; /* Same medium red */
      box-shadow: inset 0 0 0 4px rgba(190, 40, 47, 0.9) !important;
    }
    
    div.premove-source {
      background-color: rgba(215, 57, 65, 0.65) !important;
      box-shadow: inset 0 0 0 4px rgba(190, 40, 47, 0.9) !important;
    }

    /* Custom Confirmation Modal */
    #confirm-modal {
      display: none;
      position: fixed;
      z-index: 10000;
      animation: popIn 0.2s ease-out;
    }

    #confirm-modal.show {
      display: block;
    }

    .confirm-dialog {
      background: white;
      border-radius: 12px;
      padding: 20px 25px;
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.25), 0 0 0 1px rgba(0, 0, 0, 0.05);
      min-width: 280px;
      max-width: 320px;
      position: relative;
      border: 2px solid #e74c3c;
    }

    .confirm-dialog::after {
      content: '';
      position: absolute;
      bottom: -10px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 10px solid transparent;
      border-right: 10px solid transparent;
      border-top: 10px solid #e74c3c;
    }

    .confirm-dialog::before {
      content: '';
      position: absolute;
      bottom: -8px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 9px solid transparent;
      border-right: 9px solid transparent;
      border-top: 9px solid white;
      z-index: 1;
    }

    .confirm-dialog h3 {
      margin: 0 0 10px 0;
      color: #e74c3c;
      font-family: 'Inter', sans-serif;
      font-size: 1.1em;
      font-weight: 600;
    }

    .confirm-dialog p {
      margin: 0 0 15px 0;
      color: #555;
      font-family: 'Inter', sans-serif;
      font-size: 0.95em;
      line-height: 1.4;
    }

    .confirm-buttons {
      display: flex;
      gap: 10px;
      justify-content: stretch;
    }

    .confirm-buttons button {
      flex: 1;
      padding: 8px 16px;
      border: none;
      border-radius: 8px;
      font-family: 'Inter', sans-serif;
      font-size: 0.9em;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .confirm-buttons .confirm-yes {
      background: linear-gradient(135deg, #e74c3c, #c0392b);
      color: white;
    }

    .confirm-buttons .confirm-yes:hover {
      transform: translateY(-1px);
      box-shadow: 0 3px 8px rgba(231, 76, 60, 0.4);
    }

    .confirm-buttons .confirm-no {
      background: linear-gradient(135deg, #ecf0f1, #bdc3c7);
      color: #555;
    }

    .confirm-buttons .confirm-no:hover {
      transform: translateY(-1px);
      box-shadow: 0 3px 8px rgba(189, 195, 199, 0.4);
    }

    @keyframes popIn {
      from { 
        opacity: 0;
        transform: translateY(10px) scale(0.95);
      }
      to { 
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    @keyframes victoryPulse {
      0%, 100% { transform: scale(1); filter: brightness(1); }
      25% { transform: scale(1.03); box-shadow: 0 0 40px rgba(46, 204, 113, 0.9); filter: brightness(1.1); }
      50% { transform: scale(0.98); box-shadow: 0 0 60px rgba(46, 204, 113, 1); filter: brightness(1.2); }
      75% { transform: scale(1.02); box-shadow: 0 0 50px rgba(46, 204, 113, 0.9); filter: brightness(1.1); }
    }

    @keyframes sparkle {
      0%, 100% { opacity: 0; transform: scale(0) rotate(0deg); }
      50% { opacity: 1; transform: scale(1) rotate(180deg); }
    }

    @keyframes defeatShake {
      0%, 100% { transform: translateX(0) rotate(0deg) scale(1); }
      5% { transform: translateX(-15px) rotate(-2deg) scale(0.98); }
      10% { transform: translateX(15px) rotate(2deg) scale(1.02); }
      15% { transform: translateX(-15px) rotate(-2deg) scale(0.98); }
      20% { transform: translateX(15px) rotate(2deg) scale(1.02); }
      25% { transform: translateX(-12px) rotate(-1.5deg) scale(0.99); }
      30% { transform: translateX(12px) rotate(1.5deg) scale(1.01); }
      35% { transform: translateX(-12px) rotate(-1.5deg) scale(0.99); }
      40% { transform: translateX(12px) rotate(1.5deg) scale(1.01); }
      50% { transform: translateX(-8px) rotate(-1deg) scale(1); }
      60% { transform: translateX(8px) rotate(1deg) scale(1); }
      70% { transform: translateX(-5px) rotate(-0.5deg) scale(1); }
      80% { transform: translateX(5px) rotate(0.5deg) scale(1); }
      90% { transform: translateX(-2px) rotate(0deg) scale(1); }
    }

    @keyframes defeatPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(0.95); }
    }

    @keyframes defeatFlash {
      0% { opacity: 0; }
      5% { opacity: 0.6; }
      10% { opacity: 0.2; }
      15% { opacity: 0.7; }
      20% { opacity: 0.1; }
      25% { opacity: 0.6; }
      30% { opacity: 0.2; }
      35% { opacity: 0.5; }
      40% { opacity: 0.1; }
      50% { opacity: 0.4; }
      60% { opacity: 0.1; }
      70% { opacity: 0.3; }
      100% { opacity: 0; }
    }

    @keyframes kingFall {
      0% { 
        transform: rotate(0deg) translateY(0);
        opacity: 1;
      }
      50% {
        transform: rotate(45deg) translateY(5px);
        opacity: 1;
      }
      100% { 
        transform: rotate(90deg) translateY(15px);
        opacity: 0.6;
      }
    }

    /* Checkmate Celebration */
    .confetti {
      position: fixed;
      width: 10px;
      height: 10px;
      background: #f0f;
      z-index: 9999;
    }

    .sparkle {
      position: fixed;
      width: 20px;
      height: 20px;
      background: radial-gradient(circle, rgba(255, 215, 0, 1) 0%, rgba(255, 215, 0, 0) 70%);
      border-radius: 50%;
      z-index: 10000;
      pointer-events: none;
    }

    @keyframes confetti-fall {
      to {
        transform: translateY(100vh) rotate(720deg);
        opacity: 0;
      }
    }

    .checkmate-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 9998;
    }

    .defeat-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, rgba(139, 0, 0, 0.3) 0%, rgba(139, 0, 0, 0.6) 100%);
      pointer-events: none;
      z-index: 9997;
      animation: defeatFlash 1.2s ease-out;
    }

    /* Move History/Notation Container */
    #notation-container {
      background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
      padding: 15px;
      border-radius: 15px;
      box-shadow: 
          0 4px 15px rgba(0, 0, 0, 0.08),
          inset 0 1px 0 rgba(255, 255, 255, 0.8);
      border: 1px solid rgba(52, 152, 219, 0.1);
      font-family: 'Roboto Mono', monospace;
      font-size: 0.85rem;
      line-height: 1.8;
      min-height: 60px;
      height: auto;
      max-height: 450px;
      transition: min-height 0.35s cubic-bezier(0.33,1,0.68,1), max-height 0.35s cubic-bezier(0.33,1,0.68,1);
      box-sizing: border-box;
      overflow-y: auto;
      overflow-x: hidden;
      display: none;
      color: #34495e;
      flex-shrink: 0;
    }
    
    #notation-container .move-item.highlighted {
      background-color: #3498db !important;
      color: white !important;
      font-weight: 600;
    }
    
    #notation-container .move-item.highlighted:hover {
      background-color: #2980b9 !important;
    }

    #notation-container::before {
      content: 'Move History (‚Üê ‚Üí keys to navigate)';
      display: block;
      font-family: 'Inter', sans-serif;
      font-size: 0.95rem;
      font-weight: 600;
      color: #2c3e50;
      text-align: center;
      margin-bottom: 10px;
      opacity: 0.8;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 2px solid #e9ecef;
      position: sticky;
      top: 0;
      background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
      z-index: 1;
      margin-top: -15px;
      padding-top: 15px;
    }

    .move-pair {
      margin-bottom: 8px;
      padding: 8px 12px;
      background: white;
      border-radius: 8px;
      transition: all 0.2s ease;
    }

    .move-pair:hover {
      background: #f8f9fa;
      transform: translateX(3px);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    }

    .move-number {
      color: #7f8c8d;
      margin-right: -10px;
      font-weight: 600;
      min-width: 30px;
      display: inline-block;
    }

    .white-move {
      color: #2c3e50;
      margin-right: -10px;
      font-weight: 600;
      padding: 4px 8px;
      background: rgba(52, 152, 219, 0.08);
      border-radius: 4px;
      border-left: 3px solid #3498db;
    }

    .move-item {
      cursor: pointer;
      padding: 3px 3px;
      margin: 0;
      border-radius: 4px;
      transition: all 0.2s ease;
      display: inline-block;
    }

    .move-item:hover {
      background: rgba(52, 152, 219, 0.2);
    }

    .move-item.highlighted {
      background: #3498db;
      color: white;
      font-weight: 700;
      box-shadow: 0 2px 6px rgba(52, 152, 219, 0.4);
    }

    .black-move {
      color: #34495e;
      font-weight: 500;
      padding: 4px 8px;
      background: rgba(44, 62, 80, 0.05);
      border-radius: 4px;
      border-left: 3px solid #2c3e50;
    }

    /* Hidden State */
    #timers-container,
    #move-timer-container,
    #last-move-container,
    #notation-container {
      display: none;
    }

    /* Blindfold Mode */
    .blindfold-hidden {
      display: none !important;
    }

    #move-input-container {
      text-align: center;
      margin: 20px auto;
      padding: 20px;
      background-color: white;
      border-radius: 15px;
      border: 1px solid #e9ecef;
      max-width: 600px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    #show-history-row {
      display: none;
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      main {
        padding: 15px;
      }
      
      #board-timers-container {
        flex-direction: column;
        gap: 20px;
      }
      
      #board {
        width: 350px;
        height: 350px;
      }
      
      h2 {
        font-size: 2rem;
      }
      
      #choose-side {
        padding: 20px;
        margin: 0 10px 20px 10px;
      }
      
      .control-row {
        flex-direction: column;
        gap: 10px;
        text-align: center;
      }
      
      select, button {
        width: 200px;
        max-width: 90%;
      }
      
      #timers-container {
        min-width: 200px;
      }
    }
  </style>
</head>
<body>
    <div class="wrapper">
        <header>
            <div class="header-content">
                <a href="index.html" class="logo-link">
                    <img src="img/EagleLogo.png" alt="Ahrens Labs logo" class="header-logo">
                </a>
                <h1>Ahrens Labs</h1>
                <nav>
                    <ul>
                        <li><a href="index.html">Home</a></li>
                        <li><a href="labs.html">Labs & Projects</a></li>
                        <li><a href="contact.html">Contact</a></li>
                        <li><a href="chess_engine.html" class="active">Chess Engine</a></li>
                    </ul>
                </nav>
            </div>
        </header>
	    
	<h2>
    Play Chess against Trifang<span class="sharp">X</span>
    </h2>
  <div id="choose-side">
    <div class="control-row">
      <label for="color-select">Choose your side: </label>
      <select id="color-select">
        <option value="random">Random</option>
        <option value="white">White</option>
        <option value="black">Black</option>
      </select>
      
      <label for="time-control" style="margin-left: 15px;">Time control: </label>
      <select id="time-control">
        <option value="none">None</option>
        <option value="60">1 min</option>
        <option value="180|2">3 | 2</option>egal 
        <option value="300|0">5 min</option>
        <option value="600|0">10 min</option>
        <option value="900|5">15 | 5</option>
        <option value="3600|0">60 min</option>
      </select>
    </div>
    
    <div class="control-row style-option">
      <label for="board-style">Board Style: </label>
      <select id="board-style" onchange="changeBoardStyle()">
        <option value="classic">Classic</option>
        <option value="blue">Blue</option>
        <option value="green">Green</option>
        <option value="gray">Gray</option>
        <option value="purple">Purple</option>
        <option value="wood">Wood</option>
        <option value="coral">Coral</option>
      </select>
      
      <label for="piece-style" style="margin-left: 20px;">Piece Style: </label>
      <select id="piece-style" onchange="changePieceStyle()">
        <option value="wikipedia">Wikipedia</option>
        <option value="alpha">Alpha</option>
        <option value="cburnett">CBurnett</option>
        <option value="merida">Merida</option>
        <option value="pirouetti">Pirouetti</option>
        <option value="spatial">Spatial</option>
      </select>
    </div>
    
    <div class="control-row">
      <label for="engine-style">Engine Personality:</label>
      <select id="engine-style" onchange="changeEngineStyle()">
        <option value="balanced">‚öñÔ∏è Balanced</option>
        <option value="aggressive">‚öîÔ∏è Aggressive</option>
        <option value="defensive">üõ°Ô∏è Defensive</option>
        <option value="positional">üéØ Positional</option>
        <option value="material">üíé Material-Focused</option>
        <option value="tactical">‚ö° Tactical</option>
        <option value="custom">üéõÔ∏è Custom</option>
      </select>
    </div>
    
    <!-- Custom modifiers panel -->
    <div id="custom-modifiers-panel" style="display: none;">
      <div style="text-align: center; margin-bottom: 15px; font-weight: 600; color: #2c3e50;">
        Customize Engine Modifiers (0.0 - 3.0)
      </div>
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; max-width: 600px; margin: 0 auto;">
        <div class="modifier-input-group">
          <label for="mod-material">Material:</label>
          <input type="number" id="mod-material" min="0" max="3" step="0.1" value="1.0" onchange="updateCustomModifiers()">
        </div>
        <div class="modifier-input-group">
          <label for="mod-king-safety">King Safety:</label>
          <input type="number" id="mod-king-safety" min="0" max="3" step="0.1" value="1.0" onchange="updateCustomModifiers()">
        </div>
        <div class="modifier-input-group">
          <label for="mod-centralization">Centralization:</label>
          <input type="number" id="mod-centralization" min="0" max="3" step="0.1" value="1.0" onchange="updateCustomModifiers()">
        </div>
        <div class="modifier-input-group">
          <label for="mod-attack">Attack:</label>
          <input type="number" id="mod-attack" min="0" max="3" step="0.1" value="1.0" onchange="updateCustomModifiers()">
        </div>
        <div class="modifier-input-group">
          <label for="mod-piece-activity">Piece Activity:</label>
          <input type="number" id="mod-piece-activity" min="0" max="3" step="0.1" value="1.0" onchange="updateCustomModifiers()">
        </div>
        <div class="modifier-input-group">
          <label for="mod-defense">Defense:</label>
          <input type="number" id="mod-defense" min="0" max="3" step="0.1" value="1.0" onchange="updateCustomModifiers()">
        </div>
        <div class="modifier-input-group">
          <label for="mod-pawn-structure">Pawn Structure:</label>
          <input type="number" id="mod-pawn-structure" min="0" max="3" step="0.1" value="1.0" onchange="updateCustomModifiers()">
        </div>
        <div style="grid-column: 1 / -1; text-align: center; margin-top: 5px;">
          <button onclick="resetCustomModifiers()" style="padding: 8px 20px; font-size: 0.9em; background: linear-gradient(135deg, #95a5a6, #7f8c8d); border: none; border-radius: 15px; color: white; cursor: pointer; font-weight: 600;">
            Reset to 1.0
          </button>
        </div>
      </div>
    </div>
    
    <div class="control-row">
      <label for="blindfold-mode">
        <input type="checkbox" id="blindfold-mode" onchange="toggleHistoryOption()" style="margin-right: 8px;">
        Blindfold Mode
      </label>
    
      <label for="show-history" id="show-history-row" style="margin-left: 20px; display: none;">
        <input type="checkbox" id="show-history" style="margin-right: 8px;">
        Show Move History in Blindfold
      </label>
    </div>
    
    <div class="control-row">
      <button onclick="startGame()">Start Game</button>
    </div>
  </div>

  <div id="game-container">
    <div style="display: flex; justify-content: center; align-items: center; gap: 20px; flex-wrap: wrap; margin: 20px auto;">
      <div id="move-timer-container">
        Time for this move: <span id="timer">00:00.00</span>
      </div>
      <div id="last-move-container">
        Turn: <span id="turn-color">White</span> | Last Move: <span id="last-move">None</span>
      </div>
    </div>

    <div id="board-row">
      <div id="board-with-captures">
        <div id="captured-pieces-left">
          <div class="captured-section" id="black-captured-section">
            <div class="captured-section-title">Black Pieces</div>
            <div class="captured-pieces-display" id="black-captures-display"></div>
          </div>
          <div class="captured-section" id="white-captured-section">
            <div class="captured-section-title">White Pieces</div>
            <div class="captured-pieces-display" id="white-captures-display"></div>
          </div>
        </div>

        <div id="board-timers-container">
          <div id="board"></div>

          <div id="timers-container">
              <!-- The divs here will be reordered by JavaScript in startGame() based on playerColor. -->
              <!-- They now have IDs for easier manipulation -->
            <div id="time-slot-white" class="time-slot">
              White Time Left: <span id="white-total">--:--.--</span>
            </div>
            <div id="time-slot-black" class="time-slot">
              Black Time Left: <span id="black-total">--:--.--</span>
            </div>
          </div>
        </div>
      </div>

      <div id="right-panel">
        <div id="opening-display">
          <div class="opening-label">Opening:</div>
          <div class="opening-name" id="opening-name">-</div>
        </div>

      <div id="game-stats-panel">
        <h3>Game Statistics</h3>
        <div class="stats-row">
          <span class="stats-label">Material Balance:</span>
          <span class="stats-value material-advantage" id="material-balance">Equal</span>
        </div>
        <div class="stats-row">
          <span class="stats-label">Total Moves:</span>
          <span class="stats-value" id="total-moves">0</span>
        </div>
        <div class="stats-row">
          <span class="stats-label">Move Number:</span>
          <span class="stats-value" id="move-number">1</span>
        </div>
      </div>

      <div id="notation-container"></div>

      <div id="game-buttons">
        <button id="export-pgn-btn" onclick="exportPGN()">Export Game (PGN)</button>
        <button id="resign-btn" onclick="resignGame()" style="display: none;">Resign</button>
      </div>
    </div>
  </div>

  <!-- Custom Confirmation Modal -->
  <div id="confirm-modal">
    <div class="confirm-dialog">
      <h3>‚ö†Ô∏è Resign Game?</h3>
      <p>Are you sure you want to resign? This cannot be undone.</p>
      <div class="confirm-buttons">
        <button class="confirm-no" onclick="closeConfirmModal()">Cancel</button>
        <button class="confirm-yes" onclick="confirmResign()">Resign</button>
      </div>
    </div>
  </div>

  <div id="move-input-container" style="display: none;">
    <input type="text" id="move-input" placeholder="Enter move (e.g., e4, Nf3, O-O)" 
           onkeypress="if(event.key === 'Enter') submitMove()"
           style="padding: 12px 18px; font-size: 1.1em; border: 2px solid #3498db; 
                  border-radius: 20px; margin-right: 10px; font-family: 'Inter', sans-serif;
                  box-shadow: 0 2px 8px rgba(52, 152, 219, 0.1);">
    <button onclick="submitMove()" 
            style="padding: 12px 24px; font-size: 1.1em; background-color: #3498db; 
                   color: white; border: none; border-radius: 20px; cursor: pointer;
                   font-family: 'Inter', sans-serif; font-weight: 600; max-width: none;">
      Submit Move
    </button>
  </div>

  <script>
    let game, board;
    let playerColor = "white";
    let timerStart = 0;
    let timerInterval = null;
    let whiteTime, blackTime, increment;
    let timeLimited = false;
    let gameOver = false;
    let blindfoldMode = false;
    let showHistoryInBlindfold = false;
    let moveHistory = [];
    let currentMoveIndex = -1;
    let capturedPieces = { white: [], black: [] };
    let lastMoveSquares = { from: null, to: null };
    let gameStartTime = null;
    let currentPieceStyle = 'wikipedia';
    let premoves = []; // Store array of premoves as [{from: 'e2', to: 'e4'}, ...]
    let selectedSquare = null; // Track clicked piece for click-to-move
    let currentEngineStyle = 'balanced'; // Track current engine personality

    // Engine personality presets
    const enginePersonalities = {
      balanced: {
        material: 1.0,
        king_safety_b: 1.0, king_safety_w: 1.0,
        centralization_b: 1.0, centralization_w: 1.0,
        attack_b: 1.0, attack_w: 1.0,
        piece_activity_b: 1.0, piece_activity_w: 1.0,
        defense_b: 1.0, defense_w: 1.0,
        pawn_structure_b: 1.0, pawn_structure_w: 1.0
      },
      aggressive: {
        material: 0.7,
        king_safety_b: 0.5, king_safety_w: 0.5,
        centralization_b: 1.5, centralization_w: 1.5,
        attack_b: 2.5, attack_w: 2.5,
        piece_activity_b: 1.8, piece_activity_w: 1.8,
        defense_b: 0.4, defense_w: 0.4,
        pawn_structure_b: 0.6, pawn_structure_w: 0.6
      },
      defensive: {
        material: 1.2,
        king_safety_b: 2.2, king_safety_w: 2.2,
        centralization_b: 0.7, centralization_w: 0.7,
        attack_b: 0.5, attack_w: 0.5,
        piece_activity_b: 0.6, piece_activity_w: 0.6,
        defense_b: 2.0, defense_w: 2.0,
        pawn_structure_b: 1.8, pawn_structure_w: 1.8
      },
      positional: {
        material: 0.8,
        king_safety_b: 1.4, king_safety_w: 1.4,
        centralization_b: 2.0, centralization_w: 2.0,
        attack_b: 0.7, attack_w: 0.7,
        piece_activity_b: 1.5, piece_activity_w: 1.5,
        defense_b: 1.6, defense_w: 1.6,
        pawn_structure_b: 1.9, pawn_structure_w: 1.9
      },
      material: {
        material: 2.5,
        king_safety_b: 0.7, king_safety_w: 0.7,
        centralization_b: 0.6, centralization_w: 0.6,
        attack_b: 0.9, attack_w: 0.9,
        piece_activity_b: 0.5, piece_activity_w: 0.5,
        defense_b: 0.7, defense_w: 0.7,
        pawn_structure_b: 1.1, pawn_structure_w: 1.1
      },
      tactical: {
        material: 0.9,
        king_safety_b: 0.6, king_safety_w: 0.6,
        centralization_b: 1.6, centralization_w: 1.6,
        attack_b: 2.2, attack_w: 2.2,
        piece_activity_b: 2.0, piece_activity_w: 2.0,
        defense_b: 0.7, defense_w: 0.7,
        pawn_structure_b: 0.8, pawn_structure_w: 0.8
      },
      custom: {
        material: 1.0,
        king_safety_b: 1.0, king_safety_w: 1.0,
        centralization_b: 1.0, centralization_w: 1.0,
        attack_b: 1.0, attack_w: 1.0,
        piece_activity_b: 1.0, piece_activity_w: 1.0,
        defense_b: 1.0, defense_w: 1.0,
        pawn_structure_b: 1.0, pawn_structure_w: 1.0
      }
    };

    // Piece style themes
    const pieceThemes = {
      wikipedia: 'lib/img/chesspieces/wikipedia/{piece}.png',
      alpha: 'https://lichess1.org/assets/piece/alpha/{piece}.svg',
      cburnett: 'https://lichess1.org/assets/piece/cburnett/{piece}.svg',
      merida: 'https://lichess1.org/assets/piece/merida/{piece}.svg',
      pirouetti: 'https://lichess1.org/assets/piece/pirouetti/{piece}.svg',
      spatial: 'https://lichess1.org/assets/piece/spatial/{piece}.svg'
    };

    // Opening Book Database
    const openingBook = {
      "e4": "King's Pawn Opening",
      "e4 e5": "Open Game",
      "e4 e5 Nf3 Nc6 Bb5": "Ruy Lopez (Spanish Opening)",
      "e4 e5 Nf3 Nc6 Bb5 a6": "Ruy Lopez: Morphy Defense",
      "e4 e5 Nf3 Nc6 Bb5 a6 Ba4 Nf6 O-O": "Ruy Lopez: Closed Variation",
      "e4 e5 Nf3 Nc6 Bb5 a6 Ba4 Nf6 O-O Be7": "Ruy Lopez: Closed, Chigorin Defense",
      "e4 e5 Nf3 Nc6 Bb5 Nf6": "Ruy Lopez: Berlin Defense",
      "e4 e5 Nf3 Nc6 Bc4": "Italian Game",
      "e4 e5 Nf3 Nc6 Bc4 Bc5": "Italian Game: Giuoco Piano",
      "e4 e5 Nf3 Nc6 Bc4 Bc5 c3": "Italian Game: Giuoco Pianissimo",
      "e4 e5 Nf3 Nc6 Bc4 Bc5 b4": "Italian Game: Evans Gambit",
      "e4 e5 Nf3 Nc6 Bc4 Nf6": "Italian Game: Two Knights Defense",
      "e4 e5 Nf3 Nf6": "Petrov's Defense (Russian Game)",
      "e4 c5": "Sicilian Defense",
      "e4 c5 Nf3 d6": "Sicilian Defense: Open Variation",
      "e4 c5 Nf3 d6 d4 cxd4 Nxd4 Nf6 Nc3 a6": "Sicilian Defense: Najdorf Variation",
      "e4 c5 Nf3 d6 d4 cxd4 Nxd4 Nf6 Nc3 g6": "Sicilian Defense: Dragon Variation",
      "e4 c5 Nf3 d6 d4 cxd4 Nxd4 Nf6 Nc3 e6": "Sicilian Defense: Scheveningen Variation",
      "e4 c5 Nf3 Nc6": "Sicilian Defense: Closed Variation",
      "e4 c5 Nf3 e6": "Sicilian Defense: French Variation",
      "e4 c5 c3": "Sicilian Defense: Alapin Variation",
      "e4 e6": "French Defense",
      "e4 e6 d4 d5": "French Defense: Main Line",
      "e4 e6 d4 d5 Nc3": "French Defense: Classical Variation",
      "e4 e6 d4 d5 Nd2": "French Defense: Tarrasch Variation",
      "e4 e6 d4 d5 exd5": "French Defense: Exchange Variation",
      "e4 c6": "Caro-Kann Defense",
      "e4 c6 d4 d5": "Caro-Kann Defense: Main Line",
      "e4 c6 d4 d5 Nc3": "Caro-Kann Defense: Classical Variation",
      "e4 c6 d4 d5 exd5": "Caro-Kann Defense: Exchange Variation",
      "e4 d5": "Scandinavian Defense (Center Counter)",
      "e4 d5 exd5 Qxd5": "Scandinavian Defense: Main Line",
      "e4 d5 exd5 Nf6": "Scandinavian Defense: Modern Variation",
      "d4": "Queen's Pawn Opening",
      "d4 d5": "Closed Game",
      "d4 d5 c4": "Queen's Gambit",
      "d4 d5 c4 e6": "Queen's Gambit Declined",
      "d4 d5 c4 e6 Nc3 Nf6": "Queen's Gambit Declined: Orthodox Variation",
      "d4 d5 c4 e6 Nc3 Nf6 Bg5": "Queen's Gambit Declined: Classical Variation",
      "d4 d5 c4 c6": "Slav Defense",
      "d4 d5 c4 c6 Nf3 Nf6 Nc3 dxc4": "Slav Defense: Accepted Variation",
      "d4 d5 c4 c6 Nf3 Nf6 Nc3 e6": "Semi-Slav Defense",
      "d4 d5 c4 dxc4": "Queen's Gambit Accepted",
      "d4 Nf6 c4 g6": "King's Indian Defense",
      "d4 Nf6 c4 g6 Nc3 Bg7": "King's Indian Defense: Main Line",
      "d4 Nf6 c4 g6 Nc3 Bg7 e4": "King's Indian Defense: Classical Variation",
      "d4 Nf6 c4 e6": "Indian Defense",
      "d4 Nf6 c4 e6 Nc3 Bb4": "Nimzo-Indian Defense",
      "d4 Nf6 c4 e6 Nc3 Bb4 Qc2": "Nimzo-Indian Defense: Classical Variation",
      "d4 Nf6 c4 e6 Nc3 Bb4 e3": "Nimzo-Indian Defense: Rubinstein Variation",
      "d4 Nf6 c4 e6 Nf3 b6": "Queen's Indian Defense",
      "d4 Nf6 Nf3 g6": "King's Indian Attack",
      "d4 Nf6 Nf3 e6": "Indian Game",
      "d4 Nf6 c4 c5 d5": "Benoni Defense: Modern Benoni",
      "d4 Nf6 c4 c5 d5 e6": "Benoni Defense: Modern Variation",
      "Nf3": "R√©ti Opening",
      "Nf3 d5 c4": "R√©ti Opening: Anglo-Slav Variation",
      "Nf3 Nf6 c4 g6": "R√©ti Opening: King's Indian Attack",
      "c4": "English Opening",
      "c4 e5": "English Opening: Reversed Sicilian",
      "c4 Nf6": "English Opening: Anglo-Indian Defense",
      "c4 c5": "English Opening: Symmetrical Variation",
      "e4 e5 Nf3 Nc6 d4": "Scotch Game",
      "e4 e5 Nf3 Nc6 d4 exd4 Nxd4": "Scotch Game: Main Line",
      "e4 e5 Nf3 Nc6 Nc3": "Four Knights Game",
      "e4 e5 Nf3 Nc6 Nc3 Nf6": "Four Knights Game: Spanish Variation",
      "e4 e5 f4": "King's Gambit",
      "e4 e5 f4 exf4": "King's Gambit Accepted",
      "e4 e5 f4 Bc5": "King's Gambit Declined: Classical Defense",
      "d4 Nf6 Bg5": "Trompowsky Attack",
      "d4 Nf6 Bg5 Ne4": "Trompowsky Attack: Main Line",
      "d4 d5 Nf3": "London System",
      "d4 d5 Nf3 Nf6 Bf4": "London System: Main Line",
      "e4 g6": "Modern Defense",
      "e4 g6 d4 Bg7": "Modern Defense: Gurgenidze System",
      "e4 g6 d4 Bg7 Nc3 d6": "Modern Defense: Pseudo-Austrian Attack",
      "e4 Nc6": "Nimzowitsch Defense",
      "e4 Nc6 d4 e5": "Nimzowitsch Defense: Scandinavian Variation",
      "d4 f5": "Dutch Defense",
      "d4 f5 g3": "Dutch Defense: Leningrad Variation",
      "d4 f5 Nf3 Nf6 g3 g6 Bg2 Bg7": "Dutch Defense: Leningrad System",
      "d4 f5 c4 Nf6": "Dutch Defense: Classical Variation",
      "d4 f5 e4": "Dutch Defense: Staunton Gambit",
      "f4": "Bird's Opening",
      "f4 d5": "Bird's Opening: From's Gambit",
      "f4 e5": "Bird's Opening: From Gambit",
      "e4 e5 Nf3 Nc6 Bb5 a6 Ba4 Nf6": "Ruy Lopez: Open Defense",
      "e4 e5 Nf3 Nc6 Bb5 a6 Ba4 Nf6 O-O Nxe4": "Ruy Lopez: Open Variation",
      "e4 e5 Nf3 Nc6 Bb5 a6 Ba4 Nf6 O-O Be7 Re1 b5 Bb3 d6": "Ruy Lopez: Closed, Zaitsev Variation",
      "e4 e5 Nf3 Nc6 Bb5 a6 Ba4 Nf6 O-O Be7 Re1 b5 Bb3 d6 c3 O-O": "Ruy Lopez: Closed, Breyer Variation",
      "e4 e5 Nf3 Nc6 Bb5 a6 Ba4 Nf6 O-O Nxe4 d4": "Ruy Lopez: Open, Howell Attack",
      "e4 e5 Nf3 Nc6 Bc4 Bc5 b4 Bxb4 c3": "Italian Game: Evans Gambit Accepted",
      "e4 e5 Nf3 Nc6 Bc4 Nf6 d4": "Italian Game: Two Knights Defense, Max Lange Attack",
      "e4 e5 Nf3 Nc6 Bc4 Nf6 Ng5": "Italian Game: Two Knights Defense, Fried Liver Attack",
      "e4 e5 Nf3 Nf6 Nxe5": "Petrov's Defense: Steinitz Attack",
      "e4 e5 Nf3 Nf6 Nxe5 d6": "Petrov's Defense: Classical Variation",
      "e4 e5 Nf3 Nf6 d4": "Petrov's Defense: Three Knights Game",
      "e4 c5 Nf3 d6 d4 cxd4 Nxd4 Nf6 Nc3 a6 Be3": "Sicilian Defense: Najdorf, English Attack",
      "e4 c5 Nf3 d6 d4 cxd4 Nxd4 Nf6 Nc3 a6 Be2": "Sicilian Defense: Najdorf, Classical Variation",
      "e4 c5 Nf3 d6 d4 cxd4 Nxd4 Nf6 Nc3 g6 Be3 Bg7": "Sicilian Defense: Dragon, Yugoslav Attack",
      "e4 c5 Nf3 e6 d4 cxd4 Nxd4 a6": "Sicilian Defense: Kan Variation",
      "e4 c5 Nf3 e6 d4 cxd4 Nxd4 Nc6": "Sicilian Defense: Taimanov Variation",
      "e4 c5 Nf3 e6 d4 cxd4 Nxd4 Nc6 Nc3 Qc7": "Sicilian Defense: Taimanov, English Attack",
      "e4 c5 Nf3 e6 c3": "Sicilian Defense: Smith-Morra Gambit",
      "e4 c5 Nf3 e6 c3 d5": "Sicilian Defense: Smith-Morra Gambit Declined",
      "e4 c5 c3 Nf6": "Sicilian Defense: Alapin, Barmen Variation",
      "e4 c5 c3 d5": "Sicilian Defense: Alapin, Normal Variation",
      "e4 e6 d4 d5 Nc3 Bb4": "French Defense: Winawer Variation",
      "e4 e6 d4 d5 Nc3 Bb4 e5": "French Defense: Winawer, Advance Variation",
      "e4 e6 d4 d5 Nc3 Bb4 e5 c5": "French Defense: Winawer, Poisoned Pawn",
      "e4 e6 d4 d5 Nc3 Nf6": "French Defense: Alekhine-Chatard Attack",
      "e4 e6 d4 d5 Nd2 c5": "French Defense: Tarrasch, Guimard Variation",
      "e4 e6 d4 d5 Nd2 Nf6": "French Defense: Tarrasch, Leningrad Variation",
      "e4 e6 d4 d5 exd5 exd5": "French Defense: Exchange, Classical Variation",
      "e4 c6 d4 d5 Nc3 dxe4 Nxe4 Bf5": "Caro-Kann Defense: Classical Variation",
      "e4 c6 d4 d5 Nc3 dxe4 Nxe4 Nd7": "Caro-Kann Defense: Karpov Variation",
      "e4 c6 d4 d5 Nc3 dxe4 Nxe4 Bf5 Ng3 Bg6": "Caro-Kann Defense: Classical, Main Line",
      "e4 c6 d4 d5 Nc3 dxe4 Nxe4 Nd7 Nf3 Ngf6": "Caro-Kann Defense: Karpov, Main Line",
      "e4 d5 exd5 Nf6 c4 e6": "Scandinavian Defense: Modern, Main Line",
      "e4 d5 exd5 Qxd5 Nc3 Qa5": "Scandinavian Defense: Main Line, Gubinsky-Melts Defense",
      "e4 d5 exd5 Qxd5 Nc3 Qd6": "Scandinavian Defense: Main Line, Modern Variation",
      "d4 d5 c4 e6 Nf3": "Queen's Gambit Declined: Orthodox",
      "d4 d5 c4 e6 Nf3 Nf6": "Queen's Gambit Declined: Orthodox, Main Line",
      "d4 d5 c4 e6 Nf3 Nf6 Nc3 Be7": "Queen's Gambit Declined: Orthodox, Classical",
      "d4 d5 c4 e6 Nf3 Nf6 Nc3 Be7 Bg5": "Queen's Gambit Declined: Orthodox, Tartakower Variation",
      "d4 d5 c4 e6 Nf3 Nf6 cxd5": "Queen's Gambit Declined: Exchange Variation",
      "d4 d5 c4 c6 Nf3 Nf6 e3": "Slav Defense: Quiet Variation",
      "d4 d5 c4 c6 Nf3 Nf6 Nc3 dxc4 a4": "Slav Defense: Alekhine Variation",
      "d4 d5 c4 c6 Nf3 Nf6 e3 Bf5": "Slav Defense: Modern Variation",
      "d4 d5 c4 c6 Nf3 Nf6 Nc3 e6 Bg5": "Semi-Slav Defense: Botvinnik Variation",
      "d4 d5 c4 c6 Nf3 Nf6 Nc3 e6 e3": "Semi-Slav Defense: Meran Variation",
      "d4 Nf6 c4 g6 Nc3 Bg7 e4 d6": "King's Indian Defense: Classical, Main Line",
      "d4 Nf6 c4 g6 Nc3 Bg7 e4 d6 Nf3 O-O Be2 e5": "King's Indian Defense: Classical, Petrosian System",
      "d4 Nf6 c4 g6 Nc3 Bg7 e4 d6 f3": "King's Indian Defense: S√§misch Variation",
      "d4 Nf6 c4 g6 Nc3 Bg7 e4 d6 f4": "King's Indian Defense: Four Pawns Attack",
      "d4 Nf6 c4 g6 Nc3 Bg7 e4 d6 Nge2": "King's Indian Defense: Averbakh Variation",
      "d4 Nf6 c4 g6 Nf3 Bg7": "King's Indian Defense: Fianchetto Variation",
      "d4 Nf6 c4 e6 Nc3 Bb4 a3": "Nimzo-Indian Defense: Samisch Variation",
      "d4 Nf6 c4 e6 Nc3 Bb4 Nf3": "Nimzo-Indian Defense: Classical, Ragozin Defense",
      "d4 Nf6 c4 e6 Nc3 Bb4 Nf3 c5": "Nimzo-Indian Defense: Classical, H√ºbner Variation",
      "d4 Nf6 c4 e6 Nf3 b6 g3": "Queen's Indian Defense: Fianchetto Variation",
      "d4 Nf6 c4 e6 Nf3 b6 a3": "Queen's Indian Defense: Petrosian Variation",
      "d4 Nf6 c4 e6 Nf3 b6 Nc3": "Queen's Indian Defense: Classical Variation",
      "d4 Nf6 c4 c5 d5 b5": "Benoni Defense: Modern, Benko Gambit",
      "d4 Nf6 c4 c5 d5 b5 cxb5 a6": "Benoni Defense: Modern, Benko Gambit Accepted",
      "d4 Nf6 c4 c5 d5 e5": "Benoni Defense: Czech Benoni",
      "Nf3 d5 d4": "R√©ti Opening: Slav System",
      "Nf3 d5 c4 d4": "R√©ti Opening: Slav, Alapin Variation",
      "Nf3 Nf6 c4 c5": "R√©ti Opening: Symmetrical Variation",
      "Nf3 Nf6 c4 e6": "R√©ti Opening: English Defense",
      "c4 e5 Nc3": "English Opening: Reversed Dragon",
      "c4 e5 Nc3 Nf6": "English Opening: Reversed Dragon, Yugoslav Attack",
      "c4 Nf6 Nc3 e5": "English Opening: Symmetrical, Botvinnik System",
      "c4 c5 Nf3": "English Opening: Symmetrical, Hedgehog System",
      "e4 e5 Nf3 Nc6 d4 exd4 Nxd4 Nf6": "Scotch Game: Schmidt Variation",
      "e4 e5 Nf3 Nc6 d4 exd4 Nxd4 Bc5": "Scotch Game: Classical Variation",
      "e4 e5 Nf3 Nc6 Nc3 Nf6 Bb5": "Four Knights Game: Spanish Variation",
      "e4 e5 Nf3 Nc6 Nc3 Nf6 Bb5 Nd4": "Four Knights Game: Spanish, Rubinstein Variation",
      "e4 e5 Nf3 Nc6 Nc3 Nf6 d4": "Four Knights Game: Scotch Variation",
      "e4 e5 Nc3": "Vienna Game",
      "e4 e5 Nc3 Nf6": "Vienna Game: Falkbeer Variation",
      "e4 e5 Nc3 Nf6 f4": "Vienna Game: Gambit",
      "e4 e5 Nc3 Bc5": "Vienna Game: Frankenstein-Dracula Variation",
      "e4 e5 Bc4": "Bishop's Opening",
      "e4 e5 Bc4 Nf6": "Bishop's Opening: Berlin Defense",
      "e4 e5 Bc4 Nc6": "Bishop's Opening: Classical Defense",
      "e4 e5 Nf3 Nc6 Bc4 Bc5 d3": "Italian Game: Giuoco Pianissimo, Main Line",
      "e4 e5 Nf3 Nc6 Bc4 Bc5 O-O": "Italian Game: Giuoco Pianissimo, Modern Variation",
      "e4 e5 f4 exf4 Nf3": "King's Gambit: Accepted, Modern Defense",
      "e4 e5 f4 exf4 Nf3 g5": "King's Gambit: Accepted, Classical Defense",
      "e4 e5 f4 exf4 Nf3 g5 h4": "King's Gambit: Accepted, Allgaier Gambit",
      "e4 e5 f4 exf4 Nc3": "King's Gambit: Accepted, Quade Gambit",
      "e4 e5 f4 Bc5": "King's Gambit: Declined, Classical Defense",
      "e4 e5 f4 d5": "King's Gambit: Declined, Falkbeer Countergambit",
      "d4 d5 Nf3 Nf6 Bf4": "London System: Main Line",
      "d4 d5 Nf3 Nf6 Bf4 c5": "London System: Normal Variation",
      "d4 d5 Nf3 Nf6 Bf4 Bf5": "London System: Symmetrical Variation",
      "d4 Nf6 Bg5 c5": "Trompowsky Attack: Classical Defense",
      "d4 Nf6 Bg5 Ne4 Bf4": "Trompowsky Attack: Raptor Variation",
      "d4 Nf6 Bg5 e6": "Trompowsky Attack: French Variation",
      "d4 Nf6 Nf3 e6 c4": "Indian Defense: Nimzowitsch Variation",
      "d4 Nf6 Nf3 e6 c4 Bb4+": "Indian Defense: Bogo-Indian Defense",
      "d4 Nf6 Nf3 e6 c4 Bb4+ Bd2": "Bogo-Indian Defense: Modern Variation",
      "d4 Nf6 c4 e6 Nc3 Bb4 Qb3": "Nimzo-Indian Defense: Spielmann Variation",
      "d4 Nf6 c4 e6 Nc3 Bb4 e3 O-O": "Nimzo-Indian Defense: Capablanca Variation",
      "d4 Nf6 c4 e6 Nc3 Bb4 a3 Bxc3+": "Nimzo-Indian Defense: Samisch, Main Line",
      "d4 Nf6 c4 e6 Nc3 Bb4 a3 Bxc3+ bxc3": "Nimzo-Indian Defense: Samisch, Orthodox",
      "e4 e5 Nf3 Nc6 d3": "King's Pawn Opening: R√©ti System",
      "e4 e5 Nf3 Nc6 Be2": "King's Pawn Opening: Modern Variation",
      "e4 e5 Nf3 Nc6 g3": "King's Pawn Opening: Konstantinopolsky Variation",
      "e4 e5 Nf3 Nc6 c3": "King's Pawn Opening: Ponziani Opening",
      "e4 e5 Nf3 Nc6 c3 d5": "Ponziani Opening: Steinitz Variation",
      "d4 d5 c4 c5": "Queen's Gambit: Slav, Marshall Gambit",
      "d4 d5 c4 e5": "Queen's Gambit: Albin Countergambit",
      "d4 d5 c4 e5 dxe5 d4": "Queen's Gambit: Albin Countergambit Accepted",
      "d4 d5 Nf3": "Queen's Pawn Opening: Zukertort Opening",
      "d4 Nf6": "Indian Game: Wade-Tartakower Defense",
      "Nf3 d5": "Zukertort Opening: Dutch Variation",
      "Nf3 d5 c4": "R√©ti Opening: Anglo-Slav, Main Line",
      "Nf3 d5 g3": "R√©ti Opening: Fianchetto Variation",
      "b4": "Sokolsky Opening (Orangutan)",
      "b4 e5": "Sokolsky Opening: Outflank Variation",
      "b4 c6": "Sokolsky Opening: Outflank Defense",
      "g4": "Grob Opening",
      "g4 d5": "Grob Opening: Spike Attack",
      "Nc3": "Dunst Opening",
      "Nc3 d5": "Dunst Opening: Normal Defense",
      "Nc3 e5": "Dunst Opening: Sicilian Variation",
      "e3": "Van't Kruijs Opening",
      "e3 d5": "Van't Kruijs Opening: Normal Defense",
      "d3": "Mieses Opening",
      "d3 d5": "Mieses Opening: Reversed Philidor",
      "a4": "Ware Opening",
      "a4 e5": "Ware Opening: Crab Variation",
      "h4": "Kadas Opening",
      "h4 e5": "Kadas Opening: Normal Defense",
      "Na3": "Durkin Opening",
      "f3": "Barnes Opening",
      "f3 e5": "Barnes Opening: Gedult Attack",
      "Nh3": "Amar Opening",
      "b3": "Larsen Opening",
      "b3 e5": "Larsen Opening: Classical Variation",
      "g3": "Benko Opening",
      "g3 d5": "Benko Opening: Reversed Alekhine",
      "c3": "Saragossa Opening",
      "c3 e5": "Saragossa Opening: Normal Variation",
      "b3": "Larsen's Opening (Queen's Fianchetto)"
    };

    // --- sendEngineCommand function ---
    function sendEngineCommand(endpoint) {
    // Key change: Add 'return' here to return the promise chain
    return fetch(`https://hedgehoglover23.pythonanywhere.com/${endpoint}`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({})
    })
    .then(response => {
        if (!response.ok) {
            return response.json().then(err => {
                throw new Error(`Server error for /${endpoint}: ${err.message || response.statusText}`);
            }).catch(() => {
                throw new Error(`Server error for /${endpoint}: ${response.status} ${response.statusText}`);
            });
        }
        return response.json(); // This 'return' passes the parsed data down
    })
    .then(data => {
        console.log(`Command /${endpoint} successful:`, data.message || data.status || data);
        return data; // This 'return data' is correct for the internal chain
    })
    .catch(error => {
        console.error(`Error sending command /${endpoint}:`, error);
        throw error; // Propagate the error so the awaiting function can catch it
    });
}

    function toggleHistoryOption() {
      const blindfoldChecked = document.getElementById("blindfold-mode").checked;
      const historyRow = document.getElementById("show-history-row");
      if (blindfoldChecked) {
        historyRow.style.display = "inline-block";
      } else {
        historyRow.style.display = "none";
      }
    }

    function updateCustomModifiers() {
      // Helper function to clamp values between 0 and 3
      const clampValue = (value) => {
        const num = parseFloat(value);
        if (isNaN(num)) return 1.0;
        return Math.max(0, Math.min(3, num));
      };
      
      // Get values and clamp them
      const material = clampValue(document.getElementById('mod-material').value);
      const kingSafety = clampValue(document.getElementById('mod-king-safety').value);
      const centralization = clampValue(document.getElementById('mod-centralization').value);
      const attack = clampValue(document.getElementById('mod-attack').value);
      const pieceActivity = clampValue(document.getElementById('mod-piece-activity').value);
      const defense = clampValue(document.getElementById('mod-defense').value);
      const pawnStructure = clampValue(document.getElementById('mod-pawn-structure').value);
      
      // Update input fields with clamped values
      document.getElementById('mod-material').value = material.toFixed(1);
      document.getElementById('mod-king-safety').value = kingSafety.toFixed(1);
      document.getElementById('mod-centralization').value = centralization.toFixed(1);
      document.getElementById('mod-attack').value = attack.toFixed(1);
      document.getElementById('mod-piece-activity').value = pieceActivity.toFixed(1);
      document.getElementById('mod-defense').value = defense.toFixed(1);
      document.getElementById('mod-pawn-structure').value = pawnStructure.toFixed(1);
      
      // Update the custom personality in enginePersonalities object
      enginePersonalities.custom.material = material;
      enginePersonalities.custom.king_safety_b = kingSafety;
      enginePersonalities.custom.king_safety_w = kingSafety;
      enginePersonalities.custom.centralization_b = centralization;
      enginePersonalities.custom.centralization_w = centralization;
      enginePersonalities.custom.attack_b = attack;
      enginePersonalities.custom.attack_w = attack;
      enginePersonalities.custom.piece_activity_b = pieceActivity;
      enginePersonalities.custom.piece_activity_w = pieceActivity;
      enginePersonalities.custom.defense_b = defense;
      enginePersonalities.custom.defense_w = defense;
      enginePersonalities.custom.pawn_structure_b = pawnStructure;
      enginePersonalities.custom.pawn_structure_w = pawnStructure;
      
      // Save to localStorage
      localStorage.setItem('customModifiers', JSON.stringify({
        material: material,
        king_safety: kingSafety,
        centralization: centralization,
        attack: attack,
        piece_activity: pieceActivity,
        defense: defense,
        pawn_structure: pawnStructure
      }));
      
      // Apply modifiers in real-time
      applyEngineModifiers('custom');
    }

    function resetCustomModifiers() {
      document.getElementById('mod-material').value = 1.0;
      document.getElementById('mod-king-safety').value = 1.0;
      document.getElementById('mod-centralization').value = 1.0;
      document.getElementById('mod-attack').value = 1.0;
      document.getElementById('mod-piece-activity').value = 1.0;
      document.getElementById('mod-defense').value = 1.0;
      document.getElementById('mod-pawn-structure').value = 1.0;
      updateCustomModifiers();
    }

    function loadCustomModifiers() {
      const saved = localStorage.getItem('customModifiers');
      if (saved) {
        const custom = JSON.parse(saved);
        document.getElementById('mod-material').value = custom.material || 1.0;
        document.getElementById('mod-king-safety').value = custom.king_safety || 1.0;
        document.getElementById('mod-centralization').value = custom.centralization || 1.0;
        document.getElementById('mod-attack').value = custom.attack || 1.0;
        document.getElementById('mod-piece-activity').value = custom.piece_activity || 1.0;
        document.getElementById('mod-defense').value = custom.defense || 1.0;
        document.getElementById('mod-pawn-structure').value = custom.pawn_structure || 1.0;
        updateCustomModifiers();
      }
    }

    function toggleHistoryOption() {
      const blindfoldChecked = document.getElementById("blindfold-mode").checked;
      const historyRow = document.getElementById("show-history-row");
      if (blindfoldChecked) {
        historyRow.style.display = "inline-block";
      } else {
        historyRow.style.display = "none";
        document.getElementById("show-history").checked = false;
      }
    }

    function changeBoardStyle() {
      const style = document.getElementById("board-style").value;
      const boardElement = document.getElementById("board");
      
      // Remove all theme classes
      boardElement.className = boardElement.className.replace(/board-theme-\w+/g, '').trim();
      
      // Add new theme class
      boardElement.classList.add(`board-theme-${style}`);
      
      // Save preference to localStorage
      localStorage.setItem('chessboardStyle', style);
    }

    function changeEngineStyle() {
      const style = document.getElementById("engine-style").value;
      const selector = document.getElementById("engine-style");
      const customPanel = document.getElementById("custom-modifiers-panel");
      currentEngineStyle = style;
      
      // Remove all personality classes
      selector.className = selector.className.replace(/personality-\w+/g, '').trim();
      
      // Add new personality class for color
      selector.classList.add('personality-' + style);
      
      // Show/hide custom modifiers panel
      if (style === 'custom') {
        customPanel.style.display = 'block';
        loadCustomModifiers();
      } else {
        customPanel.style.display = 'none';
      }
      
      // Save preference to localStorage
      localStorage.setItem('enginePersonality', style);
      
      // Apply modifiers to engine
      applyEngineModifiers(style);
    }

    async function applyEngineModifiers(personality) {
      const baseModifiers = enginePersonalities[personality];
      
      if (!baseModifiers) {
        console.error('Unknown engine personality:', personality);
        return;
      }

      // Determine which color the engine is playing
      const engineColor = playerColor === 'white' ? 'black' : 'white';
      // NOTE: Code internals are reversed from board!
      // _b modifiers = WHITE pieces on board, _w modifiers = BLACK pieces on board
      const engineSuffix = engineColor === 'black' ? '_w' : '_b';
      const playerSuffix = engineColor === 'black' ? '_b' : '_w';

      // Build asymmetric modifiers: engine gets personality, player gets balanced (1.0)
      const modifiers = {
        material: baseModifiers.material, // Material is symmetric
      };

      // For each personality trait, apply it to engine's color only
      const traits = ['king_safety', 'centralization', 'attack', 'piece_activity', 'defense', 'pawn_structure'];
      
      traits.forEach(trait => {
        // Engine's color gets the personality modifier
        modifiers[trait + engineSuffix] = baseModifiers[trait + engineSuffix];
        // Player's color gets balanced modifier (1.0)
        modifiers[trait + playerSuffix] = 1.0;
      });

      console.log('Applying asymmetric modifiers:', {
        personality,
        engineColor,
        engineSuffix,
        playerSuffix,
        engineModifiers: modifiers
      });

      try {
        const response = await fetch('https://hedgehoglover23.pythonanywhere.com/modifiers', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(modifiers)
        });

        if (response.ok) {
          const data = await response.json();
          console.log('Engine modifiers updated (asymmetric):', data);
        } else {
          console.error('Failed to update engine modifiers:', response.statusText);
        }
      } catch (error) {
        console.error('Error updating engine modifiers:', error);
      }
    }

    function changePieceStyle() {
      const style = document.getElementById("piece-style").value;
      currentPieceStyle = style;
      
      // Save preference to localStorage
      localStorage.setItem('chessPieceStyle', style);
      
      // If board exists, update the piece theme
      if (board) {
        const currentPosition = board.position();
        board.destroy();
        
        // Check if game is active or preview mode
        const isGameStarted = document.getElementById("choose-side").style.display === "none";
        
        if (isGameStarted && game && !gameOver) {
          // Game is active - recreate with full handlers
          recreateBoard();
        } else {
          // Preview mode - recreate preview board
          board = Chessboard('board', {
            draggable: false,
            position: currentPosition,
            orientation: 'white',
            pieceTheme: pieceThemes[currentPieceStyle]
          });
        }
        board.position(currentPosition);
      }
    }

    function recreateBoard() {
      board = Chessboard("board", {
        draggable: true,
        position: game ? game.fen() : "start",
        orientation: playerColor,
        snapSpeed: 50,
        snapbackSpeed: 50,
        appearSpeed: 0,
        moveSpeed: 100,
        trashSpeed: 50,
        dragThrottleRate: 0,
        sparePieces: false,
        dropOffBoard: 'snapback',
        onDragStart: (source, piece, position, orientation) => {
          if (game.game_over() || gameOver) {
            const sourceSquare = $(`#board .square-${source}`);
            sourceSquare.addClass('illegal-move');
            setTimeout(() => sourceSquare.removeClass('illegal-move'), 600);
            return false;
          }
          const turn = game.turn();
          if ((playerColor === "white" && turn !== "w") || (playerColor === "black" && turn !== "b")) {
            const sourceSquare = $(`#board .square-${source}`);
            sourceSquare.addClass('illegal-move');
            setTimeout(() => sourceSquare.removeClass('illegal-move'), 600);
            return false;
          }
          if ((turn === 'w' && piece.search(/^b/) !== -1) || (turn === 'b' && piece.search(/^w/) !== -1)) {
            const sourceSquare = $(`#board .square-${source}`);
            sourceSquare.addClass('illegal-move');
            setTimeout(() => sourceSquare.removeClass('illegal-move'), 600);
            return false;
          }
          highlightLegalMoves(source);
        },
        onDragMove: (newLocation, oldLocation, source, piece, position, orientation) => {
          $("#board .square-55d63").removeClass("legal-target");
          const moves = game.moves({ square: source, verbose: true });
          const isLegal = moves.some(move => move.to === newLocation);
          if (isLegal) {
            $(`#board .square-${newLocation}`).addClass("legal-target");
          }
        },
        onDrop: handleMove,
        onSnapEnd: () => {
          removeHighlights();
          $("#board .square-55d63").removeClass("legal-target");
        },
        pieceTheme: pieceThemes[currentPieceStyle],
      });
    }

 $(document).ready(function() {
	 		
        console.log("The page has finished loading!");

        // Load saved board style
        const savedStyle = localStorage.getItem('chessboardStyle') || 'classic';
        document.getElementById('board-style').value = savedStyle;
        changeBoardStyle();

        // Load saved piece style
        const savedPieceStyle = localStorage.getItem('chessPieceStyle') || 'wikipedia';
        currentPieceStyle = savedPieceStyle;
        document.getElementById('piece-style').value = savedPieceStyle;

        // Load saved engine personality
        const savedEngineStyle = localStorage.getItem('enginePersonality') || 'balanced';
        currentEngineStyle = savedEngineStyle;
        const engineStyleSelect = document.getElementById('engine-style');
        engineStyleSelect.value = savedEngineStyle;
        // Apply personality color on load
        engineStyleSelect.classList.add('personality-' + savedEngineStyle);
        
        // Show custom panel if custom personality was selected
        if (savedEngineStyle === 'custom') {
          document.getElementById('custom-modifiers-panel').style.display = 'block';
          loadCustomModifiers();
        }

        // Initialize game object for preview board
        game = new Chess();
        gameOver = false;
        playerColor = "white"; // Default for preview

        // Create preview board with dragging enabled
        board = Chessboard('board', {
          draggable: false,
          position: 'start',
          orientation: 'white',
          pieceTheme: pieceThemes[currentPieceStyle]
        });
        
        console.log('Preview board created with config:', {
          draggable: false
        });
        
        // Show the board container
        document.getElementById('board-timers-container').style.display = 'flex';

        // --- AUTOMATIC LOGIC: Stop then Start the engine on page load ---
        console.log("Attempting to stop and then start the engine automatically on page load...");
        sendEngineCommand('stop')
            .then(() => {
                console.log("Stop command sent successfully. Now sending start command...");
                return sendEngineCommand('start');
            })
            .then(() => {
                console.log("Start command sent successfully. Engine should be reset and running.");
            })
            .catch(error => {
                console.error("Error during automatic engine reset on page load:", error);
                // Replaced alert() with a console log
                console.error("Failed to automatically reset engine on page load. Check console for details.");
            });
    });

        $(document).keydown(function(e) {
            if (!blindfoldMode && board && moveHistory.length > 0) {
                if (e.key === 'ArrowLeft' || e.keyCode === 37) {
                    e.preventDefault();
                    navigateToPreviousMove();
                } else if (e.key === 'ArrowRight' || e.keyCode === 39) {
                    e.preventDefault();
                    navigateToNextMove();
                } else if (e.key === 'ArrowUp' || e.keyCode === 38) {
                    e.preventDefault();
                    navigateToStart();
                } else if (e.key === 'ArrowDown' || e.keyCode === 40) {
                    e.preventDefault();
                    navigateToCurrent();
                }
            }
        });
    function formatTime(ms) {
      const t = Math.max(0, Math.floor(ms));
      const totalHundredths = Math.floor(t / 10);
      const minutes = String(Math.floor(totalHundredths / 6000)).padStart(2, "0");
      const seconds = String(Math.floor((totalHundredths % 6000) / 100)).padStart(2, "0");
      const hundredths = String(totalHundredths % 100).padStart(2, "0");
      return `${minutes}:${seconds}.${hundredths}`;
    }
    
    function updateClockStyles() {
        const turn = game.turn();
        const playerIsWhite = playerColor === 'white';
        
        // Determine which slot is the player's and which is the engine's
        const playerSlot = playerIsWhite ? document.getElementById("time-slot-white") : document.getElementById("time-slot-black");
        const engineSlot = playerIsWhite ? document.getElementById("time-slot-black") : document.getElementById("time-slot-white");
        
        // Remove active class from both
        playerSlot.classList.remove('time-active');
        engineSlot.classList.remove('time-active');

        // Add active class only to the player's clock when it's their turn
        if ((playerIsWhite && turn === 'w') || (!playerIsWhite && turn === 'b')) {
            playerSlot.classList.add('time-active');
        }
    }


    // MODIFIED: Timer always counts up, but only deducts time if it's the player's turn.
    function startTimer() {
      clearInterval(timerInterval);
      timerStart = performance.now();

      const turn = game.turn();
      const isPlayerTurn = (playerColor === "white" && turn === "w") || (playerColor === "black" && turn === "b");
      
      // Update clock styling (active state)
      updateClockStyles();

      // MODIFICATION START: Set player's time to its value and engine's time to "Unlimited"
      if (timeLimited) {
          // Determine element IDs and time references
          const playerTotalId = playerColor === 'white' ? "white-total" : "black-total";
          const engineTotalId = playerColor === 'white' ? "black-total" : "white-total";
          const playerTimeRef = playerColor === 'white' ? whiteTime : blackTime;
          
          // Set player's time display
          document.getElementById(playerTotalId).textContent = formatTime(playerTimeRef);
          
          // Set engine's time display to "Unlimited"
          document.getElementById(engineTotalId).textContent = "Unlimited";
      }
      // MODIFICATION END
      
      timerInterval = setInterval(() => {
          if (gameOver) {
              clearInterval(timerInterval);
              return;
          }

        const elapsed = performance.now() - timerStart;

        // 1. Always update the move timer display (Counts up)
        document.getElementById("timer").textContent = formatTime(elapsed);

        // 2. ONLY manage total time deduction/check if it's time limited AND the player's turn
        if (timeLimited && isPlayerTurn) {
            const totalTimeElementId = playerColor === 'white' ? "white-total" : "black-total";
            const playerTimeRef = playerColor === 'white' ? whiteTime : blackTime;
            
            const newTime = playerTimeRef - elapsed;

            // Update the player's total remaining time (countdown)
            document.getElementById(totalTimeElementId).textContent = formatTime(newTime);
            
            if (newTime <= 0) {
                clearInterval(timerInterval);
                // Replaced alert() with UI message
                const moveContainer = document.getElementById("move-timer-container");
                moveContainer.innerHTML = 'TIME OUT! <span style="color:red;">You lose!</span>';
                gameOver = true;
            }
        }
      }, 10);
    }

    // UNMODIFIED Logic, only checking if the color that just moved was the player's color
    function stopTimerAndUpdateTotal(color) {
      clearInterval(timerInterval);
      const elapsed = performance.now() - timerStart;
      if (timeLimited) {
        if (
          (color === "w" && playerColor === "white") ||
          (color === "b" && playerColor === "black")
          ) {
          if (color === "w") {
            whiteTime = Math.max(0, whiteTime - elapsed);
            whiteTime += increment * 1000;
            document.getElementById("white-total").textContent = formatTime(whiteTime);
          } else {
            blackTime = Math.max(0, blackTime - elapsed);
            blackTime += increment * 1000;
            document.getElementById("black-total").textContent = formatTime(blackTime);
          }
        }
      }
      return elapsed;
    }

function navigateToPreviousMove() {
      if (currentMoveIndex === -1 && moveHistory.length > 0) {
        currentMoveIndex = moveHistory.length - 2;
        if (currentMoveIndex < 0) currentMoveIndex = 0;
        displayPositionAtIndex(currentMoveIndex);
      } else if (currentMoveIndex === 0) {
        currentMoveIndex = -2;
        board.position('start');
        updateMoveHighlight();
      } else if (currentMoveIndex > 0) {
        currentMoveIndex--;
        displayPositionAtIndex(currentMoveIndex);
      }
    }

    function navigateToNextMove() {
      if (currentMoveIndex === -2 && moveHistory.length > 0) {
        currentMoveIndex = 0;
        displayPositionAtIndex(currentMoveIndex);
      } else if (currentMoveIndex === -1) {
        // Already at current position, do nothing
        return;
      } else if (currentMoveIndex < moveHistory.length - 1) {
        currentMoveIndex++;
        displayPositionAtIndex(currentMoveIndex);
      } else if (currentMoveIndex === moveHistory.length - 1) {
        currentMoveIndex = -1;
        board.position(game.fen());
        updateMoveHighlight();
      }
    }

    function navigateToStart() {
      currentMoveIndex = -2;
      board.position('start');
      updateMoveHighlight();
    }

    function navigateToCurrent() {
      currentMoveIndex = -1;
      board.position(game.fen());
      updateMoveHighlight();
    }

    function displayPositionAtIndex(index) {
      if (index >= 0 && index < moveHistory.length) {
        board.position(moveHistory[index]);
        updateMoveHighlight();
      }
    }

    function updateMoveHighlight() {
      $('.move-item').removeClass('highlighted');
      if (currentMoveIndex >= 0 && currentMoveIndex < moveHistory.length) {
        $(`.move-item[data-move-index="${currentMoveIndex}"]`).addClass('highlighted');
      }
    }

    function updateNotationDisplay() {
      const history = game.history();
      const container = document.getElementById("notation-container");
      container.innerHTML = '';
      // Dynamic height: expands up to board height as moves are played
      const minHeight = 60;
      const maxHeight = 450;
      const basePadding = 35;
      let dynHeight = minHeight + Math.min(history.length * 16, maxHeight-minHeight);
      dynHeight = Math.max(minHeight, Math.min(dynHeight, maxHeight));
      container.style.minHeight = minHeight + 'px';
      container.style.height = dynHeight + 'px';
      container.style.maxHeight = maxHeight + 'px';
      // Group moves by full move (White + Black)
      for (let i = 0; i < history.length; i += 2) {
        const moveNum = Math.floor(i / 2) + 1;
        const moveRow = document.createElement('div');
        moveRow.style.marginBottom = '4px';
        moveRow.style.display = 'flex';
        moveRow.style.alignItems = 'center';
        moveRow.style.gap = '8px';
        
        // Move number
        const moveNumSpan = document.createElement('span');
        moveNumSpan.className = 'move-number';
        moveNumSpan.textContent = moveNum + '.';
        moveNumSpan.style.fontWeight = '600';
        moveNumSpan.style.minWidth = '30px';
        moveNumSpan.style.color = '#7f8c8d';
        moveRow.appendChild(moveNumSpan);
        
        // White move
        const whiteMove = history[i];
        if (whiteMove) {
          const whiteSpan = document.createElement('span');
          whiteSpan.className = 'move-item';
          if (currentMoveIndex === i || (currentMoveIndex === -1 && i === history.length - 1)) {
            whiteSpan.classList.add('highlighted');
          }
          whiteSpan.setAttribute('data-move-index', i);
          whiteSpan.onclick = function() { jumpToMove(i); };
          whiteSpan.textContent = whiteMove;
          whiteSpan.style.cursor = 'pointer';
          whiteSpan.style.padding = '2px 6px';
          whiteSpan.style.borderRadius = '4px';
          whiteSpan.style.transition = 'background-color 0.2s';
          whiteSpan.onmouseover = function() { this.style.backgroundColor = '#ecf0f1'; };
          whiteSpan.onmouseout = function() { if (!this.classList.contains('highlighted')) this.style.backgroundColor = 'transparent'; };
          moveRow.appendChild(whiteSpan);
        }
        
        // Black move
        const blackMove = history[i + 1];
        if (blackMove) {
          const blackSpan = document.createElement('span');
          blackSpan.className = 'move-item';
          if (currentMoveIndex === i + 1 || (currentMoveIndex === -1 && i + 1 === history.length - 1)) {
            blackSpan.classList.add('highlighted');
          }
          blackSpan.setAttribute('data-move-index', i + 1);
          blackSpan.onclick = function() { jumpToMove(i + 1); };
          blackSpan.textContent = blackMove;
          blackSpan.style.cursor = 'pointer';
          blackSpan.style.padding = '2px 6px';
          blackSpan.style.borderRadius = '4px';
          blackSpan.style.transition = 'background-color 0.2s';
          blackSpan.onmouseover = function() { this.style.backgroundColor = '#ecf0f1'; };
          blackSpan.onmouseout = function() { if (!this.classList.contains('highlighted')) this.style.backgroundColor = 'transparent'; };
          moveRow.appendChild(blackSpan);
        }
        
        container.appendChild(moveRow);
      }
    }
    
    function jumpToMove(index) {
      if (!blindfoldMode && index >= 0 && index < moveHistory.length) {
        currentMoveIndex = index;
        displayPositionAtIndex(index);
      }
    }

    function updateLastMove(move, timeStr, color, move_number) {
      const txt = move ? `${move} (${timeStr})` : "None";
      document.getElementById("last-move").textContent = txt;

      if (move) {
        moveHistory.push(game.fen());
        currentMoveIndex = -1;
        updateNotationDisplay();
        // Update move number (full move number, not half-move)
        const moveNum = Math.ceil(game.history().length / 2);
        document.getElementById("move-number").textContent = moveNum;
      }
}

    function updateTurnDisplay() {
      document.getElementById("turn-color").textContent = game.turn() === "w" ? "White" : "Black";
    }

    function highlightLegalMoves(square) {
      const moves = game.moves({ square, verbose: true });
      for (const move of moves) {
        $(`#board .square-${move.to}`).addClass("highlight-legal");
      }
    }

    function removeHighlights() {
      // Don't remove highlights if a piece is selected for click-to-move
      if (!selectedSquare) {
        $("#board .square-55d63").removeClass("highlight-legal");
      }
    }

    function isPremoveLegal(from, to, piece) {
      // Validate if a premove would be theoretically legal for this piece type
      // on an empty board (or for pawns, with diagonal capture squares occupied)
      
      const fromFile = from.charCodeAt(0) - 'a'.charCodeAt(0);
      const fromRank = parseInt(from[1]) - 1;
      const toFile = to.charCodeAt(0) - 'a'.charCodeAt(0);
      const toRank = parseInt(to[1]) - 1;
      
      const fileDiff = Math.abs(toFile - fromFile);
      const rankDiff = Math.abs(toRank - fromRank);
      const fileDir = toFile - fromFile;
      const rankDir = toRank - fromRank;
      
      const pieceType = piece.type;
      const pieceColor = piece.color;
      
      switch(pieceType) {
        case 'p': // Pawn
          const direction = pieceColor === 'w' ? 1 : -1;
          const startRank = pieceColor === 'w' ? 1 : 6;
          
          // Forward one square
          if (fileDir === 0 && rankDir === direction) return true;
          
          // Forward two squares from starting position
          if (fileDir === 0 && rankDir === 2 * direction && fromRank === startRank) return true;
          
          // Diagonal capture (always allow for premoves since we assume piece could be there)
          if (fileDiff === 1 && rankDir === direction) return true;
          
          return false;
          
        case 'n': // Knight
          return (fileDiff === 2 && rankDiff === 1) || (fileDiff === 1 && rankDiff === 2);
          
        case 'b': // Bishop
          return fileDiff === rankDiff && fileDiff > 0;
          
        case 'r': // Rook
          return (fileDiff === 0 && rankDiff > 0) || (rankDiff === 0 && fileDiff > 0);
          
        case 'q': // Queen
          return (fileDiff === rankDiff && fileDiff > 0) || // Diagonal
                 (fileDiff === 0 && rankDiff > 0) ||        // Vertical
                 (rankDiff === 0 && fileDiff > 0);          // Horizontal
          
        case 'k': // King
          return fileDiff <= 1 && rankDiff <= 1 && (fileDiff > 0 || rankDiff > 0);
          
        default:
          return false;
      }
    }

    function clearPremove() {
      if (premoves.length > 0 && board) {
        // Restore board position when clearing premoves since we actually moved pieces
        board.position(game.fen());
      }
      premoves = [];
      selectedSquare = null;
      $("#board .square-55d63").removeClass("premove-highlight premove-source");
    }
    
    // Helper function to update board visual with all premoves applied
    function updatePremoveVisual() {
      if (!board || !game) return;
      
      if (premoves.length === 0) {
        board.position(game.fen());
        $("#board .square-55d63").removeClass("premove-highlight premove-source");
        return;
      }
      
      // Always start from the actual game position
      // First, reset board to actual game position to get clean state
      board.position(game.fen());
      
      // Use requestAnimationFrame to ensure board has updated, then apply premoves
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          const pos = board.position();
          if (!pos || Object.keys(pos).length === 0) {
            // If position is empty, try to get it directly from game.fen() by setting it again
            board.position(game.fen());
            setTimeout(() => updatePremoveVisual(), 50);
            return;
          }
          
          // Create a deep copy of the position object
          const newPos = {};
          for (const square in pos) {
            newPos[square] = pos[square];
          }
          
          // Track all squares involved in premoves for highlighting
          const highlightSquares = [];
          
          // Manually apply all premoves to show them visually
          // For each premove in sequence, move the piece from source to destination
          for (const pm of premoves) {
            const piece = newPos[pm.from];
            if (piece) {
              // Remove piece from source
              delete newPos[pm.from];
              // Place piece on destination (overwriting anything there, as premoves can capture)
              newPos[pm.to] = piece;
              // Track squares for highlighting (both source and destination)
              highlightSquares.push({ from: pm.from, to: pm.to });
            }
          }
          
          // Update board to show all premoves
          board.position(newPos);
          
          // Clear all highlights first, then add red highlights for all premoves
          requestAnimationFrame(() => {
            $("#board .square-55d63").removeClass("premove-highlight premove-source");
            
            for (const sq of highlightSquares) {
              $(`#board .square-${sq.from}`).addClass("premove-source");
              $(`#board .square-${sq.to}`).addClass("premove-highlight");
            }
          });
        });
      });
    }

    function handleSquareClick(square) {
      console.log('=== handleSquareClick START ===', square);
      const turn = game.turn();
      const isPlayerTurn = (playerColor === "white" && turn === "w") || (playerColor === "black" && turn === "b");
      const piece = game.get(square);  // Use game.get() to get piece from game state
      console.log('Turn:', turn, 'isPlayerTurn:', isPlayerTurn, 'piece:', piece, 'selectedSquare:', selectedSquare);
      
      // If there's a selected piece
      if (selectedSquare) {
        // If clicking the same square, deselect
        if (selectedSquare === square) {
          selectedSquare = null;
          removeHighlights();
          return;
        }
        
        // Check if this is a legal move or premove
        if (!isPlayerTurn) {
          // Make premove via click - allow any destination including recapturing own pieces
          // (might be currently illegal but could become legal after opponent moves)
          const premoveFrom = selectedSquare;
          const premoveTo = square;
          
          // Verify there's a piece at the source that belongs to the player
          const sourcePiece = game.get(premoveFrom);
          if (!sourcePiece || sourcePiece.color !== (playerColor === 'white' ? 'w' : 'b')) {
            selectedSquare = null;
            removeHighlights();
            return;
          }
          
          // Validate premove is theoretically legal for this piece type
          if (!isPremoveLegal(premoveFrom, premoveTo, sourcePiece)) {
            console.log('Premove not valid for piece type:', sourcePiece.type, premoveFrom, '->', premoveTo);
            selectedSquare = null;
            removeHighlights();
            return;
          }
          
          selectedSquare = null;
          removeHighlights();
          
          // Add new premove to the array (chain of premoves)
          const newPremove = { from: premoveFrom, to: premoveTo };
          premoves.push(newPremove);
          premoveJustSet = true;
          console.log('Premove added via click:', newPremove, 'Total premoves:', premoves.length);
          
          // Update visual to show all premoves in the chain
          updatePremoveVisual();
          return;
        } else {
          // Try to make a normal move
          const moveFrom = selectedSquare;
          const moveTo = square;
          console.log('Attempting move from', moveFrom, 'to', moveTo);
          const testMove = game.move({ from: moveFrom, to: moveTo, promotion: 'q' });
          console.log('Test move result:', testMove);
          
          if (testMove) {
            // Legal move - undo the test move, then execute properly
            game.undo();
            clearPremove();
            selectedSquare = null;
            removeHighlights();
            console.log('Calling handleMove');
            handleMove(moveFrom, moveTo);
            return;
          } else if (piece) {
            const pieceColorFull = piece.color === 'w' ? 'white' : 'black';
            if (pieceColorFull === playerColor) {
              // Illegal move but clicked on own piece - change selection
              console.log('Switching selection to', square);
              // Clear old highlights before selecting new piece
              $("#board .square-55d63").removeClass("highlight-legal");
              selectedSquare = square;
              highlightLegalMoves(square);
              return;
            }
          }
          
          // Invalid move, deselect
          console.log('Invalid move, deselecting');
          selectedSquare = null;
          removeHighlights();
          return;
        }
      }
      
      // No piece selected - select clicked piece if valid
      if (piece) {
        const pieceColorFull = piece.color === 'w' ? 'white' : 'black';
        if (pieceColorFull === playerColor) {
          // Allow selecting own pieces even during opponent's turn (for premoves)
          console.log('Setting selectedSquare to:', square);
          // Clear old highlights before selecting new piece
          $("#board .square-55d63").removeClass("highlight-legal");
          selectedSquare = square;
          highlightLegalMoves(square);
          console.log('After setting, selectedSquare is:', selectedSquare);
        }
      } else {
        // Clicked on empty square with no piece selected
        // Cancel all premoves if it's the opponent's turn (when premoves can be set)
        if (!isPlayerTurn && premoves.length > 0) {
          console.log('Empty square clicked during opponent turn, canceling all premoves');
          clearPremove();
        }
      }
    }

    function detectOpening() {
      const history = game.history();
      let movesStr = history.join(" ");
      
      // Check for exact matches, starting with longest sequences
      const sortedOpenings = Object.keys(openingBook).sort((a, b) => b.length - a.length);
      
      for (let opening of sortedOpenings) {
        if (movesStr.startsWith(opening)) {
          return openingBook[opening];
        }
      }
      
      return null;
    }

    function updateOpeningDisplay() {
      const opening = detectOpening();
      const openingNameEl = document.getElementById("opening-name");
      
      if (opening) {
        openingNameEl.textContent = opening;
        document.getElementById("opening-display").style.display = "block";
      } else if (game.history().length > 10) {
        openingNameEl.textContent = "General Position";
        document.getElementById("opening-display").style.display = "block";
      }
    }

    function highlightLastMove(from, to) {
      // Remove previous highlights
      $("#board .square-55d63").removeClass("highlight-last-move");
      
      // Add new highlights
      if (from && to) {
        $("#board .square-" + from).addClass("highlight-last-move");
        $("#board .square-" + to).addClass("highlight-last-move");
      }
    }

    function highlightCheck() {
      // Remove previous check highlights
      $("#board .square-55d63").removeClass("highlight-check");
      
      if (game.in_check()) {
        const turn = game.turn();
        const kingSquare = findKingSquare(turn);
        if (kingSquare) {
          $("#board .square-" + kingSquare).addClass("highlight-check");
        }
      }
    }

    function findKingSquare(color) {
      const board = game.board();
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          const piece = board[i][j];
          if (piece && piece.type === 'k' && piece.color === color) {
            const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
            return files[j] + (8 - i);
          }
        }
      }
      return null;
    }

    function updateGameStats() {
      // Update move number
      const moveNum = Math.ceil(game.history().length / 2);
      if (game.history().length === 0) {
        document.getElementById("move-number").textContent = "1";
      } else {
        document.getElementById("move-number").textContent = moveNum;
      }
      // Update total moves
      document.getElementById("total-moves").textContent = game.history().length;
      
      // Update captured pieces display
      updateCapturedPieces();
      
      // Calculate and update material balance
      updateMaterialBalance();
    }

    function updateCapturedPieces() {
      const whiteCapDiv = document.getElementById("white-captures-display");
      const blackCapDiv = document.getElementById("black-captures-display");
      
      whiteCapDiv.innerHTML = capturedPieces.white.length > 0 ? 
        capturedPieces.white.map(p => `<div class="captured-piece" style="background-image: url('lib/img/chesspieces/wikipedia/${p}.png')"></div>`).join('') :
        '';
      
      blackCapDiv.innerHTML = capturedPieces.black.length > 0 ? 
        capturedPieces.black.map(p => `<div class="captured-piece" style="background-image: url('lib/img/chesspieces/wikipedia/${p}.png')"></div>`).join('') :
        '';
    }

    function updateMaterialBalance() {
      const pieceValues = { p: 1, n: 3, b: 3, r: 5, q: 9, k: 0 };
      
      let whiteMaterial = 0;
      let blackMaterial = 0;
      
      const board = game.board();
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          const piece = board[i][j];
          if (piece) {
            const value = pieceValues[piece.type];
            if (piece.color === 'w') {
              whiteMaterial += value;
            } else {
              blackMaterial += value;
            }
          }
        }
      }
      
      const difference = whiteMaterial - blackMaterial;
      const balanceEl = document.getElementById("material-balance");
      
      balanceEl.classList.remove('positive', 'negative', 'equal');
      
      if (difference > 0) {
        balanceEl.textContent = `White +${difference}`;
        balanceEl.classList.add('positive');
      } else if (difference < 0) {
        balanceEl.textContent = `Black +${Math.abs(difference)}`;
        balanceEl.classList.add('negative');
      } else {
        balanceEl.textContent = 'Equal';
        balanceEl.classList.add('equal');
      }
    }

    function trackCapturedPiece(move) {
      if (move.captured) {
        const capturedPieceCode = move.color === 'w' ? 'b' + move.captured.toUpperCase() : 'w' + move.captured.toUpperCase();
        if (move.color === 'w') {
          capturedPieces.white.push(capturedPieceCode);
        } else {
          capturedPieces.black.push(capturedPieceCode);
        }
      }
    }

    function celebrateCheckmate(playerWon) {
      console.log('celebrateCheckmate called, playerWon:', playerWon);
      if (playerWon) {
        // Victory celebration: massive confetti + sparkles + green pulse + brightness
        const overlay = document.createElement('div');
        overlay.className = 'checkmate-overlay';
        document.body.appendChild(overlay);

        // Generate MORE confetti (200 pieces instead of 100)
        const colors = ['#FFD700', '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE', '#2ECC71', '#3498DB'];
        for (let i = 0; i < 200; i++) {
          setTimeout(() => {
            const confetti = document.createElement('div');
            confetti.className = 'confetti';
            confetti.style.left = Math.random() * 100 + '%';
            confetti.style.top = -10 + 'px';
            confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
            confetti.style.width = (Math.random() * 15 + 8) + 'px'; // Bigger confetti
            confetti.style.height = (Math.random() * 15 + 8) + 'px';
            confetti.style.opacity = Math.random() * 0.5 + 0.5;
            confetti.style.animation = `confetti-fall ${(Math.random() * 2 + 2)}s linear forwards`;
            confetti.style.animationDelay = (Math.random() * 0.5) + 's';
            overlay.appendChild(confetti);

            setTimeout(() => confetti.remove(), 3500);
          }, i * 15); // Faster spawn rate
        }

        // Add sparkles around the board
        const board = document.getElementById('board');
        const boardRect = board.getBoundingClientRect();
        for (let i = 0; i < 30; i++) {
          setTimeout(() => {
            const sparkle = document.createElement('div');
            sparkle.className = 'sparkle';
            const angle = (Math.PI * 2 * i) / 30;
            const distance = 300 + Math.random() * 100;
            sparkle.style.left = (boardRect.left + boardRect.width / 2 + Math.cos(angle) * distance) + 'px';
            sparkle.style.top = (boardRect.top + boardRect.height / 2 + Math.sin(angle) * distance) + 'px';
            sparkle.style.animation = `sparkle ${0.8 + Math.random() * 0.4}s ease-out`;
            document.body.appendChild(sparkle);

            setTimeout(() => sparkle.remove(), 1200);
          }, i * 50);
        }

        // Add dramatic victory pulse with brightness
        board.style.animation = 'victoryPulse 1s ease-in-out 4'; // 4 pulses instead of 3
        setTimeout(() => {
          board.style.animation = '';
          board.style.filter = '';
        }, 4000);

        setTimeout(() => overlay.remove(), 5000);
      } else {
        // Defeat animation: INTENSE shake + red overlay + red glow + screen pulse
        const overlay = document.createElement('div');
        overlay.className = 'defeat-overlay';
        document.body.appendChild(overlay);

        // Shake the entire game container for extra drama
        const gameContainer = document.getElementById('game-container');
        if (gameContainer) {
          gameContainer.style.animation = 'defeatPulse 1.5s ease-out';
          setTimeout(() => {
            gameContainer.style.animation = '';
          }, 1500);
        }

        const board = document.getElementById('board');
        // Apply VERY intense shake and massive red glow
        board.style.animation = 'defeatShake 1.5s ease-in-out';
        board.style.boxShadow = '0 0 80px 20px rgba(220, 53, 69, 1), inset 0 0 40px rgba(220, 53, 69, 0.3)';
        board.style.filter = 'brightness(0.7) saturate(1.5)';
        
        setTimeout(() => {
          board.style.animation = '';
          board.style.boxShadow = '';
          board.style.filter = '';
        }, 1500);

        // Remove overlay after animation
        setTimeout(() => overlay.remove(), 1500);
      }
    }

    function exportPGN() {
      const date = new Date();
      const dateStr = date.toISOString().split('T')[0].replace(/-/g, '.');
      
      let pgn = '[Event "Chess vs TrifangX"]\n';
      pgn += '[Site "Ahrens Labs"]\n';
      pgn += `[Date "${dateStr}"]\n`;
      pgn += '[Round "1"]\n';
      pgn += `[White "${playerColor === 'white' ? 'Player' : 'TrifangX'}"]\n`;
      pgn += `[Black "${playerColor === 'black' ? 'Player' : 'TrifangX'}"]\n`;
      
      let result = '*';
      if (game.in_checkmate()) {
        result = game.turn() === 'w' ? '0-1' : '1-0';
      } else if (game.in_draw() || game.in_stalemate() || game.in_threefold_repetition()) {
        result = '1/2-1/2';
      }
      pgn += `[Result "${result}"]\n\n`;
      
      const history = game.history();
      let moveText = '';
      for (let i = 0; i < history.length; i++) {
        if (i % 2 === 0) {
          moveText += `${Math.floor(i / 2) + 1}. `;
        }
        moveText += history[i] + ' ';
        if (i % 2 === 1) {
          moveText += '\n';
        }
      }
      
      pgn += moveText.trim() + ` ${result}`;
      
      // Create download
      const blob = new Blob([pgn], { type: 'text/plain' });
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `chess_game_${dateStr}.pgn`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
    }
    
    function resignGame() {
      if (gameOver) return;
      
      // Position the modal directly above the resign button (popping out of it)
      const modal = document.getElementById('confirm-modal');
      const resignBtn = document.getElementById('resign-btn');
      
      // Show the modal first
      modal.classList.add('show');
      
      // Use requestAnimationFrame to ensure modal is rendered before getting dimensions
      requestAnimationFrame(() => {
        const modalRect = modal.getBoundingClientRect();
        const btnRect = resignBtn.getBoundingClientRect();
        
        // Position centered horizontally above the button with a small gap
        // Make it appear to "pop out" from the button
        const gap = 8; // 8px gap between button and modal
        modal.style.left = (btnRect.left + btnRect.width / 2 - modalRect.width / 2) + 'px';
        modal.style.top = (btnRect.top - modalRect.height - gap) + 'px';
        modal.style.position = 'fixed'; // Use fixed positioning relative to viewport
      });
    }

    function closeConfirmModal() {
      document.getElementById('confirm-modal').classList.remove('show');
    }

    function confirmResign() {
      closeConfirmModal();
      
      const winner = playerColor === 'white' ? 'black' : 'white';
      const moveContainer = document.getElementById("move-timer-container");
      moveContainer.innerHTML = `RESIGNATION! <span style="color:red;">You Lose!</span>`;
      gameOver = true;
      
      // Send resignation to engine
      sendEngineCommand("resign").catch(err => console.error("Error sending resignation:", err));
          a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
    }

    function setupTimerDisplayOrder() {
      // Get the parent container
      const container = document.getElementById('timers-container');
      
      // Get the individual time slots
      const whiteSlot = document.getElementById('time-slot-white');
      const blackSlot = document.getElementById('time-slot-black');

      // Determine player and engine colors
      const playerIsWhite = playerColor === 'white';
      const playerSlot = playerIsWhite ? whiteSlot : blackSlot;
      const engineSlot = playerIsWhite ? blackSlot : whiteSlot;

      // Remove existing children
      container.innerHTML = '';

      // Engine time always on top, Player time always on bottom
      container.appendChild(engineSlot);
      container.appendChild(playerSlot);
    }

    async function startGame() {
      gameOver = false;
      
      const side = document.getElementById("color-select").value;
      const timeOption = document.getElementById("time-control").value;      blindfoldMode = document.getElementById("blindfold-mode").checked;      showHistoryInBlindfold = document.getElementById("show-history").checked;      playerColor = side === "random" ? (Math.random() < 0.5 ? "white" : "black") : side;
      const [base, inc] =
        timeOption === "none" ? [null, null] : timeOption.split("|").map(Number);

      timeLimited = timeOption !== "none";
      increment = inc || 0;
      whiteTime = base ? base * 1000 : 0;
      blackTime = base ? base * 1000 : 0;

      // Show or hide timers based on time control
      const timersContainer = document.getElementById("timers-container");
      if (timeLimited) {
        timersContainer.style.display = "flex";
      } else {
        timersContainer.style.display = "none";
      }

      // Reset game (don't create new, just reset existing)
      if (!game) {
        game = new Chess();
      } else {
        game.reset();
      }
      moveHistory = [];
      currentMoveIndex = -1;
      capturedPieces = { white: [], black: [] };
      lastMoveSquares = { from: null, to: null };
      gameStartTime = new Date();
      premoves = []; // Clear any premoves
      selectedSquare = null; // Clear any selection
      
      // Hide the options panel with fade effect
      const choosePanel = document.getElementById("choose-side");
      choosePanel.style.transition = "opacity 0.3s ease, transform 0.3s ease";
      choosePanel.style.opacity = "0";
      choosePanel.style.transform = "scale(0.95)";
      setTimeout(() => {
        choosePanel.style.display = "none";
      }, 300);
      
      document.getElementById("move-timer-container").innerHTML = 'Time for this move: <span id="timer">00:00.00</span>';

      updateLastMove(null, "00:00.00", 0, 0);
      updateTurnDisplay();
      
      // Initialize move number
      document.getElementById("move-number").textContent = "1";

      // Destroy preview board and create game board
      if (board) {
        board.destroy();
      }
      
      board = Chessboard("board", {
        draggable: true,
        position: "start",
        orientation: playerColor,
        snapSpeed: 50,
        snapbackSpeed: 50,
        appearSpeed: 0,
        moveSpeed: 100,
        trashSpeed: 50,
        dragThrottleRate: 0,
        sparePieces: false,
        dropOffBoard: 'snapback',
        onDragStart: (source, piece, position, orientation) => {
          console.log('onDragStart called for:', source, 'selectedSquare before:', selectedSquare);
          
          // Store the drag start square and time for click detection
          window.dragStartSquare = source;
          window.dragStartTime = Date.now();
          
          // Clear any previous highlights when starting to drag a new piece
          $("#board .square-55d63").removeClass("highlight-legal");
          
          // Don't allow dragging if game is over
          if (game.game_over() || gameOver) {
            return false;
          }
          
          const turn = game.turn();
          const isPlayerTurn = (playerColor === "white" && turn === "w") || (playerColor === "black" && turn === "b");
          
          // Allow dragging opponent's pieces for premove, or own pieces on player's turn
          if (!isPlayerTurn) {
            // This is a premove - allow dragging player's pieces only
            if ((playerColor === "white" && piece.search(/^w/) === -1) || 
                (playerColor === "black" && piece.search(/^b/) === -1)) {
              return false; // Can't premove opponent's pieces
            }
            return true; // Allow premove
          }
          
          // Don't allow dragging opponent's pieces on player's turn
          if ((turn === 'w' && piece.search(/^b/) !== -1) || (turn === 'b' && piece.search(/^w/) !== -1)) {
            return false;
          }
          
          // Highlight legal moves when starting to drag
          highlightLegalMoves(source);
        },
        onDragMove: (newLocation, oldLocation, source, piece, position, orientation) => {
          // Remove previous legal-target class
          $("#board .square-55d63").removeClass("legal-target");
          
          // Only add yellow border if hovering over a legal move square
          const moves = game.moves({ square: source, verbose: true });
          const isLegal = moves.some(move => move.to === newLocation);
          
          if (isLegal) {
            $(`#board .square-${newLocation}`).addClass("legal-target");
          }
        },
        onMouseoutSquare: (square, piece) => {
          // Only remove legal-target class (yellow hover border during drag)
          $("#board .square-55d63").removeClass("legal-target");
          // Don't remove legal move dots - they stay until piece is deselected or moved
        },
        onDrop: (source, target) => {
          console.log('onDrop called:', source, '->', target);
          
          // Detect click-to-move: if dropped on same square, it's a click
          if (source === target) {
            console.log('Click detected (drop on same square):', source);
            handleSquareClick(source);
            return 'snapback'; // Return piece to original position
          }
          
          const turn = game.turn();
          const isPlayerTurn = (playerColor === "white" && turn === "w") || (playerColor === "black" && turn === "b");
          
          // Handle premove (during opponent's turn)
          if (!isPlayerTurn) {
            // Verify there's a piece at the source that belongs to the player
            const sourcePiece = game.get(source);
            if (!sourcePiece || sourcePiece.color !== (playerColor === 'white' ? 'w' : 'b')) {
              return 'snapback';
            }
            
            // Validate premove is theoretically legal for this piece type
            if (!isPremoveLegal(source, target, sourcePiece)) {
              console.log('Premove not valid for piece type:', sourcePiece.type, source, '->', target);
              return 'snapback';
            }
            
            // Add new premove to the array (chain of premoves)
            const newPremove = { from: source, to: target };
            premoves.push(newPremove);
            premoveJustSet = true;
            console.log('Premove added via drag:', newPremove, 'Total premoves:', premoves.length);
            
            // Update visual to show all premoves in the chain
            updatePremoveVisual();
            
            // Don't snapback - keep the piece moved
            return;
          }
          
          // Clear premove if player makes a manual move
          clearPremove();
          
          // Validate move synchronously first
          if (gameOver) {
            return 'snapback';
          }
          
          // Check if move is legal
          const move = game.move({ from: source, to: target, promotion: 'q' });
          if (!move) {
            return 'snapback';
          }
          
          // Move is legal - undo it and let handleMove process it properly
          game.undo();
          handleMove(source, target);
        },
        onSnapEnd: () => {
          // Clean up after drag/drop (clicks are handled in onDrop)
          $("#board .square-55d63").removeClass("legal-target");
          
          // Only remove highlights if not in click-to-move mode
          if (!selectedSquare) {
            removeHighlights();
          }
        },
        onClick: (square) => {
          const turn = game.turn();
          const isPlayerTurn = (playerColor === "white" && turn === "w") || (playerColor === "black" && turn === "b");
          const position = board.position();
          const piece = position[square];
          
          // If there's a selected piece
          if (selectedSquare) {
            // If clicking the same square, deselect
            if (selectedSquare === square) {
              selectedSquare = null;
              removeHighlights();
              return;
            }
            
            // Check if this is a legal move or premove
            if (!isPlayerTurn) {
              // Handle premove click
              if (!piece || (playerColor === "white" && piece.search(/^w/) !== -1) || 
                  (playerColor === "black" && piece.search(/^b/) !== -1)) {
                // Clicking empty square or own piece - try to premove
                const premoveFrom = selectedSquare;
                const premoveTo = square;
                
                // Clear highlights and selection
                selectedSquare = null;
                removeHighlights();
                
                // If clicking own piece, select it instead
                if (piece) {
                  selectedSquare = square;
                  highlightLegalMoves(square);
                } else {
                  // Add new premove to the array (chain of premoves)
                  const newPremove = { from: premoveFrom, to: premoveTo };
                  premoves.push(newPremove);
                  premoveJustSet = true;
                  console.log('Premove added via onClick:', newPremove, 'Total premoves:', premoves.length);
                  
                  // Update visual to show all premoves in the chain
                  updatePremoveVisual();
                }
                return;
              }
            } else {
              // Try to make a normal move
              const move = game.move({ from: selectedSquare, to: square, promotion: 'q' });
              
              if (move) {
                // Legal move
                clearPremove();
                selectedSquare = null;
                removeHighlights();
                game.undo();
                handleMove(move.from, move.to);
                return;
              } else if (piece) {
                // Illegal move but clicked on own piece - change selection
                const pieceColor = piece.search(/^w/) !== -1 ? 'w' : 'b';
                if ((turn === 'w' && pieceColor === 'w') || (turn === 'b' && pieceColor === 'b')) {
                  selectedSquare = square;
                  removeHighlights();
                  highlightLegalMoves(square);
                  return;
                }
              }
              
              // Invalid move, deselect
              selectedSquare = null;
              removeHighlights();
              return;
            }
          }
          
          // No piece selected - select clicked piece if valid
          if (piece) {
            if (!isPlayerTurn) {
              // During opponent's turn, allow selecting own pieces for premove
              if ((playerColor === "white" && piece.search(/^w/) !== -1) || 
                  (playerColor === "black" && piece.search(/^b/) !== -1)) {
                selectedSquare = square;
                highlightLegalMoves(square);
              }
            } else {
              // During player's turn, select own pieces
              const pieceColor = piece.search(/^w/) !== -1 ? 'w' : 'b';
              if ((turn === 'w' && pieceColor === 'w') || (turn === 'b' && pieceColor === 'b')) {
                selectedSquare = square;
                highlightLegalMoves(square);
              }
            }
          } else {
            // Clicked on empty square with no piece selected
            // Cancel all premoves if it's the opponent's turn (when premoves can be set)
            if (!isPlayerTurn && premoves.length > 0) {
              console.log('Empty square clicked during opponent turn, canceling all premoves');
              clearPremove();
            }
          }
        },
        pieceTheme: pieceThemes[currentPieceStyle],
      });
      
      // Add click-to-move functionality using mousedown/mouseup to avoid drag interference
      setTimeout(() => {
        let mouseDownSquare = null;
        
        $('#board').off('mousedown mouseup').on('mousedown', function(e) {
          // Only handle left click
          if (e.button !== 0) return;
          
          let $square = $(e.target);
          
          // If clicked on a piece image, get the parent square
          if ($square.hasClass('piece-417db') || $square.prop('tagName') === 'IMG') {
            $square = $square.parent();
          }
          
          // Make sure we have a square element
          if (!$square.hasClass('square-55d63')) {
            $square = $square.closest('.square-55d63');
          }
          
          if ($square.length === 0) return;
          
          const square = $square.data('square');
          if (square) {
            mouseDownSquare = square;
          }
        }).on('mouseup', function(e) {
          // Only handle left click
          if (e.button !== 0) return;
          
          if (!mouseDownSquare) return;
          
          let $square = $(e.target);
          
          // If released on a piece image, get the parent square
          if ($square.hasClass('piece-417db') || $square.prop('tagName') === 'IMG') {
            $square = $square.parent();
          }
          
          // Make sure we have a square element
          if (!$square.hasClass('square-55d63')) {
            $square = $square.closest('.square-55d63');
          }
          
          if ($square.length === 0) {
            mouseDownSquare = null;
            return;
          }
          
          const square = $square.data('square');
          
          // Only treat as click if mousedown and mouseup on same square
          if (square && square === mouseDownSquare) {
            console.log('Click detected on square:', square);
            handleSquareClick(square);
          }
          
          mouseDownSquare = null;
        });
      }, 100);

      // Cancel premoves on mousedown/touchstart outside of pieces/board
      let premoveJustSet = false;
      $(document).on('mousedown touchstart', function(e) {
        // Don't cancel if we just set a premove in the same event cycle
        if (premoves.length > 0 && !premoveJustSet) {
          // Check if the click is on the board or a piece
          const $target = $(e.target);
          const isOnBoard = $target.closest('#board').length > 0;
          const isOnPiece = $target.hasClass('piece-417db') || $target.hasClass('square-55d63') || $target.closest('.square-55d63').length > 0;
          
          // Only cancel if clicking outside the board/pieces
          if (!isOnBoard && !isOnPiece) {
            console.log('Click detected outside board/pieces, canceling all premoves');
            clearPremove();
          }
        }
        premoveJustSet = false;
      });

      // Prevent native HTML5 drag on piece images
      setTimeout(() => {
        $('#board img').on('dragstart', function(e) {
          e.preventDefault();
          return false;
        });
        // Also set draggable attribute to false
        $('#board img').attr('draggable', 'false');
        
        // Use MutationObserver to handle dynamically added images
        const observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            mutation.addedNodes.forEach(function(node) {
              if (node.tagName === 'IMG') {
                $(node).attr('draggable', 'false');
                $(node).on('dragstart', function(e) {
                  e.preventDefault();
                  return false;
                });
              }
              if (node.querySelectorAll) {
                $(node).find('img').attr('draggable', 'false');
                $(node).find('img').on('dragstart', function(e) {
                  e.preventDefault();
                  return false;
                });
              }
            });
          });
        });
        
        observer.observe(document.getElementById('board'), {
          childList: true,
          subtree: true
        });
      }, 200);
      
      // Add event delegation for dynamically added images
      $('#board').on('dragstart', 'img', function(e) {
        e.preventDefault();
        return false;
      });

      document.getElementById("move-timer-container").style.display = "block";
      document.getElementById("last-move-container").style.display = "block";
      document.getElementById("notation-container").style.display = "block";
      document.getElementById("notation-container").textContent = "";
      document.getElementById("game-stats-panel").style.display = "block";
      document.getElementById("export-pgn-btn").style.display = "block";
      document.getElementById("resign-btn").style.display = "block";
      document.getElementById("opening-display").style.display = "none";
      
      // Initialize stats
      updateGameStats();
      
      // Handle blindfold mode
      if (blindfoldMode) {
        document.getElementById("board").classList.add("blindfold-hidden");
        document.getElementById("timers-container").classList.add("blindfold-hidden");
        document.getElementById("move-input-container").style.display = "block";
        
        // Handle move history visibility in blindfold mode
        if (showHistoryInBlindfold) {
          document.getElementById("notation-container").classList.remove("blindfold-hidden");
        } else {
          document.getElementById("notation-container").classList.add("blindfold-hidden");
        }
      } else {
        document.getElementById("board").classList.remove("blindfold-hidden");
        document.getElementById("timers-container").classList.remove("blindfold-hidden");
        document.getElementById("notation-container").classList.remove("blindfold-hidden");
        document.getElementById("move-input-container").style.display = "none";
      }
      
      startTimer();
      
      // Initialize engine and apply modifiers before allowing moves
      await sendEngineCommand("start");
      await applyEngineModifiers(currentEngineStyle);
      
      if (playerColor === "black") {
        engineMove();
      }
    }

    async function handleMove(source, target) {
      console.log('handleMove called:', source, 'to', target);
      
      removeHighlights();
      const move = game.move({ from: source, to: target, promotion: "q" });
      if (!move) {
        console.log('Move was invalid in handleMove (should not happen)');
        return;
      }

      trackCapturedPiece(move);
      lastMoveSquares = { from: source, to: target };
      
      const prevTurn = game.turn() === "w" ? "b" : "w";
      const moveTimeMs = stopTimerAndUpdateTotal(prevTurn);
      updateLastMove(move.san, formatTime(moveTimeMs), game.turn() === "w" ? "black" : "white", game.history().length/2 + 0.5);
      board.position(game.fen());
      highlightLastMove(source, target);
      highlightCheck();
      updateTurnDisplay();
      updateOpeningDisplay();
      updateGameStats();

      if (game.in_checkmate()) {
        // Replaced alert() with UI message
        const moveContainer = document.getElementById("move-timer-container");
        moveContainer.innerHTML = 'CHECKMATE! <span style="color:#2ECC71;">You Win!</span>'; // Green text for win
        celebrateCheckmate(true);
        gameOver = true;
        return;
      }

      startTimer(); // Start move timer for engine
      await engineMove();
    }
    async function engineMove() {
      console.log('=== engineMove START ===');
      console.log('Game over status:', gameOver);
      console.log('Current position:', game.fen());
      try {
        const lastMove = game.history().slice(-1)[0];
        console.log('Last move:', lastMove, 'Game turn:', game.turn());
        console.log('Sending request to engine...');
        const response = await fetch("https://hedgehoglover23.pythonanywhere.com/move", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            move: lastMove,
            color: game.turn() === "w" ? "black" : "white",
          }),
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        console.log('Engine response:', data);
        if (!data.move) {
          console.log('ERROR: No move returned from engine');
          // Replaced alert() with UI message
          const moveContainer = document.getElementById("move-timer-container");
          moveContainer.innerHTML = 'ENGINE ERROR: <span style="color:red;">No move returned.</span>';
          return;
        }

        console.log('Engine move:', data.move);
        // Stop timer *before* making the move on the game object
        const moveTimeMs = stopTimerAndUpdateTotal(game.turn()); 
        const move = game.move(data.move);
        console.log('Move applied to game. New position:', game.fen());
        console.log('Is checkmate?', game.in_checkmate());
        console.log('Is check?', game.in_check());
        console.log('Is game over?', game.game_over());
        
        trackCapturedPiece(move);
        lastMoveSquares = { from: move.from, to: move.to };
        
        updateLastMove(data.move, formatTime(moveTimeMs), game.turn() === "w" ? "black" : "white", game.history().length/2 + 0.5);
        
        // Show opponent's move first
        board.position(game.fen());
        
        highlightLastMove(move.from, move.to);
        highlightCheck();
        updateTurnDisplay();
        updateOpeningDisplay();
        updateGameStats();

        if (game.in_checkmate()) {
          console.log('CHECKMATE DETECTED - Player Lost');
          // Replaced alert() with UI message
          const moveContainer = document.getElementById("move-timer-container");
          moveContainer.innerHTML = 'CHECKMATE! <span style="color:red;">You Lose!</span>';
          console.log('About to call celebrateCheckmate(false)');
          try {
            celebrateCheckmate(false);
            console.log('celebrateCheckmate call completed');
          } catch (err) {
            console.error('Error in celebrateCheckmate:', err);
          }
          gameOver = true;
          clearPremove();
          return;
        }
        
        // Check if there are premoves and execute the first one if legal
        console.log('Checking for premoves...', premoves);
        if (premoves.length > 0) {
          const firstPremove = premoves[0];
          console.log('Attempting to execute first premove:', firstPremove);
          
          const premoveAttempt = game.move({ from: firstPremove.from, to: firstPremove.to, promotion: 'q' });
          console.log('Premove attempt result:', premoveAttempt);
          
          if (premoveAttempt) {
            // Premove is legal - it's been executed, remove it from the array
            console.log('Premove was legal and executed!');
            premoves.shift(); // Remove the executed premove
            
            const from = premoveAttempt.from;
            const to = premoveAttempt.to;
            
            trackCapturedPiece(premoveAttempt);
            lastMoveSquares = { from, to };
            
            const premoveMoveTimeMs = 0; // Instant premove
            updateLastMove(premoveAttempt.san, "00:00.00", game.turn() === "w" ? "black" : "white", game.history().length/2 + 0.5);
            board.position(game.fen());
            
            // Remove red highlights for this executed premove
            $("#board .square-55d63").removeClass("premove-highlight premove-source");
            
            // Update visual to show remaining premoves if any
            if (premoves.length > 0) {
              updatePremoveVisual();
            }
            
            // Highlight with normal last-move highlight (not red premove highlight)
            highlightLastMove(from, to);
            highlightCheck();
            updateTurnDisplay();
            updateOpeningDisplay();
            updateGameStats();
            
            if (game.in_checkmate()) {
              const moveContainer = document.getElementById("move-timer-container");
              moveContainer.innerHTML = 'CHECKMATE! <span style="color:#2ECC71;">You Win!</span>';
              celebrateCheckmate(true);
              gameOver = true;
              clearPremove();
              return;
            }
            
            // After executing premove, get engine response
            // The next premove in the chain will be executed after the engine moves
            console.log('Premove executed, now getting engine response...', premoves.length, 'premoves remaining');
            startTimer();
            await engineMove();
            return;
          } else {
            // First premove is no longer legal - clear all premoves and restore board position
            console.log('First premove was not legal, clearing all premoves');
            clearPremove();
          }
        }

        startTimer(); // Start move timer for player
      } catch (err) {
        // Replaced alert() with UI message
        const moveContainer = document.getElementById("move-timer-container");
        moveContainer.innerHTML = `CONNECTION ERROR: <span style="color:red;">${err.message || 'Could not reach engine.'}</span>`;
        console.error('Engine connection error:', err);
        gameOver = true;
      }
    }
    function submitMove() {
      if (gameOver) return;
      
      const moveInput = document.getElementById("move-input");
      const moveStr = moveInput.value.trim();
      
      if (!moveStr) {
        moveInput.style.borderColor = "red";
        setTimeout(() => { moveInput.style.borderColor = "#3498db"; }, 500);
        return;
      }
      
      removeHighlights();
      const move = game.move(moveStr, { sloppy: true });
      
      if (!move) {
        moveInput.style.borderColor = "red";
        setTimeout(() => { moveInput.style.borderColor = "#3498db"; }, 500);
        return;
      }
      
      moveInput.value = "";
      moveInput.style.borderColor = "#3498db";
      
      trackCapturedPiece(move);
      lastMoveSquares = { from: move.from, to: move.to };
      
      const prevTurn = game.turn() === "w" ? "b" : "w";
      const moveTimeMs = stopTimerAndUpdateTotal(prevTurn);
      updateLastMove(move.san, formatTime(moveTimeMs), game.turn() === "w" ? "black" : "white", game.history().length/2 + 0.5);
      
      if (!blindfoldMode) {
        board.position(game.fen());
        highlightLastMove(move.from, move.to);
        highlightCheck();
      }
      
      updateTurnDisplay();
      updateOpeningDisplay();
      updateGameStats();

      if (game.in_checkmate()) {
        const moveContainer = document.getElementById("move-timer-container");
        moveContainer.innerHTML = 'CHECKMATE! <span style="color:#2ECC71;">You Win!</span>';
        celebrateCheckmate(true);
        gameOver = true;
        return;
      }

      startTimer();
      engineMove();
    }  </script>
  <div class="push"></div>
    </div>
  <footer>
        <p>&copy; 2025 Ahrens Labs. All rights reserved.</p>
    </footer>
</body>
</html>