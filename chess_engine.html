<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Chess Game against TrifangX</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Orbitron&family=Roboto+Mono&display=swap" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">
    <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <link rel="stylesheet" href="css/style.css">
    <script src="js/script.js"></script>

  <style>
    /* Chess Engine Page - Enhanced Clean Theme */
    body {
      background: linear-gradient(135deg, #f0f4f8 0%, #e8f2f7 50%, #f0f4f8 100%);
      background-attachment: fixed;
      color: #333;
      min-height: 100vh;
      overflow-x: hidden;
      position: relative;
    }

    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: 
          radial-gradient(circle at 20% 80%, rgba(52, 152, 219, 0.03) 0%, transparent 50%),
          radial-gradient(circle at 80% 20%, rgba(46, 204, 113, 0.02) 0%, transparent 50%);
      background-size: 600px 600px;
      animation: subtleFloat 15s ease-in-out infinite;
      pointer-events: none;
      z-index: -1;
    }

    /* Main content container */
    main {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      max-width: 1200px;
      margin: 0 auto;
    }

    /* Main Title Styling */
    h2 {
      text-align: center;
      font-family: "Inter", sans-serif;
      font-size: 2.5rem;
      font-weight: 700;
      margin-bottom: 2rem;
      color: #2c3e50;
      margin-top: 1rem;
      position: relative;
    }

    h2::after {
      content: '';
      position: absolute;
      bottom: -10px;
      left: 50%;
      transform: translateX(-50%);
      width: 100px;
      height: 3px;
      background: linear-gradient(90deg, #3498db, #2ecc71);
      border-radius: 2px;
    }

    .sharp {
      background: linear-gradient(135deg, #3498db, #2ecc71);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      font-weight: 800;
      animation: shimmer 3s ease-in-out infinite;
    }

    /* Game Controls Container */
    #choose-side {
      background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
      padding: 30px;
      border-radius: 20px;
      box-shadow: 
          0 10px 30px rgba(0, 0, 0, 0.1),
          0 1px 8px rgba(0, 0, 0, 0.1),
          inset 0 1px 0 rgba(255, 255, 255, 0.8);
      max-width: 800px;
      margin: 0 auto 30px auto;
      display: flex;
      flex-direction: column;
      gap: 20px;
      align-items: center;
      text-align: center;
      border: 1px solid rgba(52, 152, 219, 0.1);
      position: relative;
      overflow: hidden;
    }

    #choose-side::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, #3498db, #2ecc71, #3498db);
      background-size: 200% 100%;
      animation: shimmer 3s ease-in-out infinite;
    }

    /* Individual control rows */
    .control-row {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      width: 100%;
      flex-wrap: wrap;
    }

    /* Keep label and select together on same line */
    .control-row label:not([for="blindfold-mode"]):not([for="show-history"]) {
      white-space: nowrap;
    }

    .control-row > label,
    .control-row > select {
      flex-shrink: 0;
    }

    /* Less prominent style options */
    .control-row.style-option {
      font-size: 0.9em;
      opacity: 0.8;
    }

    .control-row.style-option label {
      font-size: 0.95em;
      font-weight: 500;
      color: #5a6c7d;
    }

    .control-row.style-option select {
      font-size: 0.9em;
      min-width: 130px;
      padding: 10px 16px;
    }

    /* Labels */
    label {
      font-family: "Inter", sans-serif;
      color: #2c3e50;
      font-weight: 600;
      margin-right: 10px;
      font-size: 1.1em;
    }

    /* Select Dropdowns */
    select {
      background-color: white;
      color: #333;
      border: 2px solid #3498db;
      border-radius: 20px;
      padding: 12px 18px;
      font-family: "Inter", sans-serif;
      font-size: 1em;
      margin: 0;
      transition: all 0.3s ease;
      box-shadow: 0 2px 8px rgba(52, 152, 219, 0.1);
      min-width: 140px;
      max-width: 160px;
      cursor: pointer;
    }

    /* Engine personality selector - make it stand out */
    #engine-style {
      border: 3px solid #6c757d;
      background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
      font-weight: 600;
      min-width: 180px;
      box-shadow: 0 3px 10px rgba(108, 117, 125, 0.15);
      position: relative;
      transition: all 0.4s ease;
    }

    /* Personality color classes */
    #engine-style.personality-balanced {
      border-color: #6c757d;
      box-shadow: 0 3px 10px rgba(108, 117, 125, 0.3), 0 0 15px rgba(108, 117, 125, 0.2);
      background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
    }

    #engine-style.personality-aggressive {
      border-color: #e74c3c;
      box-shadow: 0 3px 12px rgba(231, 76, 60, 0.4), 0 0 20px rgba(231, 76, 60, 0.3);
      background: linear-gradient(145deg, #ffffff 0%, #fff5f5 100%);
    }

    #engine-style.personality-defensive {
      border-color: #3498db;
      box-shadow: 0 3px 12px rgba(52, 152, 219, 0.4), 0 0 20px rgba(52, 152, 219, 0.3);
      background: linear-gradient(145deg, #ffffff 0%, #f0f8ff 100%);
    }

    #engine-style.personality-positional {
      border-color: #9b59b6;
      box-shadow: 0 3px 12px rgba(155, 89, 182, 0.4), 0 0 20px rgba(155, 89, 182, 0.3);
      background: linear-gradient(145deg, #ffffff 0%, #f8f0ff 100%);
    }

    #engine-style.personality-material {
      border-color: #f39c12;
      box-shadow: 0 3px 12px rgba(243, 156, 18, 0.4), 0 0 20px rgba(243, 156, 18, 0.3);
      background: linear-gradient(145deg, #ffffff 0%, #fffaf0 100%);
    }

    #engine-style.personality-tactical {
      border-color: #1abc9c;
      box-shadow: 0 3px 12px rgba(26, 188, 156, 0.4), 0 0 20px rgba(26, 188, 156, 0.3);
      background: linear-gradient(145deg, #ffffff 0%, #f0fff8 100%);
    }

    #engine-style:hover {
      transform: translateY(-2px) scale(1.02);
      filter: brightness(1.05);
    }

    #engine-style:focus {
      outline: none;
      transform: scale(1.03);
    }

    /* Custom personality class */
    #engine-style.personality-custom {
      border-color: #34495e;
      box-shadow: 0 3px 12px rgba(52, 73, 94, 0.4), 0 0 20px rgba(52, 73, 94, 0.3);
      background: linear-gradient(145deg, #ffffff 0%, #f5f6fa 100%);
    }

    /* Custom modifiers panel */
    #custom-modifiers-panel {
      background: linear-gradient(145deg, #f8f9fa 0%, #ffffff 100%);
      border: 2px solid #34495e;
      border-radius: 15px;
      padding: 20px;
      margin: 15px 0;
      box-shadow: 0 4px 15px rgba(52, 73, 94, 0.15);
      animation: slideDown 0.3s ease;
    }

    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .modifier-input-group {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .modifier-input-group label {
      flex: 1;
      font-size: 0.95em;
      font-weight: 500;
      color: #2c3e50;
      text-align: left;
    }

    .modifier-input-group input[type="number"] {
      width: 80px;
      padding: 8px 12px;
      border: 2px solid #34495e;
      border-radius: 10px;
      font-family: "Roboto Mono", monospace;
      font-size: 0.95em;
      text-align: center;
      transition: all 0.3s ease;
      background: white;
    }

    .modifier-input-group input[type="number"]:hover {
      border-color: #5d6d7e;
      box-shadow: 0 2px 8px rgba(52, 73, 94, 0.2);
    }

    .modifier-input-group input[type="number"]:focus {
      outline: none;
      border-color: #3498db;
      box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.15);
    }

    /* Option elements styling */
    select option {
      background: white;
      color: #333;
      font-family: "Inter", sans-serif;
      padding: 8px;
    }

    select:hover {
      border-color: #2980b9;
      box-shadow: 0 4px 12px rgba(52, 152, 219, 0.2);
      transform: translateY(-1px);
    }

    select:focus {
      outline: none;
      border-color: #3498db;
      box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
    }

    /* Start Game Button */
    button {
      width: 100%;
      padding: 15px 20px;
      font-size: 1.1em;
      background-color: #3498db;
      color: white;
      border: none;
      border-radius: 20px;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      font-family: "Inter", sans-serif;
      font-weight: 600;
      box-shadow: 0 4px 12px rgba(52, 152, 219, 0.2);
      margin: 10px 0;
      max-width: 200px;
    }

    button:hover {
      background-color: #2980b9;
      transform: translateY(-2px) scale(1.02);
      box-shadow: 0 6px 16px rgba(52, 152, 219, 0.3);
    }

    button:active {
      transform: translateY(0) scale(1);
      box-shadow: 0 2px 8px rgba(52, 152, 219, 0.2);
    }

    /* Chess Board Container */
    #board-timers-container {
      display: flex !important;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      height: auto;
      min-height: 450px;
      justify-content: flex-start;
      align-self: flex-start;
    }

    /* Chess Board Styling */
    #board {
      width: 450px;
      height: 450px;
      border-radius: 15px;
      box-shadow: 
          0 15px 35px rgba(0, 0, 0, 0.15),
          0 5px 15px rgba(0, 0, 0, 0.1);
      border: 3px solid #e9ecef;
      overflow: hidden;
      position: relative;
      background-color: white;
      transition: all 0.3s ease;
    }

    #board:hover {
      transform: translateY(-2px);
      box-shadow: 
          0 20px 40px rgba(0, 0, 0, 0.2),
          0 8px 20px rgba(0, 0, 0, 0.1);
    }

    /* Board Color Themes with Enhanced Visual Effects */
    .board-theme-classic .white-1e1d7 { 
      background: linear-gradient(135deg, #f0d9b5 0%, #e8d0a8 100%);
      box-shadow: inset 0 0 20px rgba(181, 136, 99, 0.1);
    }
    .board-theme-classic .black-3c85d { 
      background: linear-gradient(135deg, #b58863 0%, #a67c52 100%);
      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.2);
    }

    .board-theme-blue .white-1e1d7 { 
      background: linear-gradient(135deg, #dee3e6 0%, #d0d8dd 100%);
      box-shadow: inset 0 0 15px rgba(140, 162, 173, 0.15);
    }
    .board-theme-blue .black-3c85d { 
      background: linear-gradient(135deg, #8ca2ad 0%, #7a95a3 100%);
      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.25);
    }

    .board-theme-green .white-1e1d7 { 
      background: linear-gradient(135deg, #ffffdd 0%, #f5f5c8 100%);
      box-shadow: inset 0 0 15px rgba(134, 166, 102, 0.1);
    }
    .board-theme-green .black-3c85d { 
      background: linear-gradient(135deg, #86a666 0%, #75955a 100%);
      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.2);
    }

    .board-theme-gray .white-1e1d7 { 
      background: linear-gradient(135deg, #e8e8e8 0%, #dcdcdc 100%);
      box-shadow: inset 0 0 10px rgba(153, 153, 153, 0.1);
    }
    .board-theme-gray .black-3c85d { 
      background: linear-gradient(135deg, #999999 0%, #888888 100%);
      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.3);
    }

    .board-theme-purple .white-1e1d7 { 
      background: linear-gradient(135deg, #e8d4f2 0%, #dfc5ed 100%);
      box-shadow: inset 0 0 15px rgba(155, 109, 181, 0.15);
    }
    .board-theme-purple .black-3c85d { 
      background: linear-gradient(135deg, #9b6db5 0%, #8a5da0 100%);
      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.25);
    }

    .board-theme-wood .white-1e1d7 { 
      background: 
        linear-gradient(135deg, #f4dec4 0%, #ead4b0 100%),
        repeating-linear-gradient(45deg, transparent, transparent 2px, rgba(139, 90, 43, 0.03) 2px, rgba(139, 90, 43, 0.03) 4px);
      box-shadow: inset 0 0 25px rgba(139, 90, 43, 0.2);
    }
    .board-theme-wood .black-3c85d { 
      background: 
        linear-gradient(135deg, #8b5a2b 0%, #7a4a1f 100%),
        repeating-linear-gradient(45deg, transparent, transparent 2px, rgba(0, 0, 0, 0.1) 2px, rgba(0, 0, 0, 0.1) 4px);
      box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.4);
    }

    .board-theme-coral .white-1e1d7 { 
      background: linear-gradient(135deg, #ffebcd 0%, #ffe0b3 100%);
      box-shadow: inset 0 0 15px rgba(205, 133, 63, 0.15);
    }
    .board-theme-coral .black-3c85d { 
      background: linear-gradient(135deg, #cd853f 0%, #b87333 100%);
      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.25);
    }

    .board-theme-marble .white-1e1d7 { 
      background: 
        linear-gradient(135deg, #f5f5f0 0%, #ecece5 100%),
        repeating-linear-gradient(0deg, transparent, transparent 8px, rgba(139, 134, 128, 0.05) 8px, rgba(139, 134, 128, 0.05) 10px);
      box-shadow: inset 0 0 20px rgba(139, 134, 128, 0.1);
    }
    .board-theme-marble .black-3c85d { 
      background: 
        linear-gradient(135deg, #8b8680 0%, #7d7872 100%),
        repeating-linear-gradient(0deg, transparent, transparent 8px, rgba(0, 0, 0, 0.1) 8px, rgba(0, 0, 0, 0.1) 10px);
      box-shadow: inset 0 0 25px rgba(0, 0, 0, 0.3);
    }

    .board-theme-dark .white-1e1d7 { 
      background: linear-gradient(135deg, #4a5568 0%, #3d4758 100%);
      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.3);
    }
    .board-theme-dark .black-3c85d { 
      background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
      box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.5);
    }

    .board-theme-neon .white-1e1d7 { 
      background: linear-gradient(135deg, #e0f7fa 0%, #b2ebf2 100%);
      box-shadow: inset 0 0 20px rgba(0, 172, 193, 0.3), 0 0 10px rgba(0, 172, 193, 0.2);
    }
    .board-theme-neon .black-3c85d { 
      background: linear-gradient(135deg, #00acc1 0%, #00838f 100%);
      box-shadow: inset 0 0 25px rgba(0, 0, 0, 0.3), 0 0 15px rgba(0, 172, 193, 0.4);
    }

    .board-theme-emerald .white-1e1d7 { 
      background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
      box-shadow: inset 0 0 15px rgba(40, 167, 69, 0.2);
    }
    .board-theme-emerald .black-3c85d { 
      background: linear-gradient(135deg, #28a745 0%, #218838 100%);
      box-shadow: inset 0 0 25px rgba(0, 0, 0, 0.3);
    }

    .board-theme-gold .white-1e1d7 { 
      background: linear-gradient(135deg, #fff8dc 0%, #ffeaa7 100%);
      box-shadow: inset 0 0 20px rgba(218, 165, 32, 0.3), 0 0 10px rgba(218, 165, 32, 0.1);
    }
    .board-theme-gold .black-3c85d { 
      background: linear-gradient(135deg, #daa520 0%, #c4941c 100%);
      box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.4), 0 0 15px rgba(218, 165, 32, 0.3);
    }

    .board-theme-ocean .white-1e1d7 { 
      background: 
        linear-gradient(135deg, #e0f2f1 0%, #b2dfdb 100%),
        radial-gradient(circle at 30% 30%, rgba(0, 105, 92, 0.1) 0%, transparent 50%);
      box-shadow: inset 0 0 20px rgba(0, 105, 92, 0.15);
    }
    .board-theme-ocean .black-3c85d { 
      background: 
        linear-gradient(135deg, #00695c 0%, #004d40 100%),
        radial-gradient(circle at 70% 70%, rgba(0, 0, 0, 0.2) 0%, transparent 50%);
      box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.4);
    }

    .board-theme-sunset .white-1e1d7 { 
      background: linear-gradient(135deg, #ffe5cc 0%, #ffcc99 100%);
      box-shadow: inset 0 0 20px rgba(255, 107, 53, 0.25);
    }
    .board-theme-sunset .black-3c85d { 
      background: linear-gradient(135deg, #ff6b35 0%, #e55a2b 100%);
      box-shadow: inset 0 0 25px rgba(0, 0, 0, 0.3);
    }

    .board-theme-midnight .white-1e1d7 { 
      background: 
        linear-gradient(135deg, #3a3f4b 0%, #2d323d 100%),
        radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.05) 0%, transparent 70%);
      box-shadow: inset 0 0 25px rgba(0, 0, 0, 0.4);
    }
    .board-theme-midnight .black-3c85d { 
      background: 
        linear-gradient(135deg, #1a1d24 0%, #0f1114 100%),
        radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.03) 0%, transparent 70%);
      box-shadow: inset 0 0 35px rgba(0, 0, 0, 0.6);
    }

    .board-theme-forest .white-1e1d7 { 
      background: 
        linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%),
        repeating-linear-gradient(45deg, transparent, transparent 3px, rgba(46, 125, 50, 0.05) 3px, rgba(46, 125, 50, 0.05) 6px);
      box-shadow: inset 0 0 15px rgba(46, 125, 50, 0.15);
    }
    .board-theme-forest .black-3c85d { 
      background: 
        linear-gradient(135deg, #2e7d32 0%, #1b5e20 100%),
        repeating-linear-gradient(45deg, transparent, transparent 3px, rgba(0, 0, 0, 0.1) 3px, rgba(0, 0, 0, 0.1) 6px);
      box-shadow: inset 0 0 25px rgba(0, 0, 0, 0.35);
    }

    .board-theme-royal .white-1e1d7 { 
      background: linear-gradient(135deg, #f3e5f5 0%, #e1bee7 100%);
      box-shadow: inset 0 0 20px rgba(123, 31, 162, 0.25), 0 0 10px rgba(123, 31, 162, 0.1);
    }
    .board-theme-royal .black-3c85d { 
      background: linear-gradient(135deg, #7b1fa2 0%, #6a1b9a 100%);
      box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.4), 0 0 15px rgba(123, 31, 162, 0.3);
    }

    .board-theme-ice .white-1e1d7 { 
      background: 
        linear-gradient(135deg, #e1f5fe 0%, #b3e5fc 100%),
        radial-gradient(circle at 20% 20%, rgba(2, 119, 189, 0.1) 0%, transparent 60%);
      box-shadow: inset 0 0 20px rgba(2, 119, 189, 0.2);
    }
    .board-theme-ice .black-3c85d { 
      background: 
        linear-gradient(135deg, #0277bd 0%, #01579b 100%),
        radial-gradient(circle at 80% 80%, rgba(0, 0, 0, 0.2) 0%, transparent 60%);
      box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.4);
    }

    .board-theme-cherry .white-1e1d7 { 
      background: linear-gradient(135deg, #ffebee 0%, #ffcdd2 100%);
      box-shadow: inset 0 0 20px rgba(198, 40, 40, 0.2);
    }
    .board-theme-cherry .black-3c85d { 
      background: linear-gradient(135deg, #c62828 0%, #b71c1c 100%);
      box-shadow: inset 0 0 25px rgba(0, 0, 0, 0.35);
    }

    /* Advanced Visual Effect Themes */
    .board-theme-3d .white-1e1d7 { 
      background: 
        linear-gradient(135deg, #f5f5f0 0%, #e8e8e0 50%, #f5f5f0 100%),
        repeating-linear-gradient(45deg, transparent, transparent 4px, rgba(0, 0, 0, 0.02) 4px, rgba(0, 0, 0, 0.02) 8px);
      box-shadow: inset -2px -2px 8px rgba(0, 0, 0, 0.1), inset 2px 2px 8px rgba(255, 255, 255, 0.5);
    }
    .board-theme-3d .black-3c85d { 
      background: 
        linear-gradient(135deg, #8b8680 0%, #7a7570 50%, #8b8680 100%),
        repeating-linear-gradient(45deg, transparent, transparent 4px, rgba(0, 0, 0, 0.1) 4px, rgba(0, 0, 0, 0.1) 8px);
      box-shadow: inset -2px -2px 10px rgba(0, 0, 0, 0.4), inset 2px 2px 10px rgba(255, 255, 255, 0.1);
    }

    .board-theme-glass .white-1e1d7 { 
      background: 
        linear-gradient(135deg, rgba(255, 255, 255, 0.9) 0%, rgba(240, 240, 240, 0.8) 100%),
        radial-gradient(circle at 30% 30%, rgba(200, 200, 255, 0.2) 0%, transparent 70%);
      box-shadow: inset 0 0 30px rgba(200, 200, 255, 0.3), 0 0 20px rgba(200, 200, 255, 0.2);
      backdrop-filter: blur(1px);
    }
    .board-theme-glass .black-3c85d { 
      background: 
        linear-gradient(135deg, rgba(100, 100, 150, 0.8) 0%, rgba(70, 70, 120, 0.9) 100%),
        radial-gradient(circle at 70% 70%, rgba(0, 0, 0, 0.3) 0%, transparent 70%);
      box-shadow: inset 0 0 35px rgba(0, 0, 0, 0.4), 0 0 25px rgba(100, 100, 150, 0.3);
      backdrop-filter: blur(1px);
    }

    .board-theme-carbon .white-1e1d7 { 
      background: 
        linear-gradient(135deg, #e8e8e8 0%, #d0d0d0 100%),
        repeating-linear-gradient(0deg, transparent, transparent 1px, rgba(0, 0, 0, 0.03) 1px, rgba(0, 0, 0, 0.03) 2px),
        repeating-linear-gradient(90deg, transparent, transparent 1px, rgba(0, 0, 0, 0.03) 1px, rgba(0, 0, 0, 0.03) 2px);
      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.1);
    }
    .board-theme-carbon .black-3c85d { 
      background: 
        linear-gradient(135deg, #2c2c2c 0%, #1a1a1a 100%),
        repeating-linear-gradient(0deg, transparent, transparent 1px, rgba(255, 255, 255, 0.05) 1px, rgba(255, 255, 255, 0.05) 2px),
        repeating-linear-gradient(90deg, transparent, transparent 1px, rgba(255, 255, 255, 0.05) 1px, rgba(255, 255, 255, 0.05) 2px);
      box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.5);
    }

    .board-theme-velvet .white-1e1d7 { 
      background: 
        radial-gradient(ellipse at 30% 30%, rgba(255, 255, 255, 0.8) 0%, transparent 50%),
        linear-gradient(135deg, #f5f0f5 0%, #e8e0e8 100%);
      box-shadow: inset 0 0 25px rgba(138, 43, 226, 0.15);
    }
    .board-theme-velvet .black-3c85d { 
      background: 
        radial-gradient(ellipse at 70% 70%, rgba(0, 0, 0, 0.3) 0%, transparent 50%),
        linear-gradient(135deg, #8a2be2 0%, #6a1b9a 100%);
      box-shadow: inset 0 0 35px rgba(0, 0, 0, 0.5), 0 0 20px rgba(138, 43, 226, 0.3);
    }

    .board-theme-stone .white-1e1d7 { 
      background: 
        linear-gradient(135deg, #d5d5d5 0%, #c0c0c0 100%),
        repeating-linear-gradient(45deg, transparent, transparent 6px, rgba(0, 0, 0, 0.05) 6px, rgba(0, 0, 0, 0.05) 12px),
        radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.3) 0%, transparent 40%);
      box-shadow: inset 0 0 25px rgba(0, 0, 0, 0.15);
    }
    .board-theme-stone .black-3c85d { 
      background: 
        linear-gradient(135deg, #696969 0%, #555555 100%),
        repeating-linear-gradient(45deg, transparent, transparent 6px, rgba(0, 0, 0, 0.15) 6px, rgba(0, 0, 0, 0.15) 12px),
        radial-gradient(circle at 80% 80%, rgba(0, 0, 0, 0.3) 0%, transparent 40%);
      box-shadow: inset 0 0 35px rgba(0, 0, 0, 0.4);
    }

    .board-theme-cyber .white-1e1d7 { 
      background: 
        linear-gradient(135deg, #00ff88 0%, #00cc6a 100%),
        repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0, 255, 136, 0.1) 2px, rgba(0, 255, 136, 0.1) 4px);
      box-shadow: inset 0 0 30px rgba(0, 255, 136, 0.4), 0 0 20px rgba(0, 255, 136, 0.3);
    }
    .board-theme-cyber .black-3c85d { 
      background: 
        linear-gradient(135deg, #001a0f 0%, #000000 100%),
        repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0, 255, 136, 0.2) 2px, rgba(0, 255, 136, 0.2) 4px);
      box-shadow: inset 0 0 40px rgba(0, 255, 136, 0.5), 0 0 30px rgba(0, 255, 136, 0.4);
    }

    .board-theme-luxury .white-1e1d7 { 
      background: 
        linear-gradient(135deg, #fffef7 0%, #f5f4e8 100%),
        radial-gradient(ellipse at 50% 50%, rgba(212, 175, 55, 0.15) 0%, transparent 70%);
      box-shadow: inset 0 0 30px rgba(212, 175, 55, 0.2), 0 0 15px rgba(212, 175, 55, 0.1);
    }
    .board-theme-luxury .black-3c85d { 
      background: 
        linear-gradient(135deg, #d4af37 0%, #b8941f 100%),
        radial-gradient(ellipse at 50% 50%, rgba(0, 0, 0, 0.3) 0%, transparent 70%);
      box-shadow: inset 0 0 40px rgba(0, 0, 0, 0.5), 0 0 25px rgba(212, 175, 55, 0.4);
    }

    /* Legal Move Highlights */
    .highlight-legal {
      position: relative;
    }
    .highlight-legal::after {
      content: "";
      position: absolute;
      top: 50%;
      left: 50%;
      width: 20px;
      height: 20px;
      background: radial-gradient(circle, #3498db, transparent);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 10;
      animation: legalMovePulse 1.5s ease-in-out infinite;
    }

    /* Hide default drag-over border */
    #board .square-55d63 {
      box-shadow: none !important;
    }

    /* Enable pointer events for dragging */
    #board img {
      pointer-events: auto !important;
      cursor: grab;
      user-select: none;
      -webkit-user-drag: none;
      -khtml-user-drag: none;
      -moz-user-drag: none;
      -o-user-drag: none;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
    }
    
    #board img[draggable] {
      -webkit-user-drag: none !important;
    }

    #board img:active {
      cursor: grabbing;
    }

    /* Only show yellow border on legal move targets during drag */
    .legal-target {
      box-shadow: inset 0 0 0 3px rgba(255, 235, 59, 0.8) !important;
    }

    @keyframes legalMovePulse {
      0%, 100% { 
        opacity: 0.6; 
        transform: translate(-50%, -50%) scale(1);
      }
      50% { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1.2);
      }
    }

    /* Timers Container */
    #timers-container {
      font-family: "Inter", sans-serif;
      color: #333;
      display: none;
      flex-direction: column;
      justify-content: center;
      gap: 15px;
      user-select: none;
      background-color: white;
      border-radius: 15px;
      padding: 25px;
      border: 1px solid #e9ecef;
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.1);
      min-width: 250px;
      min-height: 150px;
      visibility: visible !important;
    }

    #timers-container div {
      font-size: 1.2em;
      font-weight: 600;
      padding: 15px;
      background-color: #f8f9fa;
      border-radius: 10px;
      border-left: 4px solid #3498db;
      transition: all 0.3s ease;
    }
    
    .time-slot {
      display: block !important;
      visibility: visible !important;
    }

    #timers-container div:hover {
      background-color: #e9ecef;
      transform: translateX(3px);
    }

    /* Move Timer */
    #move-timer-container {
      text-align: center;
      margin: 0;
      font-family: "Inter", sans-serif;
      font-size: 1.3em;
      font-weight: 600;
      user-select: none;
      color: #2c3e50;
      background-color: white;
      border-radius: 15px;
      padding: 20px;
      border: 1px solid #e9ecef;
      max-width: 300px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    /* Last Move Container */
    #last-move-container {
      text-align: center;
      margin: 0;
      font-family: "Inter", sans-serif;
      font-size: 1.2em;
      font-weight: 600;
      color: #2c3e50;
      user-select: none;
      background-color: white;
      border-radius: 15px;
      padding: 20px;
      border: 1px solid #e9ecef;
      max-width: 500px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    #turn-color {
      color: #3498db;
      font-weight: 700;
    }

    #last-move {
      color: #e74c3c;
      font-weight: 700;
    }

    /* Game Statistics Panel */
    #game-stats-panel {
      background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
      padding: 15px;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
      margin: 15px auto;
      max-width: 600px;
      border: 1px solid rgba(52, 152, 219, 0.1);
      font-family: 'Inter', sans-serif;
      display: none;
    }

    #game-stats-panel h3 {
      text-align: center;
      font-size: 1.05rem;
      font-weight: 600;
      color: #2c3e50;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 2px solid #e9ecef;
    }

    .stats-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 10px;
      margin-bottom: 6px;
      background: white;
      border-radius: 6px;
      border-left: 2px solid #3498db;
    }

    .stats-label {
      font-weight: 600;
      color: #2c3e50;
      font-size: 0.9em;
    }

    .stats-value {
      font-weight: 500;
      color: #7f8c8d;
      font-size: 0.9em;
    }

    .captured-pieces {
      display: flex;
      gap: 5px;
      align-items: center;
      flex-wrap: wrap;
    }

    .captured-piece {
      width: 30px;
      height: 30px;
      display: inline-block;
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
    }

    /* Main game container with vertical layout */
    #game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
      margin: 20px auto;
      max-width: 1400px;
    }

    #board-row {
      display: flex;
      justify-content: center;
      align-items: flex-start;
      gap: 25px;
      align-items: flex-start;
    }
    
    /* Ensure board container has flexible height to accommodate flip button */
    #board-timers-container {
      min-height: 450px;
      height: auto;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;
    }

    /* Captured pieces beside board */
    #board-with-captures {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 20px;
    }

    #captured-pieces-left {
      display: flex;
      flex-direction: column;
      gap: 30px;
      min-width: 80px;
    }

    #right-panel {
      display: flex;
      flex-direction: column;
      gap: 15px;
      min-width: 350px;
      max-width: 400px;
      height: 450px;
      overflow-y: auto;
      overflow-x: hidden;
      align-self: flex-start;
    }

    #right-panel > div,
    #right-panel > button {
      margin: 0;
    }

    #game-buttons {
      display: flex;
      gap: 10px;
      justify-content: center;
    }

    #game-buttons button {
      flex: 1;
      min-width: 0;
    }
    
    #board-timers-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      min-height: 450px;
      height: auto;
      justify-content: flex-start;
      align-self: flex-start;
    }

    .captured-section {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
      background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
      border-radius: 10px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
    }

    .captured-section-title {
      font-family: 'Inter', sans-serif;
      font-size: 0.75em;
      font-weight: 600;
      color: #7f8c8d;
      margin-bottom: 8px;
      text-align: center;
    }

    .captured-pieces-display {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      max-width: 70px;
      justify-content: center;
    }

    .material-advantage {
      font-weight: 700;
      font-size: 1.1em;
    }

    .material-advantage.positive {
      color: #2ecc71;
    }

    .material-advantage.negative {
      color: #e74c3c;
    }

    #right-panel {
      display: flex;
      flex-direction: column;
      gap: 15px;
      min-width: 350px;
      max-width: 400px;
      height: 450px;
      overflow-y: auto;
      overflow-x: hidden;
      align-self: flex-start;
    }

    #right-panel > div,
    #right-panel > button {
      margin: 0;
    }

    .material-advantage.equal {
      color: #7f8c8d;
    }

    /* Opening Book Display */
    #opening-display {
      background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
      padding: 12px 15px;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
      margin: 15px auto;
      max-width: 600px;
      text-align: center;
      border: 1px solid rgba(52, 152, 219, 0.1);
      display: none;
    }

    #opening-display .opening-label {
      font-family: 'Inter', sans-serif;
      font-size: 0.8em;
      font-weight: 500;
      color: #7f8c8d;
      margin-bottom: 4px;
    }

    #opening-display .opening-name {
      font-family: 'Inter', sans-serif;
      font-size: 1.1em;
      font-weight: 700;
      color: #3498db;
    }

    /* Export PGN Button */
    #export-pgn-btn {
      background-color: #2ecc71;
      color: white;
      padding: 12px 24px;
      border: none;
      border-radius: 20px;
      cursor: pointer;
      font-family: 'Inter', sans-serif;
      font-weight: 600;
      font-size: 1em;
      box-shadow: 0 4px 12px rgba(46, 204, 113, 0.2);
      transition: all 0.3s ease;
      margin: 10px auto;
      display: none;
    }

    #export-pgn-btn:hover {
      background-color: #27ae60;
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(46, 204, 113, 0.3);
    }
    
    /* Resign Button */
    #resign-btn {
      background-color: #e74c3c;
      color: white;
      padding: 12px 24px;
      border: none;
      border-radius: 20px;
      cursor: pointer;
      font-family: 'Inter', sans-serif;
      font-weight: 600;
      font-size: 1em;
      box-shadow: 0 4px 12px rgba(231, 76, 60, 0.2);
      transition: all 0.3s ease;
      margin: 10px auto;
      display: none;
    }

    #resign-btn:hover {
      background-color: #c0392b;
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(231, 76, 60, 0.3);
    }

    /* Board square highlighting */
    .highlight-last-move {
      background-color: rgba(255, 235, 59, 0.4) !important;
    }

    .highlight-check {
      background-color: rgba(231, 76, 60, 0.5) !important;
      animation: checkPulse 1s ease-in-out infinite;
    }

    @keyframes checkPulse {
      0%, 100% { 
        background-color: rgba(231, 76, 60, 0.5) !important;
      }
      50% { 
        background-color: rgba(231, 76, 60, 0.7) !important;
      }
    }

    /* Illegal move animation */
    @keyframes illegalMoveBlink {
      0%, 100% { 
        background-color: transparent;
        box-shadow: none;
      }
      50% {
        background-color: rgba(231, 76, 60, 0.4) !important;
        box-shadow: inset 0 0 10px rgba(231, 76, 60, 0.5) !important;
      }
    }

    .square-55d63.illegal-move {
      animation: illegalMoveBlink 0.4s ease-in-out !important;
    }

    /* Premove highlighting */
    .square-55d63.premove-highlight {
      background-color: rgba(215, 57, 65, 0.65) !important; /* Medium red between dark and light */
      box-shadow: inset 0 0 0 4px rgba(190, 40, 47, 0.9) !important;
    }
    
    div.premove-highlight {
      background-color: rgba(215, 57, 65, 0.65) !important;
      box-shadow: inset 0 0 0 4px rgba(190, 40, 47, 0.9) !important;
    }
    
    /* Premove source highlighting (same color as destination) */
    .square-55d63.premove-source {
      background-color: rgba(215, 57, 65, 0.65) !important; /* Same medium red */
      box-shadow: inset 0 0 0 4px rgba(190, 40, 47, 0.9) !important;
    }
    
    div.premove-source {
      background-color: rgba(215, 57, 65, 0.65) !important;
      box-shadow: inset 0 0 0 4px rgba(190, 40, 47, 0.9) !important;
    }


    @keyframes slideInRight {
      from {
        transform: translateX(400px);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes slideOutRight {
      from {
        transform: translateX(0);
        opacity: 1;
      }
      to {
        transform: translateX(400px);
        opacity: 0;
      }
    }

    /* Rematch Modal */
    #rematch-modal {
      display: none;
      position: fixed;
      z-index: 10001;
      animation: rematchPopIn 0.3s ease-out;
    }

    #rematch-modal.show {
      display: block;
    }

    .rematch-dialog {
      background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
      border-radius: 16px;
      padding: 30px 35px;
      box-shadow: 
        0 12px 40px rgba(0, 0, 0, 0.3),
        0 0 0 1px rgba(0, 0, 0, 0.05),
        0 0 60px rgba(52, 152, 219, 0.2);
      min-width: 320px;
      max-width: 400px;
      position: relative;
      border: 3px solid #3498db;
      text-align: center;
    }

    .rematch-dialog h3 {
      margin: 0 0 12px 0;
      color: #2c3e50;
      font-family: 'Inter', sans-serif;
      font-size: 1.4em;
      font-weight: 700;
    }

    .rematch-dialog p {
      margin: 0 0 25px 0;
      color: #555;
      font-family: 'Inter', sans-serif;
      font-size: 1.05em;
      line-height: 1.5;
    }

    .rematch-buttons {
      display: flex;
      gap: 12px;
      justify-content: center;
    }

    .rematch-buttons button {
      flex: 1;
      padding: 12px 20px;
      border: none;
      border-radius: 10px;
      font-family: 'Inter', sans-serif;
      font-size: 1em;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .rematch-buttons .rematch-yes {
      background: linear-gradient(135deg, #3498db, #2980b9);
      color: white;
      box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
    }

    .rematch-buttons .rematch-yes:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(52, 152, 219, 0.4);
      background: linear-gradient(135deg, #2980b9, #1f6391);
    }

    .rematch-buttons .rematch-no {
      background: linear-gradient(135deg, #ecf0f1, #bdc3c7);
      color: #555;
    }

    .rematch-buttons .rematch-no:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(189, 195, 199, 0.4);
    }

    @keyframes rematchPopIn {
      from { 
        opacity: 0;
        transform: translateY(-20px) scale(0.9);
      }
      to { 
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    /* All Achievements Modal */
    #all-achievements-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 10005;
      animation: fadeIn 0.3s ease-out;
      overflow-y: auto;
    }

    #all-achievements-modal.show {
      display: block;
    }

    .all-achievements-dialog {
      background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
      margin: 2% auto;
      max-width: 90%;
      width: 1200px;
      max-height: 90vh;
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      padding: 30px;
      position: relative;
      animation: slideDown 0.4s ease-out;
    }

    .achievements-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 25px;
      padding-bottom: 15px;
      border-bottom: 3px solid #3498db;
    }

    .achievements-header h2 {
      margin: 0;
      font-family: 'Inter', sans-serif;
      font-size: 2em;
      font-weight: 700;
      color: #2c3e50;
    }

    .close-achievements-btn {
      background: #e74c3c;
      color: white;
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      font-size: 1.5em;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
    }

    .close-achievements-btn:hover {
      background: #c0392b;
      transform: rotate(90deg) scale(1.1);
    }

    .achievements-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 15px;
      max-height: calc(90vh - 120px);
      overflow-y: auto;
      padding-right: 10px;
    }

    .achievement-card {
      background: white;
      border-radius: 12px;
      padding: 15px;
      border: 2px solid #e9ecef;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .achievement-card.unlocked {
      border-color: #2ecc71;
      background: linear-gradient(145deg, #ffffff 0%, #f0fdf4 100%);
      box-shadow: 0 4px 12px rgba(46, 204, 113, 0.2);
    }

    .achievement-card.unlocked::before {
      content: 'âœ“';
      position: absolute;
      top: 10px;
      right: 10px;
      color: #2ecc71;
      font-size: 1.5em;
      font-weight: 700;
    }

    .achievement-card.locked {
      opacity: 0.5;
      filter: grayscale(0.7);
    }

    .achievement-card:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
    }

    .achievement-name {
      font-size: 1.1em;
      font-weight: 700;
      color: #2c3e50;
      margin-bottom: 8px;
      font-family: 'Inter', sans-serif;
    }

    .achievement-desc {
      font-size: 0.9em;
      color: #7f8c8d;
      margin-bottom: 8px;
      font-family: 'Inter', sans-serif;
    }

    .achievement-progress {
      font-size: 0.85em;
      color: #3498db;
      font-weight: 600;
      font-family: 'Inter', sans-serif;
    }

    .achievement-progress-bar {
      width: 100%;
      height: 6px;
      background: #e9ecef;
      border-radius: 3px;
      margin-top: 8px;
      overflow: hidden;
    }

    .achievement-progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #3498db, #2ecc71);
      border-radius: 3px;
      transition: width 0.3s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Custom Confirmation Modal */
    #confirm-modal {
      display: none;
      position: fixed;
      z-index: 10000;
      animation: popIn 0.2s ease-out;
    }

    #confirm-modal.show {
      display: block;
    }

    .confirm-dialog {
      background: white;
      border-radius: 12px;
      padding: 20px 25px;
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.25), 0 0 0 1px rgba(0, 0, 0, 0.05);
      min-width: 280px;
      max-width: 320px;
      position: relative;
      border: 2px solid #e74c3c;
    }

    .confirm-dialog::after {
      content: '';
      position: absolute;
      bottom: -10px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 10px solid transparent;
      border-right: 10px solid transparent;
      border-top: 10px solid #e74c3c;
    }

    .confirm-dialog::before {
      content: '';
      position: absolute;
      bottom: -8px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 9px solid transparent;
      border-right: 9px solid transparent;
      border-top: 9px solid white;
      z-index: 1;
    }

    .confirm-dialog h3 {
      margin: 0 0 10px 0;
      color: #e74c3c;
      font-family: 'Inter', sans-serif;
      font-size: 1.1em;
      font-weight: 600;
    }

    .confirm-dialog p {
      margin: 0 0 15px 0;
      color: #555;
      font-family: 'Inter', sans-serif;
      font-size: 0.95em;
      line-height: 1.4;
    }

    .confirm-buttons {
      display: flex;
      gap: 10px;
      justify-content: stretch;
    }

    .confirm-buttons button {
      flex: 1;
      padding: 8px 16px;
      border: none;
      border-radius: 8px;
      font-family: 'Inter', sans-serif;
      font-size: 0.9em;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .confirm-buttons .confirm-yes {
      background: linear-gradient(135deg, #e74c3c, #c0392b);
      color: white;
    }

    .confirm-buttons .confirm-yes:hover {
      transform: translateY(-1px);
      box-shadow: 0 3px 8px rgba(231, 76, 60, 0.4);
    }

    .confirm-buttons .confirm-no {
      background: linear-gradient(135deg, #ecf0f1, #bdc3c7);
      color: #555;
    }

    .confirm-buttons .confirm-no:hover {
      transform: translateY(-1px);
      box-shadow: 0 3px 8px rgba(189, 195, 199, 0.4);
    }

    @keyframes popIn {
      from { 
        opacity: 0;
        transform: translateY(10px) scale(0.95);
      }
      to { 
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    @keyframes victoryPulse {
      0%, 100% { transform: scale(1); filter: brightness(1); }
      10% { transform: scale(1.08) rotate(2deg); box-shadow: 0 0 60px rgba(46, 204, 113, 1), 0 0 100px rgba(46, 204, 113, 0.8); filter: brightness(1.3) saturate(1.2); }
      20% { transform: scale(0.95) rotate(-2deg); box-shadow: 0 0 80px rgba(46, 204, 113, 1), 0 0 120px rgba(46, 204, 113, 0.9); filter: brightness(1.4) saturate(1.3); }
      30% { transform: scale(1.05) rotate(1deg); box-shadow: 0 0 70px rgba(46, 204, 113, 1), 0 0 110px rgba(46, 204, 113, 0.85); filter: brightness(1.35) saturate(1.25); }
      40% { transform: scale(0.98) rotate(-1deg); box-shadow: 0 0 65px rgba(46, 204, 113, 1), 0 0 105px rgba(46, 204, 113, 0.8); filter: brightness(1.3) saturate(1.2); }
      50% { transform: scale(1.03) rotate(0.5deg); box-shadow: 0 0 75px rgba(46, 204, 113, 1), 0 0 115px rgba(46, 204, 113, 0.9); filter: brightness(1.4) saturate(1.3); }
      60% { transform: scale(0.99) rotate(-0.5deg); box-shadow: 0 0 70px rgba(46, 204, 113, 1), 0 0 110px rgba(46, 204, 113, 0.85); filter: brightness(1.35) saturate(1.25); }
      70% { transform: scale(1.02) rotate(0.3deg); box-shadow: 0 0 68px rgba(46, 204, 113, 1), 0 0 108px rgba(46, 204, 113, 0.8); filter: brightness(1.3) saturate(1.2); }
      80% { transform: scale(1) rotate(0deg); box-shadow: 0 0 50px rgba(46, 204, 113, 0.9), 0 0 90px rgba(46, 204, 113, 0.7); filter: brightness(1.2) saturate(1.1); }
      90% { transform: scale(1.01) rotate(0deg); box-shadow: 0 0 40px rgba(46, 204, 113, 0.8), 0 0 80px rgba(46, 204, 113, 0.6); filter: brightness(1.1) saturate(1.05); }
    }

    @keyframes sparkle {
      0% { opacity: 0; transform: scale(0) rotate(0deg); }
      20% { opacity: 1; transform: scale(1.5) rotate(90deg); }
      50% { opacity: 1; transform: scale(1) rotate(180deg); }
      80% { opacity: 0.8; transform: scale(0.8) rotate(270deg); }
      100% { opacity: 0; transform: scale(0) rotate(360deg); }
    }

    @keyframes firework {
      0% { 
        opacity: 1; 
        transform: scale(0) translateY(0);
      }
      50% { 
        opacity: 1; 
        transform: scale(1) translateY(-50px);
      }
      100% { 
        opacity: 0; 
        transform: scale(2) translateY(-100px);
      }
    }

    @keyframes ripple {
      0% {
        transform: scale(0);
        opacity: 1;
      }
      100% {
        transform: scale(4);
        opacity: 0;
      }
    }

    @keyframes screenFlash {
      0%, 100% { opacity: 0; }
      10% { opacity: 0.3; }
      20% { opacity: 0; }
      30% { opacity: 0.4; }
      40% { opacity: 0; }
      50% { opacity: 0.2; }
    }

    @keyframes textPop {
      0% { transform: scale(0) rotate(-180deg); opacity: 0; }
      50% { transform: scale(1.2) rotate(0deg); opacity: 1; }
      100% { transform: scale(1) rotate(0deg); opacity: 1; }
    }

    @keyframes particleTrail {
      0% { 
        transform: translate(0, 0) scale(1);
        opacity: 1;
      }
      100% { 
        transform: translate(var(--tx), var(--ty)) scale(0);
        opacity: 0;
      }
    }

    @keyframes defeatShake {
      0%, 100% { transform: translateX(0) rotate(0deg) scale(1); }
      5% { transform: translateX(-15px) rotate(-2deg) scale(0.98); }
      10% { transform: translateX(15px) rotate(2deg) scale(1.02); }
      15% { transform: translateX(-15px) rotate(-2deg) scale(0.98); }
      20% { transform: translateX(15px) rotate(2deg) scale(1.02); }
      25% { transform: translateX(-12px) rotate(-1.5deg) scale(0.99); }
      30% { transform: translateX(12px) rotate(1.5deg) scale(1.01); }
      35% { transform: translateX(-12px) rotate(-1.5deg) scale(0.99); }
      40% { transform: translateX(12px) rotate(1.5deg) scale(1.01); }
      50% { transform: translateX(-8px) rotate(-1deg) scale(1); }
      60% { transform: translateX(8px) rotate(1deg) scale(1); }
      70% { transform: translateX(-5px) rotate(-0.5deg) scale(1); }
      80% { transform: translateX(5px) rotate(0.5deg) scale(1); }
      90% { transform: translateX(-2px) rotate(0deg) scale(1); }
    }

    @keyframes defeatPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(0.95); }
    }

    @keyframes defeatFlash {
      0% { opacity: 0; }
      5% { opacity: 0.6; }
      10% { opacity: 0.2; }
      15% { opacity: 0.7; }
      20% { opacity: 0.1; }
      25% { opacity: 0.6; }
      30% { opacity: 0.2; }
      35% { opacity: 0.5; }
      40% { opacity: 0.1; }
      50% { opacity: 0.4; }
      60% { opacity: 0.1; }
      70% { opacity: 0.3; }
      100% { opacity: 0; }
    }

    @keyframes kingFall {
      0% { 
        transform: rotate(0deg) translateY(0);
        opacity: 1;
      }
      50% {
        transform: rotate(45deg) translateY(5px);
        opacity: 1;
      }
      100% { 
        transform: rotate(90deg) translateY(15px);
        opacity: 0.6;
      }
    }

    /* Checkmate Celebration */
    .confetti {
      position: fixed;
      width: 10px;
      height: 10px;
      background: #f0f;
      z-index: 9999;
      border-radius: 50%;
    }

    .confetti.rect {
      border-radius: 2px;
    }

    .confetti.star {
      clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
    }

    .sparkle {
      position: fixed;
      width: 20px;
      height: 20px;
      background: radial-gradient(circle, rgba(255, 215, 0, 1) 0%, rgba(255, 215, 0, 0) 70%);
      border-radius: 50%;
      z-index: 10000;
      pointer-events: none;
    }

    .firework {
      position: fixed;
      width: 8px;
      height: 8px;
      background: radial-gradient(circle, rgba(255, 255, 255, 1) 0%, rgba(255, 200, 0, 0.8) 50%, transparent 100%);
      border-radius: 50%;
      z-index: 10001;
      pointer-events: none;
    }

    .ripple {
      position: fixed;
      border: 3px solid rgba(46, 204, 113, 0.6);
      border-radius: 50%;
      z-index: 9998;
      pointer-events: none;
    }

    .particle {
      position: fixed;
      width: 4px;
      height: 4px;
      background: rgba(255, 255, 255, 0.9);
      border-radius: 50%;
      z-index: 10002;
      pointer-events: none;
    }

    .victory-text {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 4rem;
      font-weight: 900;
      color: #2ecc71;
      text-shadow: 
        0 0 20px rgba(46, 204, 113, 1),
        0 0 40px rgba(46, 204, 113, 0.8),
        0 0 60px rgba(46, 204, 113, 0.6),
        0 0 80px rgba(46, 204, 113, 0.4);
      z-index: 10003;
      pointer-events: none;
      font-family: 'Inter', sans-serif;
      letter-spacing: 0.2em;
      text-transform: uppercase;
    }

    .defeat-text {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 4rem;
      font-weight: 900;
      color: #e74c3c;
      text-shadow: 
        0 0 20px rgba(231, 76, 60, 1),
        0 0 40px rgba(231, 76, 60, 0.8),
        0 0 60px rgba(231, 76, 60, 0.6);
      z-index: 10003;
      pointer-events: none;
      font-family: 'Inter', sans-serif;
      letter-spacing: 0.2em;
      text-transform: uppercase;
    }

    @keyframes confetti-fall {
      0% {
        transform: translateY(0) rotate(0deg) translateX(0);
        opacity: 1;
      }
      100% {
        transform: translateY(100vh) rotate(720deg) translateX(var(--drift, 0px));
        opacity: 0;
      }
    }

    @keyframes confetti-burst {
      0% {
        transform: translate(0, 0) scale(1) rotate(0deg);
        opacity: 1;
      }
      100% {
        transform: translate(var(--tx, 0), var(--ty, 0)) scale(0) rotate(720deg);
        opacity: 0;
      }
    }

    .checkmate-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 9998;
    }

    .defeat-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, rgba(139, 0, 0, 0.3) 0%, rgba(139, 0, 0, 0.6) 100%);
      pointer-events: none;
      z-index: 9997;
      animation: defeatFlash 1.2s ease-out;
    }

    /* Move History/Notation Container */
    #notation-container {
      background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
      padding: 15px;
      border-radius: 15px;
      box-shadow: 
          0 4px 15px rgba(0, 0, 0, 0.08),
          inset 0 1px 0 rgba(255, 255, 255, 0.8);
      border: 1px solid rgba(52, 152, 219, 0.1);
      font-family: 'Roboto Mono', monospace;
      font-size: 0.85rem;
      line-height: 1.8;
      min-height: 60px;
      height: auto;
      max-height: 450px;
      transition: min-height 0.35s cubic-bezier(0.33,1,0.68,1), max-height 0.35s cubic-bezier(0.33,1,0.68,1);
      box-sizing: border-box;
      overflow-y: auto;
      overflow-x: hidden;
      display: none;
      color: #34495e;
      flex-shrink: 0;
    }
    
    #notation-container .move-item.highlighted {
      background-color: #3498db !important;
      color: white !important;
      font-weight: 600;
    }
    
    #notation-container .move-item.highlighted:hover {
      background-color: #2980b9 !important;
    }

    #notation-container::before {
      content: 'Move History (â† â†’ keys to navigate)';
      display: block;
      font-family: 'Inter', sans-serif;
      font-size: 0.95rem;
      font-weight: 600;
      color: #2c3e50;
      text-align: center;
      margin-bottom: 10px;
      opacity: 0.8;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 2px solid #e9ecef;
      position: sticky;
      top: 0;
      background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
      z-index: 1;
      margin-top: -15px;
      padding-top: 15px;
    }

    .move-pair {
      margin-bottom: 8px;
      padding: 8px 12px;
      background: white;
      border-radius: 8px;
      transition: all 0.2s ease;
    }

    .move-pair:hover {
      background: #f8f9fa;
      transform: translateX(3px);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    }

    .move-number {
      color: #7f8c8d;
      margin-right: -10px;
      font-weight: 600;
      min-width: 30px;
      display: inline-block;
    }

    .white-move {
      color: #2c3e50;
      margin-right: -10px;
      font-weight: 600;
      padding: 4px 8px;
      background: rgba(52, 152, 219, 0.08);
      border-radius: 4px;
      border-left: 3px solid #3498db;
    }

    .move-item {
      cursor: pointer;
      padding: 3px 3px;
      margin: 0;
      border-radius: 4px;
      transition: all 0.2s ease;
      display: inline-block;
    }

    .move-item:hover {
      background: rgba(52, 152, 219, 0.2);
    }

    .move-item.highlighted {
      background: #3498db;
      color: white;
      font-weight: 700;
      box-shadow: 0 2px 6px rgba(52, 152, 219, 0.4);
    }

    .black-move {
      color: #34495e;
      font-weight: 500;
      padding: 4px 8px;
      background: rgba(44, 62, 80, 0.05);
      border-radius: 4px;
      border-left: 3px solid #2c3e50;
    }

    /* Hidden State */
    #timers-container,
    #move-timer-container,
    #last-move-container,
    #notation-container {
      display: none;
    }

    /* Blindfold Mode */
    .blindfold-hidden {
      display: none !important;
    }

    #move-input-container {
      text-align: center;
      margin: 20px auto;
      padding: 20px;
      background-color: white;
      border-radius: 15px;
      border: 1px solid #e9ecef;
      max-width: 600px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    #show-history-row {
      display: none;
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      main {
        padding: 15px;
      }
      
      #board-timers-container {
        flex-direction: column;
        gap: 20px;
      }
      
      #board {
        width: 350px;
        height: 350px;
      }
      
      h2 {
        font-size: 2rem;
      }
      
      #choose-side {
        padding: 20px;
        margin: 0 10px 20px 10px;
      }
      
      .control-row {
        flex-direction: column;
        gap: 10px;
        text-align: center;
      }
      
      select, button {
        width: 200px;
        max-width: 90%;
      }
      
      #timers-container {
        min-width: 200px;
      }
    }
  </style>
</head>
<body>
    <div class="wrapper">
        <header>
            <div class="header-content">
                <a href="index.html" class="logo-link">
                    <img src="img/EagleLogo.png" alt="Ahrens Labs logo" class="header-logo">
                </a>
                <h1>Ahrens Labs</h1>
                <nav>
                    <ul>
                        <li><a href="index.html">Home</a></li>
                        <li><a href="labs.html">Labs & Projects</a></li>
                        <li><a href="contact.html">Contact</a></li>
                        <li><a href="chess_engine.html" class="active">Chess Engine</a></li>
                    </ul>
                </nav>
            </div>
        </header>
	    
	<h2>
    Play Chess against Trifang<span class="sharp">X</span>
    </h2>
  <div id="choose-side">
    <div class="control-row">
      <label for="color-select">Choose your side: </label>
      <select id="color-select">
        <option value="random">Random</option>
        <option value="white">White</option>
        <option value="black">Black</option>
      </select>
      
      <label for="time-control" style="margin-left: 15px;">Time control: </label>
      <select id="time-control">
        <option value="none">None</option>
        <option value="60">1 min</option>
        <option value="180|2">3 | 2</option>egal 
        <option value="300|0">5 min</option>
        <option value="600|0">10 min</option>
        <option value="900|5">15 | 5</option>
        <option value="3600|0">60 min</option>
      </select>
    </div>
    
    <div class="control-row style-option">
      <label for="board-style">Board Style: </label>
      <select id="board-style" onchange="changeBoardStyle()">
        <option value="classic">Classic</option>
        <option value="blue">Blue</option>
        <option value="green">Green</option>
        <option value="gray">Gray</option>
        <option value="purple">Purple</option>
        <option value="wood">Wood</option>
        <option value="coral">Coral</option>
        <option value="marble">Marble</option>
        <option value="dark">Dark</option>
        <option value="neon">Neon</option>
        <option value="emerald">Emerald</option>
        <option value="gold">Gold</option>
        <option value="ocean">Ocean</option>
        <option value="sunset">Sunset</option>
        <option value="midnight">Midnight</option>
        <option value="forest">Forest</option>
        <option value="royal">Royal</option>
        <option value="ice">Ice</option>
        <option value="cherry">Cherry</option>
        <option value="3d">3D</option>
        <option value="glass">Glass</option>
        <option value="carbon">Carbon</option>
        <option value="velvet">Velvet</option>
        <option value="stone">Stone</option>
        <option value="cyber">Cyber</option>
        <option value="luxury">Luxury</option>
      </select>
      
      <label for="piece-style" style="margin-left: 20px;">Piece Style: </label>
      <select id="piece-style" onchange="changePieceStyle()">
        <option value="wikipedia">Wikipedia</option>
        <option value="alpha">Alpha</option>
        <option value="cburnett">CBurnett</option>
        <option value="merida">Merida</option>
        <option value="pirouetti">Pirouetti</option>
        <option value="spatial">Spatial</option>
        <option value="california">California</option>
        <option value="cardinal">Cardinal</option>
        <option value="chessnut">Chessnut</option>
        <option value="chess7">Chess7</option>
        <option value="reillycraig">Reilly Craig</option>
        <option value="riohacha">Riohacha</option>
        <option value="shapes">Shapes</option>
        <option value="staunty">Staunty</option>
        <option value="tatiana">Tatiana</option>
      </select>
    </div>
    
    <div class="control-row">
      <label for="engine-style">Engine Personality:</label>
      <select id="engine-style" onchange="changeEngineStyle()">
        <option value="balanced">âš–ï¸ Balanced</option>
        <option value="aggressive">âš”ï¸ Aggressive</option>
        <option value="defensive">ðŸ›¡ï¸ Defensive</option>
        <option value="positional">ðŸŽ¯ Positional</option>
        <option value="material">ðŸ’Ž Material-Focused</option>
        <option value="tactical">âš¡ Tactical</option>
        <option value="custom">ðŸŽ›ï¸ Custom</option>
      </select>
    </div>
    
    <!-- Custom modifiers panel -->
    <div id="custom-modifiers-panel" style="display: none;">
      <div style="text-align: center; margin-bottom: 15px; font-weight: 600; color: #2c3e50;">
        Customize Engine Modifiers (0.0 - 3.0)
      </div>
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; max-width: 600px; margin: 0 auto;">
        <div class="modifier-input-group">
          <label for="mod-material">Material:</label>
          <input type="number" id="mod-material" min="0" max="3" step="0.1" value="1.0" onchange="updateCustomModifiers()">
        </div>
        <div class="modifier-input-group">
          <label for="mod-king-safety">King Safety:</label>
          <input type="number" id="mod-king-safety" min="0" max="3" step="0.1" value="1.0" onchange="updateCustomModifiers()">
        </div>
        <div class="modifier-input-group">
          <label for="mod-centralization">Centralization:</label>
          <input type="number" id="mod-centralization" min="0" max="3" step="0.1" value="1.0" onchange="updateCustomModifiers()">
        </div>
        <div class="modifier-input-group">
          <label for="mod-attack">Attack:</label>
          <input type="number" id="mod-attack" min="0" max="3" step="0.1" value="1.0" onchange="updateCustomModifiers()">
        </div>
        <div class="modifier-input-group">
          <label for="mod-piece-activity">Piece Activity:</label>
          <input type="number" id="mod-piece-activity" min="0" max="3" step="0.1" value="1.0" onchange="updateCustomModifiers()">
        </div>
        <div class="modifier-input-group">
          <label for="mod-defense">Defense:</label>
          <input type="number" id="mod-defense" min="0" max="3" step="0.1" value="1.0" onchange="updateCustomModifiers()">
        </div>
        <div class="modifier-input-group">
          <label for="mod-pawn-structure">Pawn Structure:</label>
          <input type="number" id="mod-pawn-structure" min="0" max="3" step="0.1" value="1.0" onchange="updateCustomModifiers()">
        </div>
        <div style="grid-column: 1 / -1; text-align: center; margin-top: 5px;">
          <button onclick="resetCustomModifiers()" style="padding: 8px 20px; font-size: 0.9em; background: linear-gradient(135deg, #95a5a6, #7f8c8d); border: none; border-radius: 15px; color: white; cursor: pointer; font-weight: 600;">
            Reset to 1.0
          </button>
        </div>
      </div>
    </div>
    
    <div class="control-row">
      <label for="blindfold-mode">
        <input type="checkbox" id="blindfold-mode" onchange="toggleHistoryOption()" style="margin-right: 8px;">
        Blindfold Mode
      </label>
    
      <label for="show-history" id="show-history-row" style="margin-left: 20px; display: none;">
        <input type="checkbox" id="show-history" style="margin-right: 8px;">
        Show Move History in Blindfold
      </label>
    </div>
    
    <div class="control-row">
      <label for="sound-effects">
        <input type="checkbox" id="sound-effects" checked style="margin-right: 8px;">
        ðŸ”Š Sound Effects
      </label>
    </div>
    
    <div class="control-row">
      <button onclick="startGame()">Start Game</button>
    </div>
  </div>

  <div id="game-container">
    <div style="display: flex; justify-content: center; align-items: center; gap: 20px; flex-wrap: wrap; margin: 20px auto;">
      <div id="move-timer-container">
        Time for this move: <span id="timer">00:00.00</span>
      </div>
      <div id="last-move-container">
        Turn: <span id="turn-color">White</span> | Last Move: <span id="last-move">None</span>
      </div>
    </div>

    <div id="board-row">
      <div id="board-with-captures">
        <div id="captured-pieces-left">
          <div class="captured-section" id="black-captured-section">
            <div class="captured-section-title">Black Pieces</div>
            <div class="captured-pieces-display" id="black-captures-display"></div>
          </div>
          <div class="captured-section" id="white-captured-section">
            <div class="captured-section-title">White Pieces</div>
            <div class="captured-pieces-display" id="white-captures-display"></div>
          </div>
        </div>

        <div id="board-timers-container">
          <div id="board"></div>
          <button id="flip-board-btn" onclick="flipBoard()" style="background: rgba(52, 152, 219, 0.9); color: white; border: none; border-radius: 8px; padding: 8px 12px; cursor: pointer; font-size: 0.9em; font-weight: 600; box-shadow: 0 2px 8px rgba(0,0,0,0.2); display: none; transition: all 0.3s ease; margin-top: 10px; width: 100%; max-width: 200px;" onmouseover="this.style.background='rgba(52, 152, 219, 1)'" onmouseout="this.style.background='rgba(52, 152, 219, 0.9)'">ðŸ”„ Flip Board</button>

          <div id="timers-container">
              <!-- The divs here will be reordered by JavaScript in startGame() based on playerColor. -->
              <!-- They now have IDs for easier manipulation -->
            <div id="time-slot-white" class="time-slot">
              White Time Left: <span id="white-total">--:--.--</span>
            </div>
            <div id="time-slot-black" class="time-slot">
              Black Time Left: <span id="black-total">--:--.--</span>
            </div>
          </div>
        </div>
      </div>

      <div id="right-panel">
        <div id="opening-display">
          <div class="opening-label">Opening:</div>
          <div class="opening-name" id="opening-name">-</div>
        </div>

      <div id="game-stats-panel">
        <h3>Game Statistics</h3>
        <div class="stats-row">
          <span class="stats-label">Material Balance:</span>
          <span class="stats-value material-advantage" id="material-balance">Equal</span>
        </div>
        <div class="stats-row">
          <span class="stats-label">Game Phase:</span>
          <span class="stats-value" id="game-phase">Opening</span>
        </div>
        <div class="stats-row">
          <span class="stats-label">Pieces on Board:</span>
          <span class="stats-value" id="pieces-count">32</span>
        </div>
        <div class="stats-row">
          <span class="stats-label">Check Status:</span>
          <span class="stats-value" id="check-status">None</span>
        </div>
        <div class="stats-row">
          <span class="stats-label">Castling Rights:</span>
          <span class="stats-value" id="castling-rights">Both</span>
        </div>
      </div>

      <div id="notation-container"></div>

      <div id="player-stats-panel" style="display: none; background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%); padding: 15px; border-radius: 10px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06); margin: 15px auto; max-width: 600px; border: 1px solid rgba(52, 152, 219, 0.1); font-family: 'Inter', sans-serif;">
        <h3 style="text-align: center; font-size: 1.05rem; font-weight: 600; color: #2c3e50; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 2px solid #e9ecef;">Your Statistics</h3>
        <div class="stats-row">
          <span class="stats-label">Games Played:</span>
          <span class="stats-value" id="total-games">0</span>
        </div>
        <div class="stats-row">
          <span class="stats-label">Wins:</span>
          <span class="stats-value" style="color: #2ecc71; font-weight: 700;" id="total-wins">0</span>
        </div>
        <div class="stats-row">
          <span class="stats-label">Losses:</span>
          <span class="stats-value" style="color: #e74c3c; font-weight: 700;" id="total-losses">0</span>
        </div>
        <div class="stats-row">
          <span class="stats-label">Draws:</span>
          <span class="stats-value" style="color: #7f8c8d; font-weight: 700;" id="total-draws">0</span>
        </div>
        <div class="stats-row">
          <span class="stats-label">Win Rate:</span>
          <span class="stats-value" style="font-weight: 700;" id="win-rate">0%</span>
        </div>
      </div>

      <div id="achievements-panel" style="display: none; background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%); padding: 15px; border-radius: 10px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06); margin: 15px auto; max-width: 600px; border: 1px solid rgba(52, 152, 219, 0.1); font-family: 'Inter', sans-serif;">
        <h3 style="text-align: center; font-size: 1.05rem; font-weight: 600; color: #2c3e50; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 2px solid #e9ecef;">ðŸ† Achievements</h3>
        <div style="text-align: center; margin-bottom: 12px; padding: 10px; background: linear-gradient(135deg, #f39c12, #e67e22); color: white; border-radius: 8px; font-weight: 700; font-size: 1.1em;">
          <div style="font-size: 0.85em; opacity: 0.95; margin-bottom: 4px;">Total Points</div>
          <div id="total-achievement-points" style="font-size: 1.5em;">0</div>
        </div>
        <div id="achievements-list" style="max-height: 200px; overflow-y: auto;"></div>
        <button onclick="showAllAchievements()" style="width: 100%; margin-top: 10px; padding: 10px; background: linear-gradient(135deg, #3498db, #2980b9); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 0.95em; transition: all 0.3s ease;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(52, 152, 219, 0.3)'" onmouseout="this.style.transform=''; this.style.boxShadow=''">View All Achievements</button>
      </div>

      <div id="game-buttons">
        <button id="export-pgn-btn" onclick="exportPGN()">Export Game (PGN)</button>
        <button id="resign-btn" onclick="resignGame()" style="display: none;">Resign</button>
      </div>
    </div>
  </div>

  <!-- Custom Confirmation Modal -->
  <div id="confirm-modal">
    <div class="confirm-dialog">
      <h3>âš ï¸ Resign Game?</h3>
      <p>Are you sure you want to resign? This cannot be undone.</p>
      <div class="confirm-buttons">
        <button class="confirm-no" onclick="closeConfirmModal()">Cancel</button>
        <button class="confirm-yes" onclick="confirmResign()">Resign</button>
      </div>
    </div>
  </div>

  <!-- Rematch Modal -->
  <div id="rematch-modal">
    <div class="rematch-dialog">
      <h3 id="rematch-title">Game Over</h3>
      <p id="rematch-message">Would you like to play again?</p>
      <div class="rematch-buttons">
        <button class="rematch-yes" onclick="startRematch()">ðŸ”„ Rematch</button>
        <button class="rematch-no" onclick="closeRematchModal()">Close</button>
      </div>
    </div>
  </div>

  <!-- All Achievements Modal -->
  <div id="all-achievements-modal">
    <div class="all-achievements-dialog">
      <div class="achievements-header">
        <h2>ðŸ† All Achievements</h2>
        <button class="close-achievements-btn" onclick="closeAllAchievements()">âœ•</button>
      </div>
      <div id="all-achievements-list" class="achievements-grid"></div>
    </div>
  </div>

  <div id="move-input-container" style="display: none;">
    <input type="text" id="move-input" placeholder="Enter move (e.g., e4, Nf3, O-O)" 
           onkeypress="if(event.key === 'Enter') submitMove()"
           style="padding: 12px 18px; font-size: 1.1em; border: 2px solid #3498db; 
                  border-radius: 20px; margin-right: 10px; font-family: 'Inter', sans-serif;
                  box-shadow: 0 2px 8px rgba(52, 152, 219, 0.1);">
    <button onclick="submitMove()" 
            style="padding: 12px 24px; font-size: 1.1em; background-color: #3498db; 
                   color: white; border: none; border-radius: 20px; cursor: pointer;
                   font-family: 'Inter', sans-serif; font-weight: 600; max-width: none;">
      Submit Move
    </button>
  </div>

  <script>
    let game, board;
    let playerColor = "white";
    let timerStart = 0;
    let timerInterval = null;
    let whiteTime, blackTime, increment;
    let timeLimited = false;
    let gameOver = false;
    let blindfoldMode = false;
    let showHistoryInBlindfold = false;
    let moveHistory = [];
    let currentMoveIndex = -1;
    let capturedPieces = { white: [], black: [] };
    let lastMoveSquares = { from: null, to: null };
    let gameStartTime = null;
    let currentPieceStyle = 'wikipedia';
    let premoves = []; // Store array of premoves as [{from: 'e2', to: 'e4'}, ...]
    let selectedSquare = null; // Track clicked piece for click-to-move
    let currentEngineStyle = 'balanced'; // Track current engine personality
    let soundEnabled = true; // Sound effects toggle
    let playerStats = { wins: 0, losses: 0, draws: 0 }; // Player statistics
    let achievements = []; // Achievements unlocked
    let gameStats = { // In-game statistics for achievements
      capturesByQueen: 0,
      capturesByRook: 0,
      capturesByBishop: 0,
      capturesByKnight: 0,
      capturesByPawn: 0,
      totalCaptures: 0,
      checksGiven: 0,
      castlingMoves: 0,
      promotions: 0,
      enPassants: 0,
      longestGame: 0,
      shortestWin: Infinity
    };
    let lifetimeStats = { // Lifetime statistics
      capturesByQueen: 0,
      capturesByRook: 0,
      capturesByBishop: 0,
      capturesByKnight: 0,
      capturesByPawn: 0,
      totalCaptures: 0,
      checksGiven: 0,
      castlingMoves: 0,
      promotions: 0,
      enPassants: 0,
      longestGame: 0,
      shortestWin: Infinity,
      // Track what pieces were captured (not what captured them)
      capturedQueens: 0,
      capturedRooks: 0,
      capturedBishops: 0,
      capturedKnights: 0,
      capturedPawns: 0
    };

    // Engine personality presets
    const enginePersonalities = {
      balanced: {
        material: 1.0,
        king_safety_b: 1.0, king_safety_w: 1.0,
        centralization_b: 1.0, centralization_w: 1.0,
        attack_b: 1.0, attack_w: 1.0,
        piece_activity_b: 1.0, piece_activity_w: 1.0,
        defense_b: 1.0, defense_w: 1.0,
        pawn_structure_b: 1.0, pawn_structure_w: 1.0
      },
      aggressive: {
        material: 0.7,
        king_safety_b: 0.5, king_safety_w: 0.5,
        centralization_b: 1.5, centralization_w: 1.5,
        attack_b: 2.5, attack_w: 2.5,
        piece_activity_b: 1.8, piece_activity_w: 1.8,
        defense_b: 0.4, defense_w: 0.4,
        pawn_structure_b: 0.6, pawn_structure_w: 0.6
      },
      defensive: {
        material: 1.2,
        king_safety_b: 2.2, king_safety_w: 2.2,
        centralization_b: 0.7, centralization_w: 0.7,
        attack_b: 0.5, attack_w: 0.5,
        piece_activity_b: 0.6, piece_activity_w: 0.6,
        defense_b: 2.0, defense_w: 2.0,
        pawn_structure_b: 1.8, pawn_structure_w: 1.8
      },
      positional: {
        material: 0.8,
        king_safety_b: 1.4, king_safety_w: 1.4,
        centralization_b: 2.0, centralization_w: 2.0,
        attack_b: 0.7, attack_w: 0.7,
        piece_activity_b: 1.5, piece_activity_w: 1.5,
        defense_b: 1.6, defense_w: 1.6,
        pawn_structure_b: 1.9, pawn_structure_w: 1.9
      },
      material: {
        material: 2.5,
        king_safety_b: 0.7, king_safety_w: 0.7,
        centralization_b: 0.6, centralization_w: 0.6,
        attack_b: 0.9, attack_w: 0.9,
        piece_activity_b: 0.5, piece_activity_w: 0.5,
        defense_b: 0.7, defense_w: 0.7,
        pawn_structure_b: 1.1, pawn_structure_w: 1.1
      },
      tactical: {
        material: 0.9,
        king_safety_b: 0.6, king_safety_w: 0.6,
        centralization_b: 1.6, centralization_w: 1.6,
        attack_b: 2.2, attack_w: 2.2,
        piece_activity_b: 2.0, piece_activity_w: 2.0,
        defense_b: 0.7, defense_w: 0.7,
        pawn_structure_b: 0.8, pawn_structure_w: 0.8
      },
      custom: {
        material: 1.0,
        king_safety_b: 1.0, king_safety_w: 1.0,
        centralization_b: 1.0, centralization_w: 1.0,
        attack_b: 1.0, attack_w: 1.0,
        piece_activity_b: 1.0, piece_activity_w: 1.0,
        defense_b: 1.0, defense_w: 1.0,
        pawn_structure_b: 1.0, pawn_structure_w: 1.0
      }
    };

    // Piece style themes
    const pieceThemes = {
      wikipedia: 'lib/img/chesspieces/wikipedia/{piece}.png',
      alpha: 'https://lichess1.org/assets/piece/alpha/{piece}.svg',
      cburnett: 'https://lichess1.org/assets/piece/cburnett/{piece}.svg',
      merida: 'https://lichess1.org/assets/piece/merida/{piece}.svg',
      pirouetti: 'https://lichess1.org/assets/piece/pirouetti/{piece}.svg',
      spatial: 'https://lichess1.org/assets/piece/spatial/{piece}.svg',
      california: 'https://lichess1.org/assets/piece/california/{piece}.svg',
      cardinal: 'https://lichess1.org/assets/piece/cardinal/{piece}.svg',
      chessnut: 'https://lichess1.org/assets/piece/chessnut/{piece}.svg',
      chess7: 'https://lichess1.org/assets/piece/chess7/{piece}.svg',
      reillycraig: 'https://lichess1.org/assets/piece/reillycraig/{piece}.svg',
      riohacha: 'https://lichess1.org/assets/piece/riohacha/{piece}.svg',
      shapes: 'https://lichess1.org/assets/piece/shapes/{piece}.svg',
      staunty: 'https://lichess1.org/assets/piece/staunty/{piece}.svg',
      tatiana: 'https://lichess1.org/assets/piece/tatiana/{piece}.svg'
    };

    // Opening Book Database
    const openingBook = {
      "e4": "King's Pawn Opening",
      "e4 e5": "Open Game",
      "e4 e5 Nf3 Nc6 Bb5": "Ruy Lopez (Spanish Opening)",
      "e4 e5 Nf3 Nc6 Bb5 a6": "Ruy Lopez: Morphy Defense",
      "e4 e5 Nf3 Nc6 Bb5 a6 Ba4 Nf6 O-O": "Ruy Lopez: Closed Variation",
      "e4 e5 Nf3 Nc6 Bb5 a6 Ba4 Nf6 O-O Be7": "Ruy Lopez: Closed, Chigorin Defense",
      "e4 e5 Nf3 Nc6 Bb5 Nf6": "Ruy Lopez: Berlin Defense",
      "e4 e5 Nf3 Nc6 Bc4": "Italian Game",
      "e4 e5 Nf3 Nc6 Bc4 Bc5": "Italian Game: Giuoco Piano",
      "e4 e5 Nf3 Nc6 Bc4 Bc5 c3": "Italian Game: Giuoco Pianissimo",
      "e4 e5 Nf3 Nc6 Bc4 Bc5 b4": "Italian Game: Evans Gambit",
      "e4 e5 Nf3 Nc6 Bc4 Nf6": "Italian Game: Two Knights Defense",
      "e4 e5 Nf3 Nf6": "Petrov's Defense (Russian Game)",
      "e4 c5": "Sicilian Defense",
      "e4 c5 Nf3 d6": "Sicilian Defense: Open Variation",
      "e4 c5 Nf3 d6 d4 cxd4 Nxd4 Nf6 Nc3 a6": "Sicilian Defense: Najdorf Variation",
      "e4 c5 Nf3 d6 d4 cxd4 Nxd4 Nf6 Nc3 g6": "Sicilian Defense: Dragon Variation",
      "e4 c5 Nf3 d6 d4 cxd4 Nxd4 Nf6 Nc3 e6": "Sicilian Defense: Scheveningen Variation",
      "e4 c5 Nf3 Nc6": "Sicilian Defense: Closed Variation",
      "e4 c5 Nf3 e6": "Sicilian Defense: French Variation",
      "e4 c5 c3": "Sicilian Defense: Alapin Variation",
      "e4 e6": "French Defense",
      "e4 e6 d4 d5": "French Defense: Main Line",
      "e4 e6 d4 d5 Nc3": "French Defense: Classical Variation",
      "e4 e6 d4 d5 Nd2": "French Defense: Tarrasch Variation",
      "e4 e6 d4 d5 exd5": "French Defense: Exchange Variation",
      "e4 c6": "Caro-Kann Defense",
      "e4 c6 d4 d5": "Caro-Kann Defense: Main Line",
      "e4 c6 d4 d5 Nc3": "Caro-Kann Defense: Classical Variation",
      "e4 c6 d4 d5 exd5": "Caro-Kann Defense: Exchange Variation",
      "e4 d5": "Scandinavian Defense (Center Counter)",
      "e4 d5 exd5 Qxd5": "Scandinavian Defense: Main Line",
      "e4 d5 exd5 Nf6": "Scandinavian Defense: Modern Variation",
      "d4": "Queen's Pawn Opening",
      "d4 d5": "Closed Game",
      "d4 d5 c4": "Queen's Gambit",
      "d4 d5 c4 e6": "Queen's Gambit Declined",
      "d4 d5 c4 e6 Nc3 Nf6": "Queen's Gambit Declined: Orthodox Variation",
      "d4 d5 c4 e6 Nc3 Nf6 Bg5": "Queen's Gambit Declined: Classical Variation",
      "d4 d5 c4 c6": "Slav Defense",
      "d4 d5 c4 c6 Nf3 Nf6 Nc3 dxc4": "Slav Defense: Accepted Variation",
      "d4 d5 c4 c6 Nf3 Nf6 Nc3 e6": "Semi-Slav Defense",
      "d4 d5 c4 dxc4": "Queen's Gambit Accepted",
      "d4 Nf6 c4 g6": "King's Indian Defense",
      "d4 Nf6 c4 g6 Nc3 Bg7": "King's Indian Defense: Main Line",
      "d4 Nf6 c4 g6 Nc3 Bg7 e4": "King's Indian Defense: Classical Variation",
      "d4 Nf6 c4 e6": "Indian Defense",
      "d4 Nf6 c4 e6 Nc3 Bb4": "Nimzo-Indian Defense",
      "d4 Nf6 c4 e6 Nc3 Bb4 Qc2": "Nimzo-Indian Defense: Classical Variation",
      "d4 Nf6 c4 e6 Nc3 Bb4 e3": "Nimzo-Indian Defense: Rubinstein Variation",
      "d4 Nf6 c4 e6 Nf3 b6": "Queen's Indian Defense",
      "d4 Nf6 Nf3 g6": "King's Indian Attack",
      "d4 Nf6 Nf3 e6": "Indian Game",
      "d4 Nf6 c4 c5 d5": "Benoni Defense: Modern Benoni",
      "d4 Nf6 c4 c5 d5 e6": "Benoni Defense: Modern Variation",
      "Nf3": "RÃ©ti Opening",
      "Nf3 d5 c4": "RÃ©ti Opening: Anglo-Slav Variation",
      "Nf3 Nf6 c4 g6": "RÃ©ti Opening: King's Indian Attack",
      "c4": "English Opening",
      "c4 e5": "English Opening: Reversed Sicilian",
      "c4 Nf6": "English Opening: Anglo-Indian Defense",
      "c4 c5": "English Opening: Symmetrical Variation",
      "e4 e5 Nf3 Nc6 d4": "Scotch Game",
      "e4 e5 Nf3 Nc6 d4 exd4 Nxd4": "Scotch Game: Main Line",
      "e4 e5 Nf3 Nc6 Nc3": "Four Knights Game",
      "e4 e5 Nf3 Nc6 Nc3 Nf6": "Four Knights Game: Spanish Variation",
      "e4 e5 f4": "King's Gambit",
      "e4 e5 f4 exf4": "King's Gambit Accepted",
      "e4 e5 f4 Bc5": "King's Gambit Declined: Classical Defense",
      "d4 Nf6 Bg5": "Trompowsky Attack",
      "d4 Nf6 Bg5 Ne4": "Trompowsky Attack: Main Line",
      "d4 d5 Nf3": "London System",
      "d4 d5 Nf3 Nf6 Bf4": "London System: Main Line",
      "e4 g6": "Modern Defense",
      "e4 g6 d4 Bg7": "Modern Defense: Gurgenidze System",
      "e4 g6 d4 Bg7 Nc3 d6": "Modern Defense: Pseudo-Austrian Attack",
      "e4 Nc6": "Nimzowitsch Defense",
      "e4 Nc6 d4 e5": "Nimzowitsch Defense: Scandinavian Variation",
      "d4 f5": "Dutch Defense",
      "d4 f5 g3": "Dutch Defense: Leningrad Variation",
      "d4 f5 Nf3 Nf6 g3 g6 Bg2 Bg7": "Dutch Defense: Leningrad System",
      "d4 f5 c4 Nf6": "Dutch Defense: Classical Variation",
      "d4 f5 e4": "Dutch Defense: Staunton Gambit",
      "f4": "Bird's Opening",
      "f4 d5": "Bird's Opening: From's Gambit",
      "f4 e5": "Bird's Opening: From Gambit",
      "e4 e5 Nf3 Nc6 Bb5 a6 Ba4 Nf6": "Ruy Lopez: Open Defense",
      "e4 e5 Nf3 Nc6 Bb5 a6 Ba4 Nf6 O-O Nxe4": "Ruy Lopez: Open Variation",
      "e4 e5 Nf3 Nc6 Bb5 a6 Ba4 Nf6 O-O Be7 Re1 b5 Bb3 d6": "Ruy Lopez: Closed, Zaitsev Variation",
      "e4 e5 Nf3 Nc6 Bb5 a6 Ba4 Nf6 O-O Be7 Re1 b5 Bb3 d6 c3 O-O": "Ruy Lopez: Closed, Breyer Variation",
      "e4 e5 Nf3 Nc6 Bb5 a6 Ba4 Nf6 O-O Nxe4 d4": "Ruy Lopez: Open, Howell Attack",
      "e4 e5 Nf3 Nc6 Bc4 Bc5 b4 Bxb4 c3": "Italian Game: Evans Gambit Accepted",
      "e4 e5 Nf3 Nc6 Bc4 Nf6 d4": "Italian Game: Two Knights Defense, Max Lange Attack",
      "e4 e5 Nf3 Nc6 Bc4 Nf6 Ng5": "Italian Game: Two Knights Defense, Fried Liver Attack",
      "e4 e5 Nf3 Nf6 Nxe5": "Petrov's Defense: Steinitz Attack",
      "e4 e5 Nf3 Nf6 Nxe5 d6": "Petrov's Defense: Classical Variation",
      "e4 e5 Nf3 Nf6 d4": "Petrov's Defense: Three Knights Game",
      "e4 c5 Nf3 d6 d4 cxd4 Nxd4 Nf6 Nc3 a6 Be3": "Sicilian Defense: Najdorf, English Attack",
      "e4 c5 Nf3 d6 d4 cxd4 Nxd4 Nf6 Nc3 a6 Be2": "Sicilian Defense: Najdorf, Classical Variation",
      "e4 c5 Nf3 d6 d4 cxd4 Nxd4 Nf6 Nc3 g6 Be3 Bg7": "Sicilian Defense: Dragon, Yugoslav Attack",
      "e4 c5 Nf3 e6 d4 cxd4 Nxd4 a6": "Sicilian Defense: Kan Variation",
      "e4 c5 Nf3 e6 d4 cxd4 Nxd4 Nc6": "Sicilian Defense: Taimanov Variation",
      "e4 c5 Nf3 e6 d4 cxd4 Nxd4 Nc6 Nc3 Qc7": "Sicilian Defense: Taimanov, English Attack",
      "e4 c5 Nf3 e6 c3": "Sicilian Defense: Smith-Morra Gambit",
      "e4 c5 Nf3 e6 c3 d5": "Sicilian Defense: Smith-Morra Gambit Declined",
      "e4 c5 c3 Nf6": "Sicilian Defense: Alapin, Barmen Variation",
      "e4 c5 c3 d5": "Sicilian Defense: Alapin, Normal Variation",
      "e4 e6 d4 d5 Nc3 Bb4": "French Defense: Winawer Variation",
      "e4 e6 d4 d5 Nc3 Bb4 e5": "French Defense: Winawer, Advance Variation",
      "e4 e6 d4 d5 Nc3 Bb4 e5 c5": "French Defense: Winawer, Poisoned Pawn",
      "e4 e6 d4 d5 Nc3 Nf6": "French Defense: Alekhine-Chatard Attack",
      "e4 e6 d4 d5 Nd2 c5": "French Defense: Tarrasch, Guimard Variation",
      "e4 e6 d4 d5 Nd2 Nf6": "French Defense: Tarrasch, Leningrad Variation",
      "e4 e6 d4 d5 exd5 exd5": "French Defense: Exchange, Classical Variation",
      "e4 c6 d4 d5 Nc3 dxe4 Nxe4 Bf5": "Caro-Kann Defense: Classical Variation",
      "e4 c6 d4 d5 Nc3 dxe4 Nxe4 Nd7": "Caro-Kann Defense: Karpov Variation",
      "e4 c6 d4 d5 Nc3 dxe4 Nxe4 Bf5 Ng3 Bg6": "Caro-Kann Defense: Classical, Main Line",
      "e4 c6 d4 d5 Nc3 dxe4 Nxe4 Nd7 Nf3 Ngf6": "Caro-Kann Defense: Karpov, Main Line",
      "e4 d5 exd5 Nf6 c4 e6": "Scandinavian Defense: Modern, Main Line",
      "e4 d5 exd5 Qxd5 Nc3 Qa5": "Scandinavian Defense: Main Line, Gubinsky-Melts Defense",
      "e4 d5 exd5 Qxd5 Nc3 Qd6": "Scandinavian Defense: Main Line, Modern Variation",
      "d4 d5 c4 e6 Nf3": "Queen's Gambit Declined: Orthodox",
      "d4 d5 c4 e6 Nf3 Nf6": "Queen's Gambit Declined: Orthodox, Main Line",
      "d4 d5 c4 e6 Nf3 Nf6 Nc3 Be7": "Queen's Gambit Declined: Orthodox, Classical",
      "d4 d5 c4 e6 Nf3 Nf6 Nc3 Be7 Bg5": "Queen's Gambit Declined: Orthodox, Tartakower Variation",
      "d4 d5 c4 e6 Nf3 Nf6 cxd5": "Queen's Gambit Declined: Exchange Variation",
      "d4 d5 c4 c6 Nf3 Nf6 e3": "Slav Defense: Quiet Variation",
      "d4 d5 c4 c6 Nf3 Nf6 Nc3 dxc4 a4": "Slav Defense: Alekhine Variation",
      "d4 d5 c4 c6 Nf3 Nf6 e3 Bf5": "Slav Defense: Modern Variation",
      "d4 d5 c4 c6 Nf3 Nf6 Nc3 e6 Bg5": "Semi-Slav Defense: Botvinnik Variation",
      "d4 d5 c4 c6 Nf3 Nf6 Nc3 e6 e3": "Semi-Slav Defense: Meran Variation",
      "d4 Nf6 c4 g6 Nc3 Bg7 e4 d6": "King's Indian Defense: Classical, Main Line",
      "d4 Nf6 c4 g6 Nc3 Bg7 e4 d6 Nf3 O-O Be2 e5": "King's Indian Defense: Classical, Petrosian System",
      "d4 Nf6 c4 g6 Nc3 Bg7 e4 d6 f3": "King's Indian Defense: SÃ¤misch Variation",
      "d4 Nf6 c4 g6 Nc3 Bg7 e4 d6 f4": "King's Indian Defense: Four Pawns Attack",
      "d4 Nf6 c4 g6 Nc3 Bg7 e4 d6 Nge2": "King's Indian Defense: Averbakh Variation",
      "d4 Nf6 c4 g6 Nf3 Bg7": "King's Indian Defense: Fianchetto Variation",
      "d4 Nf6 c4 e6 Nc3 Bb4 a3": "Nimzo-Indian Defense: Samisch Variation",
      "d4 Nf6 c4 e6 Nc3 Bb4 Nf3": "Nimzo-Indian Defense: Classical, Ragozin Defense",
      "d4 Nf6 c4 e6 Nc3 Bb4 Nf3 c5": "Nimzo-Indian Defense: Classical, HÃ¼bner Variation",
      "d4 Nf6 c4 e6 Nf3 b6 g3": "Queen's Indian Defense: Fianchetto Variation",
      "d4 Nf6 c4 e6 Nf3 b6 a3": "Queen's Indian Defense: Petrosian Variation",
      "d4 Nf6 c4 e6 Nf3 b6 Nc3": "Queen's Indian Defense: Classical Variation",
      "d4 Nf6 c4 c5 d5 b5": "Benoni Defense: Modern, Benko Gambit",
      "d4 Nf6 c4 c5 d5 b5 cxb5 a6": "Benoni Defense: Modern, Benko Gambit Accepted",
      "d4 Nf6 c4 c5 d5 e5": "Benoni Defense: Czech Benoni",
      "Nf3 d5 d4": "RÃ©ti Opening: Slav System",
      "Nf3 d5 c4 d4": "RÃ©ti Opening: Slav, Alapin Variation",
      "Nf3 Nf6 c4 c5": "RÃ©ti Opening: Symmetrical Variation",
      "Nf3 Nf6 c4 e6": "RÃ©ti Opening: English Defense",
      "c4 e5 Nc3": "English Opening: Reversed Dragon",
      "c4 e5 Nc3 Nf6": "English Opening: Reversed Dragon, Yugoslav Attack",
      "c4 Nf6 Nc3 e5": "English Opening: Symmetrical, Botvinnik System",
      "c4 c5 Nf3": "English Opening: Symmetrical, Hedgehog System",
      "e4 e5 Nf3 Nc6 d4 exd4 Nxd4 Nf6": "Scotch Game: Schmidt Variation",
      "e4 e5 Nf3 Nc6 d4 exd4 Nxd4 Bc5": "Scotch Game: Classical Variation",
      "e4 e5 Nf3 Nc6 Nc3 Nf6 Bb5": "Four Knights Game: Spanish Variation",
      "e4 e5 Nf3 Nc6 Nc3 Nf6 Bb5 Nd4": "Four Knights Game: Spanish, Rubinstein Variation",
      "e4 e5 Nf3 Nc6 Nc3 Nf6 d4": "Four Knights Game: Scotch Variation",
      "e4 e5 Nc3": "Vienna Game",
      "e4 e5 Nc3 Nf6": "Vienna Game: Falkbeer Variation",
      "e4 e5 Nc3 Nf6 f4": "Vienna Game: Gambit",
      "e4 e5 Nc3 Bc5": "Vienna Game: Frankenstein-Dracula Variation",
      "e4 e5 Bc4": "Bishop's Opening",
      "e4 e5 Bc4 Nf6": "Bishop's Opening: Berlin Defense",
      "e4 e5 Bc4 Nc6": "Bishop's Opening: Classical Defense",
      "e4 e5 Nf3 Nc6 Bc4 Bc5 d3": "Italian Game: Giuoco Pianissimo, Main Line",
      "e4 e5 Nf3 Nc6 Bc4 Bc5 O-O": "Italian Game: Giuoco Pianissimo, Modern Variation",
      "e4 e5 f4 exf4 Nf3": "King's Gambit: Accepted, Modern Defense",
      "e4 e5 f4 exf4 Nf3 g5": "King's Gambit: Accepted, Classical Defense",
      "e4 e5 f4 exf4 Nf3 g5 h4": "King's Gambit: Accepted, Allgaier Gambit",
      "e4 e5 f4 exf4 Nc3": "King's Gambit: Accepted, Quade Gambit",
      "e4 e5 f4 Bc5": "King's Gambit: Declined, Classical Defense",
      "e4 e5 f4 d5": "King's Gambit: Declined, Falkbeer Countergambit",
      "d4 d5 Nf3 Nf6 Bf4": "London System: Main Line",
      "d4 d5 Nf3 Nf6 Bf4 c5": "London System: Normal Variation",
      "d4 d5 Nf3 Nf6 Bf4 Bf5": "London System: Symmetrical Variation",
      "d4 Nf6 Bg5 c5": "Trompowsky Attack: Classical Defense",
      "d4 Nf6 Bg5 Ne4 Bf4": "Trompowsky Attack: Raptor Variation",
      "d4 Nf6 Bg5 e6": "Trompowsky Attack: French Variation",
      "d4 Nf6 Nf3 e6 c4": "Indian Defense: Nimzowitsch Variation",
      "d4 Nf6 Nf3 e6 c4 Bb4+": "Indian Defense: Bogo-Indian Defense",
      "d4 Nf6 Nf3 e6 c4 Bb4+ Bd2": "Bogo-Indian Defense: Modern Variation",
      "d4 Nf6 c4 e6 Nc3 Bb4 Qb3": "Nimzo-Indian Defense: Spielmann Variation",
      "d4 Nf6 c4 e6 Nc3 Bb4 e3 O-O": "Nimzo-Indian Defense: Capablanca Variation",
      "d4 Nf6 c4 e6 Nc3 Bb4 a3 Bxc3+": "Nimzo-Indian Defense: Samisch, Main Line",
      "d4 Nf6 c4 e6 Nc3 Bb4 a3 Bxc3+ bxc3": "Nimzo-Indian Defense: Samisch, Orthodox",
      "e4 e5 Nf3 Nc6 d3": "King's Pawn Opening: RÃ©ti System",
      "e4 e5 Nf3 Nc6 Be2": "King's Pawn Opening: Modern Variation",
      "e4 e5 Nf3 Nc6 g3": "King's Pawn Opening: Konstantinopolsky Variation",
      "e4 e5 Nf3 Nc6 c3": "King's Pawn Opening: Ponziani Opening",
      "e4 e5 Nf3 Nc6 c3 d5": "Ponziani Opening: Steinitz Variation",
      "d4 d5 c4 c5": "Queen's Gambit: Slav, Marshall Gambit",
      "d4 d5 c4 e5": "Queen's Gambit: Albin Countergambit",
      "d4 d5 c4 e5 dxe5 d4": "Queen's Gambit: Albin Countergambit Accepted",
      "d4 d5 Nf3": "Queen's Pawn Opening: Zukertort Opening",
      "d4 Nf6": "Indian Game: Wade-Tartakower Defense",
      "Nf3 d5": "Zukertort Opening: Dutch Variation",
      "Nf3 d5 c4": "RÃ©ti Opening: Anglo-Slav, Main Line",
      "Nf3 d5 g3": "RÃ©ti Opening: Fianchetto Variation",
      "b4": "Sokolsky Opening (Orangutan)",
      "b4 e5": "Sokolsky Opening: Outflank Variation",
      "b4 c6": "Sokolsky Opening: Outflank Defense",
      "g4": "Grob Opening",
      "g4 d5": "Grob Opening: Spike Attack",
      "Nc3": "Dunst Opening",
      "Nc3 d5": "Dunst Opening: Normal Defense",
      "Nc3 e5": "Dunst Opening: Sicilian Variation",
      "e3": "Van't Kruijs Opening",
      "e3 d5": "Van't Kruijs Opening: Normal Defense",
      "d3": "Mieses Opening",
      "d3 d5": "Mieses Opening: Reversed Philidor",
      "a4": "Ware Opening",
      "a4 e5": "Ware Opening: Crab Variation",
      "h4": "Kadas Opening",
      "h4 e5": "Kadas Opening: Normal Defense",
      "Na3": "Durkin Opening",
      "f3": "Barnes Opening",
      "f3 e5": "Barnes Opening: Gedult Attack",
      "Nh3": "Amar Opening",
      "b3": "Larsen Opening",
      "b3 e5": "Larsen Opening: Classical Variation",
      "g3": "Benko Opening",
      "g3 d5": "Benko Opening: Reversed Alekhine",
      "c3": "Saragossa Opening",
      "c3 e5": "Saragossa Opening: Normal Variation",
      "b3": "Larsen's Opening (Queen's Fianchetto)"
    };

    // --- sendEngineCommand function ---
    function sendEngineCommand(endpoint) {
    // Key change: Add 'return' here to return the promise chain
    return fetch(`https://hedgehoglover23.pythonanywhere.com/${endpoint}`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({})
    })
    .then(response => {
        if (!response.ok) {
            return response.json().then(err => {
                throw new Error(`Server error for /${endpoint}: ${err.message || response.statusText}`);
            }).catch(() => {
                throw new Error(`Server error for /${endpoint}: ${response.status} ${response.statusText}`);
            });
        }
        return response.json(); // This 'return' passes the parsed data down
    })
    .then(data => {
        console.log(`Command /${endpoint} successful:`, data.message || data.status || data);
        return data; // This 'return data' is correct for the internal chain
    })
    .catch(error => {
        console.error(`Error sending command /${endpoint}:`, error);
        throw error; // Propagate the error so the awaiting function can catch it
    });
}

    function toggleHistoryOption() {
      const blindfoldChecked = document.getElementById("blindfold-mode").checked;
      const historyRow = document.getElementById("show-history-row");
      if (blindfoldChecked) {
        historyRow.style.display = "inline-block";
      } else {
        historyRow.style.display = "none";
      }
    }

    function updateCustomModifiers() {
      // Helper function to clamp values between 0 and 3
      const clampValue = (value) => {
        const num = parseFloat(value);
        if (isNaN(num)) return 1.0;
        return Math.max(0, Math.min(3, num));
      };
      
      // Get values and clamp them
      const material = clampValue(document.getElementById('mod-material').value);
      const kingSafety = clampValue(document.getElementById('mod-king-safety').value);
      const centralization = clampValue(document.getElementById('mod-centralization').value);
      const attack = clampValue(document.getElementById('mod-attack').value);
      const pieceActivity = clampValue(document.getElementById('mod-piece-activity').value);
      const defense = clampValue(document.getElementById('mod-defense').value);
      const pawnStructure = clampValue(document.getElementById('mod-pawn-structure').value);
      
      // Update input fields with clamped values
      document.getElementById('mod-material').value = material.toFixed(1);
      document.getElementById('mod-king-safety').value = kingSafety.toFixed(1);
      document.getElementById('mod-centralization').value = centralization.toFixed(1);
      document.getElementById('mod-attack').value = attack.toFixed(1);
      document.getElementById('mod-piece-activity').value = pieceActivity.toFixed(1);
      document.getElementById('mod-defense').value = defense.toFixed(1);
      document.getElementById('mod-pawn-structure').value = pawnStructure.toFixed(1);
      
      // Update the custom personality in enginePersonalities object
      enginePersonalities.custom.material = material;
      enginePersonalities.custom.king_safety_b = kingSafety;
      enginePersonalities.custom.king_safety_w = kingSafety;
      enginePersonalities.custom.centralization_b = centralization;
      enginePersonalities.custom.centralization_w = centralization;
      enginePersonalities.custom.attack_b = attack;
      enginePersonalities.custom.attack_w = attack;
      enginePersonalities.custom.piece_activity_b = pieceActivity;
      enginePersonalities.custom.piece_activity_w = pieceActivity;
      enginePersonalities.custom.defense_b = defense;
      enginePersonalities.custom.defense_w = defense;
      enginePersonalities.custom.pawn_structure_b = pawnStructure;
      enginePersonalities.custom.pawn_structure_w = pawnStructure;
      
      // Save to localStorage
      localStorage.setItem('customModifiers', JSON.stringify({
        material: material,
        king_safety: kingSafety,
        centralization: centralization,
        attack: attack,
        piece_activity: pieceActivity,
        defense: defense,
        pawn_structure: pawnStructure
      }));
      
      // Apply modifiers in real-time
      applyEngineModifiers('custom');
    }

    function resetCustomModifiers() {
      document.getElementById('mod-material').value = 1.0;
      document.getElementById('mod-king-safety').value = 1.0;
      document.getElementById('mod-centralization').value = 1.0;
      document.getElementById('mod-attack').value = 1.0;
      document.getElementById('mod-piece-activity').value = 1.0;
      document.getElementById('mod-defense').value = 1.0;
      document.getElementById('mod-pawn-structure').value = 1.0;
      updateCustomModifiers();
    }

    function loadCustomModifiers() {
      const saved = localStorage.getItem('customModifiers');
      if (saved) {
        const custom = JSON.parse(saved);
        document.getElementById('mod-material').value = custom.material || 1.0;
        document.getElementById('mod-king-safety').value = custom.king_safety || 1.0;
        document.getElementById('mod-centralization').value = custom.centralization || 1.0;
        document.getElementById('mod-attack').value = custom.attack || 1.0;
        document.getElementById('mod-piece-activity').value = custom.piece_activity || 1.0;
        document.getElementById('mod-defense').value = custom.defense || 1.0;
        document.getElementById('mod-pawn-structure').value = custom.pawn_structure || 1.0;
        updateCustomModifiers();
      }
    }

    function toggleHistoryOption() {
      const blindfoldChecked = document.getElementById("blindfold-mode").checked;
      const historyRow = document.getElementById("show-history-row");
      if (blindfoldChecked) {
        historyRow.style.display = "inline-block";
      } else {
        historyRow.style.display = "none";
        document.getElementById("show-history").checked = false;
      }
    }

    function changeBoardStyle() {
      const style = document.getElementById("board-style").value;
      const boardElement = document.getElementById("board");
      
      // Remove all theme classes
      boardElement.className = boardElement.className.replace(/board-theme-\w+/g, '').trim();
      
      // Add new theme class
      boardElement.classList.add(`board-theme-${style}`);
      
      // Save preference to localStorage
      localStorage.setItem('chessboardStyle', style);
    }

    function changeEngineStyle() {
      const style = document.getElementById("engine-style").value;
      const selector = document.getElementById("engine-style");
      const customPanel = document.getElementById("custom-modifiers-panel");
      currentEngineStyle = style;
      
      // Remove all personality classes
      selector.className = selector.className.replace(/personality-\w+/g, '').trim();
      
      // Add new personality class for color
      selector.classList.add('personality-' + style);
      
      // Show/hide custom modifiers panel
      if (style === 'custom') {
        customPanel.style.display = 'block';
        loadCustomModifiers();
      } else {
        customPanel.style.display = 'none';
      }
      
      // Save preference to localStorage
      localStorage.setItem('enginePersonality', style);
      
      // Apply modifiers to engine
      applyEngineModifiers(style);
    }

    async function applyEngineModifiers(personality) {
      const baseModifiers = enginePersonalities[personality];
      
      if (!baseModifiers) {
        console.error('Unknown engine personality:', personality);
        return;
      }

      // Determine which color the engine is playing
      const engineColor = playerColor === 'white' ? 'black' : 'white';
      // NOTE: Code internals are reversed from board!
      // _b modifiers = WHITE pieces on board, _w modifiers = BLACK pieces on board
      const engineSuffix = engineColor === 'black' ? '_w' : '_b';
      const playerSuffix = engineColor === 'black' ? '_b' : '_w';

      // Build asymmetric modifiers: engine gets personality, player gets balanced (1.0)
      const modifiers = {
        material: baseModifiers.material, // Material is symmetric
      };

      // For each personality trait, apply it to engine's color only
      const traits = ['king_safety', 'centralization', 'attack', 'piece_activity', 'defense', 'pawn_structure'];
      
      traits.forEach(trait => {
        // Engine's color gets the personality modifier
        modifiers[trait + engineSuffix] = baseModifiers[trait + engineSuffix];
        // Player's color gets balanced modifier (1.0)
        modifiers[trait + playerSuffix] = 1.0;
      });

      console.log('Applying asymmetric modifiers:', {
        personality,
        engineColor,
        engineSuffix,
        playerSuffix,
        engineModifiers: modifiers
      });

      try {
        const response = await fetch('https://hedgehoglover23.pythonanywhere.com/modifiers', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(modifiers)
        });

        if (response.ok) {
          const data = await response.json();
          console.log('Engine modifiers updated (asymmetric):', data);
        } else {
          console.error('Failed to update engine modifiers:', response.statusText);
        }
      } catch (error) {
        console.error('Error updating engine modifiers:', error);
      }
    }

    function changePieceStyle() {
      const style = document.getElementById("piece-style").value;
      currentPieceStyle = style;
      
      // Save preference to localStorage
      localStorage.setItem('chessPieceStyle', style);
      
      // If board exists, update the piece theme
      if (board) {
        const currentPosition = board.position();
        board.destroy();
        
        // Check if game is active or preview mode
        const isGameStarted = document.getElementById("choose-side").style.display === "none";
        
        if (isGameStarted && game && !gameOver) {
          // Game is active - recreate with full handlers
          recreateBoard();
        } else {
          // Preview mode - recreate preview board
          board = Chessboard('board', {
            draggable: false,
            position: currentPosition,
            orientation: 'white',
            pieceTheme: pieceThemes[currentPieceStyle]
          });
        }
        board.position(currentPosition);
      }
    }

    function recreateBoard() {
      board = Chessboard("board", {
        draggable: true,
        position: game ? game.fen() : "start",
        orientation: playerColor,
        snapSpeed: 50,
        snapbackSpeed: 50,
        appearSpeed: 0,
        moveSpeed: 100,
        trashSpeed: 50,
        dragThrottleRate: 0,
        sparePieces: false,
        dropOffBoard: 'snapback',
        onDragStart: (source, piece, position, orientation) => {
          if (game.game_over() || gameOver) {
            const sourceSquare = $(`#board .square-${source}`);
            sourceSquare.addClass('illegal-move');
            setTimeout(() => sourceSquare.removeClass('illegal-move'), 600);
            return false;
          }
          const turn = game.turn();
          if ((playerColor === "white" && turn !== "w") || (playerColor === "black" && turn !== "b")) {
            const sourceSquare = $(`#board .square-${source}`);
            sourceSquare.addClass('illegal-move');
            setTimeout(() => sourceSquare.removeClass('illegal-move'), 600);
            return false;
          }
          if ((turn === 'w' && piece.search(/^b/) !== -1) || (turn === 'b' && piece.search(/^w/) !== -1)) {
            const sourceSquare = $(`#board .square-${source}`);
            sourceSquare.addClass('illegal-move');
            setTimeout(() => sourceSquare.removeClass('illegal-move'), 600);
            return false;
          }
          highlightLegalMoves(source);
        },
        onDragMove: (newLocation, oldLocation, source, piece, position, orientation) => {
          $("#board .square-55d63").removeClass("legal-target");
          const moves = game.moves({ square: source, verbose: true });
          const isLegal = moves.some(move => move.to === newLocation);
          if (isLegal) {
            $(`#board .square-${newLocation}`).addClass("legal-target");
          }
        },
        onDrop: handleMove,
        onSnapEnd: () => {
          removeHighlights();
          $("#board .square-55d63").removeClass("legal-target");
        },
        pieceTheme: pieceThemes[currentPieceStyle],
      });
    }

 $(document).ready(function() {
	 		
        console.log("The page has finished loading!");

        // Load saved board style
        const savedStyle = localStorage.getItem('chessboardStyle') || 'classic';
        document.getElementById('board-style').value = savedStyle;
        changeBoardStyle();

        // Load saved piece style
        const savedPieceStyle = localStorage.getItem('chessPieceStyle') || 'wikipedia';
        currentPieceStyle = savedPieceStyle;
        document.getElementById('piece-style').value = savedPieceStyle;

        // Load saved engine personality
        const savedEngineStyle = localStorage.getItem('enginePersonality') || 'balanced';
        currentEngineStyle = savedEngineStyle;
        const engineStyleSelect = document.getElementById('engine-style');
        engineStyleSelect.value = savedEngineStyle;
        // Apply personality color on load
        engineStyleSelect.classList.add('personality-' + savedEngineStyle);
        
        // Show custom panel if custom personality was selected
        if (savedEngineStyle === 'custom') {
          document.getElementById('custom-modifiers-panel').style.display = 'block';
          loadCustomModifiers();
        }

        // Initialize game object for preview board
        game = new Chess();
        gameOver = false;
        playerColor = "white"; // Default for preview

        // Create preview board with dragging enabled
        board = Chessboard('board', {
          draggable: false,
          position: 'start',
          orientation: 'white',
          pieceTheme: pieceThemes[currentPieceStyle]
        });
        
        console.log('Preview board created with config:', {
          draggable: false
        });
        
        // Show the board container
        document.getElementById('board-timers-container').style.display = 'flex';

        // --- AUTOMATIC LOGIC: Stop then Start the engine on page load ---
        console.log("Attempting to stop and then start the engine automatically on page load...");
        sendEngineCommand('stop')
            .then(() => {
                console.log("Stop command sent successfully. Now sending start command...");
                return sendEngineCommand('start');
            })
            .then(() => {
                console.log("Start command sent successfully. Engine should be reset and running.");
            })
            .catch(error => {
                console.error("Error during automatic engine reset on page load:", error);
                // Replaced alert() with a console log
                console.error("Failed to automatically reset engine on page load. Check console for details.");
            });

        // Load sound settings
        const savedSound = localStorage.getItem('soundEnabled');
        if (savedSound !== null) {
          document.getElementById('sound-effects').checked = savedSound === 'true';
          soundEnabled = savedSound === 'true';
        }

        // Add event listener for sound toggle
        document.getElementById('sound-effects').addEventListener('change', function() {
          soundEnabled = this.checked;
          localStorage.setItem('soundEnabled', soundEnabled);
        });

        // Load statistics and achievements
        loadPlayerStats();
        loadAchievements();
        loadLifetimeStats();
        updatePlayerStatsDisplay();
        updateAchievementsDisplay();
        updateTotalPoints();
    });

        $(document).keydown(function(e) {
            if (!blindfoldMode && board && moveHistory.length > 0) {
                if (e.key === 'ArrowLeft' || e.keyCode === 37) {
                    e.preventDefault();
                    navigateToPreviousMove();
                } else if (e.key === 'ArrowRight' || e.keyCode === 39) {
                    e.preventDefault();
                    navigateToNextMove();
                } else if (e.key === 'ArrowUp' || e.keyCode === 38) {
                    e.preventDefault();
                    navigateToStart();
                } else if (e.key === 'ArrowDown' || e.keyCode === 40) {
                    e.preventDefault();
                    navigateToCurrent();
                }
            }
        });
    function formatTime(ms) {
      const t = Math.max(0, Math.floor(ms));
      const totalHundredths = Math.floor(t / 10);
      const minutes = String(Math.floor(totalHundredths / 6000)).padStart(2, "0");
      const seconds = String(Math.floor((totalHundredths % 6000) / 100)).padStart(2, "0");
      const hundredths = String(totalHundredths % 100).padStart(2, "0");
      return `${minutes}:${seconds}.${hundredths}`;
    }
    
    function updateClockStyles() {
        const turn = game.turn();
        const playerIsWhite = playerColor === 'white';
        
        // Determine which slot is the player's and which is the engine's
        const playerSlot = playerIsWhite ? document.getElementById("time-slot-white") : document.getElementById("time-slot-black");
        const engineSlot = playerIsWhite ? document.getElementById("time-slot-black") : document.getElementById("time-slot-white");
        
        // Remove active class from both
        playerSlot.classList.remove('time-active');
        engineSlot.classList.remove('time-active');

        // Add active class only to the player's clock when it's their turn
        if ((playerIsWhite && turn === 'w') || (!playerIsWhite && turn === 'b')) {
            playerSlot.classList.add('time-active');
        }
    }


    // MODIFIED: Timer always counts up, but only deducts time if it's the player's turn.
    function startTimer() {
      clearInterval(timerInterval);
      timerStart = performance.now();

      const turn = game.turn();
      const isPlayerTurn = (playerColor === "white" && turn === "w") || (playerColor === "black" && turn === "b");
      
      // Update clock styling (active state)
      updateClockStyles();

      // MODIFICATION START: Set player's time to its value and engine's time to "Unlimited"
      if (timeLimited) {
          // Determine element IDs and time references
          const playerTotalId = playerColor === 'white' ? "white-total" : "black-total";
          const engineTotalId = playerColor === 'white' ? "black-total" : "white-total";
          const playerTimeRef = playerColor === 'white' ? whiteTime : blackTime;
          
          // Set player's time display
          document.getElementById(playerTotalId).textContent = formatTime(playerTimeRef);
          
          // Set engine's time display to "Unlimited"
          document.getElementById(engineTotalId).textContent = "Unlimited";
      }
      // MODIFICATION END
      
      timerInterval = setInterval(() => {
          if (gameOver) {
              clearInterval(timerInterval);
              return;
          }

        const elapsed = performance.now() - timerStart;

        // 1. Always update the move timer display (Counts up)
        document.getElementById("timer").textContent = formatTime(elapsed);

        // 2. ONLY manage total time deduction/check if it's time limited AND the player's turn
        if (timeLimited && isPlayerTurn) {
            const totalTimeElementId = playerColor === 'white' ? "white-total" : "black-total";
            const playerTimeRef = playerColor === 'white' ? whiteTime : blackTime;
            
            const newTime = playerTimeRef - elapsed;

            // Update the player's total remaining time (countdown)
            document.getElementById(totalTimeElementId).textContent = formatTime(newTime);
            
            if (newTime <= 0) {
                clearInterval(timerInterval);
                // Replaced alert() with UI message
                const moveContainer = document.getElementById("move-timer-container");
                moveContainer.innerHTML = 'TIME OUT! <span style="color:red;">You lose!</span>';
                gameOver = true;
                
                // Update statistics
                playerStats.losses++;
                savePlayerStats();
                updatePlayerStatsDisplay();
                checkAchievements();
                
                // Show rematch modal
                setTimeout(() => showRematchModal("â° Time Out", "You ran out of time! Play again?"), 1500);
            }
        }
      }, 10);
    }

    // UNMODIFIED Logic, only checking if the color that just moved was the player's color
    function stopTimerAndUpdateTotal(color) {
      clearInterval(timerInterval);
      const elapsed = performance.now() - timerStart;
      if (timeLimited) {
        if (
          (color === "w" && playerColor === "white") ||
          (color === "b" && playerColor === "black")
          ) {
          if (color === "w") {
            whiteTime = Math.max(0, whiteTime - elapsed);
            whiteTime += increment * 1000;
            document.getElementById("white-total").textContent = formatTime(whiteTime);
          } else {
            blackTime = Math.max(0, blackTime - elapsed);
            blackTime += increment * 1000;
            document.getElementById("black-total").textContent = formatTime(blackTime);
          }
        }
      }
      return elapsed;
    }

function navigateToPreviousMove() {
      if (currentMoveIndex === -1 && moveHistory.length > 0) {
        currentMoveIndex = moveHistory.length - 2;
        if (currentMoveIndex < 0) currentMoveIndex = 0;
        displayPositionAtIndex(currentMoveIndex);
      } else if (currentMoveIndex === 0) {
        currentMoveIndex = -2;
        board.position('start');
        updateMoveHighlight();
      } else if (currentMoveIndex > 0) {
        currentMoveIndex--;
        displayPositionAtIndex(currentMoveIndex);
      }
    }

    function navigateToNextMove() {
      if (currentMoveIndex === -2 && moveHistory.length > 0) {
        currentMoveIndex = 0;
        displayPositionAtIndex(currentMoveIndex);
      } else if (currentMoveIndex === -1) {
        // Already at current position, do nothing
        return;
      } else if (currentMoveIndex < moveHistory.length - 1) {
        currentMoveIndex++;
        displayPositionAtIndex(currentMoveIndex);
      } else if (currentMoveIndex === moveHistory.length - 1) {
        currentMoveIndex = -1;
        board.position(game.fen());
        updateMoveHighlight();
      }
    }

    function navigateToStart() {
      currentMoveIndex = -2;
      board.position('start');
      updateMoveHighlight();
    }

    function navigateToCurrent() {
      currentMoveIndex = -1;
      board.position(game.fen());
      updateMoveHighlight();
    }

    function displayPositionAtIndex(index) {
      if (index >= 0 && index < moveHistory.length) {
        board.position(moveHistory[index]);
        updateMoveHighlight();
      }
    }

    function updateMoveHighlight() {
      $('.move-item').removeClass('highlighted');
      if (currentMoveIndex >= 0 && currentMoveIndex < moveHistory.length) {
        $(`.move-item[data-move-index="${currentMoveIndex}"]`).addClass('highlighted');
      }
    }

    function updateNotationDisplay() {
      const history = game.history();
      const container = document.getElementById("notation-container");
      container.innerHTML = '';
      // Dynamic height: expands up to board height as moves are played
      const minHeight = 60;
      const maxHeight = 450;
      const basePadding = 35;
      let dynHeight = minHeight + Math.min(history.length * 16, maxHeight-minHeight);
      dynHeight = Math.max(minHeight, Math.min(dynHeight, maxHeight));
      container.style.minHeight = minHeight + 'px';
      container.style.height = dynHeight + 'px';
      container.style.maxHeight = maxHeight + 'px';
      // Group moves by full move (White + Black)
      for (let i = 0; i < history.length; i += 2) {
        const moveNum = Math.floor(i / 2) + 1;
        const moveRow = document.createElement('div');
        moveRow.style.marginBottom = '4px';
        moveRow.style.display = 'flex';
        moveRow.style.alignItems = 'center';
        moveRow.style.gap = '8px';
        
        // Move number
        const moveNumSpan = document.createElement('span');
        moveNumSpan.className = 'move-number';
        moveNumSpan.textContent = moveNum + '.';
        moveNumSpan.style.fontWeight = '600';
        moveNumSpan.style.minWidth = '30px';
        moveNumSpan.style.color = '#7f8c8d';
        moveRow.appendChild(moveNumSpan);
        
        // White move
        const whiteMove = history[i];
        if (whiteMove) {
          const whiteSpan = document.createElement('span');
          whiteSpan.className = 'move-item';
          if (currentMoveIndex === i || (currentMoveIndex === -1 && i === history.length - 1)) {
            whiteSpan.classList.add('highlighted');
          }
          whiteSpan.setAttribute('data-move-index', i);
          whiteSpan.onclick = function() { jumpToMove(i); };
          whiteSpan.textContent = whiteMove;
          whiteSpan.style.cursor = 'pointer';
          whiteSpan.style.padding = '2px 6px';
          whiteSpan.style.borderRadius = '4px';
          whiteSpan.style.transition = 'background-color 0.2s';
          whiteSpan.onmouseover = function() { this.style.backgroundColor = '#ecf0f1'; };
          whiteSpan.onmouseout = function() { if (!this.classList.contains('highlighted')) this.style.backgroundColor = 'transparent'; };
          moveRow.appendChild(whiteSpan);
        }
        
        // Black move
        const blackMove = history[i + 1];
        if (blackMove) {
          const blackSpan = document.createElement('span');
          blackSpan.className = 'move-item';
          if (currentMoveIndex === i + 1 || (currentMoveIndex === -1 && i + 1 === history.length - 1)) {
            blackSpan.classList.add('highlighted');
          }
          blackSpan.setAttribute('data-move-index', i + 1);
          blackSpan.onclick = function() { jumpToMove(i + 1); };
          blackSpan.textContent = blackMove;
          blackSpan.style.cursor = 'pointer';
          blackSpan.style.padding = '2px 6px';
          blackSpan.style.borderRadius = '4px';
          blackSpan.style.transition = 'background-color 0.2s';
          blackSpan.onmouseover = function() { this.style.backgroundColor = '#ecf0f1'; };
          blackSpan.onmouseout = function() { if (!this.classList.contains('highlighted')) this.style.backgroundColor = 'transparent'; };
          moveRow.appendChild(blackSpan);
        }
        
        container.appendChild(moveRow);
      }
    }
    
    function jumpToMove(index) {
      if (!blindfoldMode && index >= 0 && index < moveHistory.length) {
        currentMoveIndex = index;
        displayPositionAtIndex(index);
      }
    }

    function updateLastMove(move, timeStr, color, move_number) {
      const txt = move ? `${move} (${timeStr})` : "None";
      document.getElementById("last-move").textContent = txt;

      if (move) {
        moveHistory.push(game.fen());
        currentMoveIndex = -1;
        updateNotationDisplay();
      }
}

    function updateTurnDisplay() {
      document.getElementById("turn-color").textContent = game.turn() === "w" ? "White" : "Black";
    }

    function highlightLegalMoves(square) {
      const moves = game.moves({ square, verbose: true });
      for (const move of moves) {
        $(`#board .square-${move.to}`).addClass("highlight-legal");
      }
    }

    function removeHighlights() {
      // Don't remove highlights if a piece is selected for click-to-move
      if (!selectedSquare) {
        $("#board .square-55d63").removeClass("highlight-legal");
      }
    }

    function isPremoveLegal(from, to, piece) {
      // Validate if a premove would be theoretically legal for this piece type
      // on an empty board (or for pawns, with diagonal capture squares occupied)
      
      const fromFile = from.charCodeAt(0) - 'a'.charCodeAt(0);
      const fromRank = parseInt(from[1]) - 1;
      const toFile = to.charCodeAt(0) - 'a'.charCodeAt(0);
      const toRank = parseInt(to[1]) - 1;
      
      const fileDiff = Math.abs(toFile - fromFile);
      const rankDiff = Math.abs(toRank - fromRank);
      const fileDir = toFile - fromFile;
      const rankDir = toRank - fromRank;
      
      const pieceType = piece.type;
      const pieceColor = piece.color;
      
      switch(pieceType) {
        case 'p': // Pawn
          const direction = pieceColor === 'w' ? 1 : -1;
          const startRank = pieceColor === 'w' ? 1 : 6;
          
          // Forward one square
          if (fileDir === 0 && rankDir === direction) return true;
          
          // Forward two squares from starting position
          if (fileDir === 0 && rankDir === 2 * direction && fromRank === startRank) return true;
          
          // Diagonal capture (always allow for premoves since we assume piece could be there)
          if (fileDiff === 1 && rankDir === direction) return true;
          
          return false;
          
        case 'n': // Knight
          return (fileDiff === 2 && rankDiff === 1) || (fileDiff === 1 && rankDiff === 2);
          
        case 'b': // Bishop
          return fileDiff === rankDiff && fileDiff > 0;
          
        case 'r': // Rook
          return (fileDiff === 0 && rankDiff > 0) || (rankDiff === 0 && fileDiff > 0);
          
        case 'q': // Queen
          return (fileDiff === rankDiff && fileDiff > 0) || // Diagonal
                 (fileDiff === 0 && rankDiff > 0) ||        // Vertical
                 (rankDiff === 0 && fileDiff > 0);          // Horizontal
          
        case 'k': // King
          return fileDiff <= 1 && rankDiff <= 1 && (fileDiff > 0 || rankDiff > 0);
          
        default:
          return false;
      }
    }

    function clearPremove() {
      if (premoves.length > 0 && board) {
        // Restore board position when clearing premoves since we actually moved pieces
        board.position(game.fen());
      }
      premoves = [];
      selectedSquare = null;
      $("#board .square-55d63").removeClass("premove-highlight premove-source");
    }
    
    // Helper function to update board visual with all premoves applied
    function updatePremoveVisual() {
      if (!board || !game) return;
      
      if (premoves.length === 0) {
        board.position(game.fen());
        $("#board .square-55d63").removeClass("premove-highlight premove-source");
        return;
      }
      
      // Always start from the actual game position
      // First, reset board to actual game position to get clean state
      board.position(game.fen());
      
      // Use requestAnimationFrame to ensure board has updated, then apply premoves
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          const pos = board.position();
          if (!pos || Object.keys(pos).length === 0) {
            // If position is empty, try to get it directly from game.fen() by setting it again
            board.position(game.fen());
            setTimeout(() => updatePremoveVisual(), 50);
            return;
          }
          
          // Create a deep copy of the position object
          const newPos = {};
          for (const square in pos) {
            newPos[square] = pos[square];
          }
          
          // Track all squares involved in premoves for highlighting
          const highlightSquares = [];
          
          // Manually apply all premoves to show them visually
          // For each premove in sequence, move the piece from source to destination
          for (const pm of premoves) {
            const piece = newPos[pm.from];
            if (piece) {
              // Remove piece from source
              delete newPos[pm.from];
              // Place piece on destination (overwriting anything there, as premoves can capture)
              newPos[pm.to] = piece;
              // Track squares for highlighting (both source and destination)
              highlightSquares.push({ from: pm.from, to: pm.to });
            }
          }
          
          // Update board to show all premoves
          board.position(newPos);
          
          // Clear all highlights first, then add red highlights for all premoves
          requestAnimationFrame(() => {
            $("#board .square-55d63").removeClass("premove-highlight premove-source");
            
            for (const sq of highlightSquares) {
              $(`#board .square-${sq.from}`).addClass("premove-source");
              $(`#board .square-${sq.to}`).addClass("premove-highlight");
            }
          });
        });
      });
    }

    function handleSquareClick(square) {
      console.log('=== handleSquareClick START ===', square);
      const turn = game.turn();
      const isPlayerTurn = (playerColor === "white" && turn === "w") || (playerColor === "black" && turn === "b");
      const piece = game.get(square);  // Use game.get() to get piece from game state
      console.log('Turn:', turn, 'isPlayerTurn:', isPlayerTurn, 'piece:', piece, 'selectedSquare:', selectedSquare);
      
      // If there's a selected piece
      if (selectedSquare) {
        // If clicking the same square, deselect
        if (selectedSquare === square) {
          selectedSquare = null;
          removeHighlights();
          return;
        }
        
        // Check if this is a legal move or premove
        if (!isPlayerTurn) {
          // Make premove via click - allow any destination including recapturing own pieces
          // (might be currently illegal but could become legal after opponent moves)
          const premoveFrom = selectedSquare;
          const premoveTo = square;
          
          // Verify there's a piece at the source that belongs to the player
          const sourcePiece = game.get(premoveFrom);
          if (!sourcePiece || sourcePiece.color !== (playerColor === 'white' ? 'w' : 'b')) {
            selectedSquare = null;
            removeHighlights();
            return;
          }
          
          // Validate premove is theoretically legal for this piece type
          if (!isPremoveLegal(premoveFrom, premoveTo, sourcePiece)) {
            console.log('Premove not valid for piece type:', sourcePiece.type, premoveFrom, '->', premoveTo);
            selectedSquare = null;
            removeHighlights();
            return;
          }
          
          selectedSquare = null;
          removeHighlights();
          
          // Add new premove to the array (chain of premoves)
          const newPremove = { from: premoveFrom, to: premoveTo };
          premoves.push(newPremove);
          premoveJustSet = true;
          console.log('Premove added via click:', newPremove, 'Total premoves:', premoves.length);
          
          // Update visual to show all premoves in the chain
          updatePremoveVisual();
          return;
        } else {
          // Try to make a normal move
          const moveFrom = selectedSquare;
          const moveTo = square;
          console.log('Attempting move from', moveFrom, 'to', moveTo);
          const testMove = game.move({ from: moveFrom, to: moveTo, promotion: 'q' });
          console.log('Test move result:', testMove);
          
          if (testMove) {
            // Legal move - undo the test move, then execute properly
            game.undo();
            clearPremove();
            selectedSquare = null;
            removeHighlights();
            console.log('Calling handleMove');
            handleMove(moveFrom, moveTo);
            return;
          } else if (piece) {
            const pieceColorFull = piece.color === 'w' ? 'white' : 'black';
            if (pieceColorFull === playerColor) {
              // Illegal move but clicked on own piece - change selection
              console.log('Switching selection to', square);
              // Clear old highlights before selecting new piece
              $("#board .square-55d63").removeClass("highlight-legal");
              selectedSquare = square;
              highlightLegalMoves(square);
              return;
            }
          }
          
          // Invalid move, deselect
          console.log('Invalid move, deselecting');
          selectedSquare = null;
          removeHighlights();
          return;
        }
      }
      
      // No piece selected - select clicked piece if valid
      if (piece) {
        const pieceColorFull = piece.color === 'w' ? 'white' : 'black';
        if (pieceColorFull === playerColor) {
          // Allow selecting own pieces even during opponent's turn (for premoves)
          console.log('Setting selectedSquare to:', square);
          // Clear old highlights before selecting new piece
          $("#board .square-55d63").removeClass("highlight-legal");
          selectedSquare = square;
          highlightLegalMoves(square);
          console.log('After setting, selectedSquare is:', selectedSquare);
        }
      } else {
        // Clicked on empty square with no piece selected
        // Cancel all premoves if it's the opponent's turn (when premoves can be set)
        if (!isPlayerTurn && premoves.length > 0) {
          console.log('Empty square clicked during opponent turn, canceling all premoves');
          clearPremove();
        }
      }
    }

    function detectOpening() {
      const history = game.history();
      let movesStr = history.join(" ");
      
      // Check for exact matches, starting with longest sequences
      const sortedOpenings = Object.keys(openingBook).sort((a, b) => b.length - a.length);
      
      for (let opening of sortedOpenings) {
        if (movesStr.startsWith(opening)) {
          return openingBook[opening];
        }
      }
      
      return null;
    }

    function updateOpeningDisplay() {
      const opening = detectOpening();
      const openingNameEl = document.getElementById("opening-name");
      
      if (opening) {
        openingNameEl.textContent = opening;
        document.getElementById("opening-display").style.display = "block";
      } else if (game.history().length > 10) {
        openingNameEl.textContent = "General Position";
        document.getElementById("opening-display").style.display = "block";
      }
    }

    function highlightLastMove(from, to) {
      // Remove previous highlights
      $("#board .square-55d63").removeClass("highlight-last-move");
      
      // Add new highlights
      if (from && to) {
        $("#board .square-" + from).addClass("highlight-last-move");
        $("#board .square-" + to).addClass("highlight-last-move");
      }
    }

    function highlightCheck() {
      // Remove previous check highlights
      $("#board .square-55d63").removeClass("highlight-check");
      
      if (game.in_check()) {
        const turn = game.turn();
        const kingSquare = findKingSquare(turn);
        if (kingSquare) {
          $("#board .square-" + kingSquare).addClass("highlight-check");
        }
      }
    }

    function findKingSquare(color) {
      const board = game.board();
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          const piece = board[i][j];
          if (piece && piece.type === 'k' && piece.color === color) {
            const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
            return files[j] + (8 - i);
          }
        }
      }
      return null;
    }

    function updateGameStats() {
      // Update captured pieces display
      updateCapturedPieces();
      
      // Calculate and update material balance
      updateMaterialBalance();
      
      // Update game phase - more accurate detection
      const moveCount = game.history().length;
      const phaseEl = document.getElementById("game-phase");
      
      // Count pieces and check game state for more accurate phase detection
      const boardState = game.board();
      let pieceCount = 0;
      let queenCount = 0;
      let rookCount = 0;
      
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          const piece = boardState[i][j];
          if (piece) {
            pieceCount++;
            if (piece.type === 'q') queenCount++;
            else if (piece.type === 'r') rookCount++;
          }
        }
      }
      
      // More accurate phase detection
      // Opening: first 15-20 moves, most pieces still on board, queens present
      // Middlegame: pieces developed, material exchanges happening, queens usually still present
      // Endgame: few pieces left, queens often traded, or very low material
      if (pieceCount <= 12 || (queenCount === 0 && pieceCount <= 18)) {
        // Endgame: very few pieces or queens traded with low material
        phaseEl.textContent = "Endgame";
        phaseEl.style.color = "#e74c3c";
      } else if (moveCount >= 20 && pieceCount > 20 && queenCount > 0) {
        // Middlegame: enough moves played, good material, queens present
        phaseEl.textContent = "Middlegame";
        phaseEl.style.color = "#2ecc71";
      } else if (moveCount >= 15 && (pieceCount <= 20 || rookCount >= 2)) {
        // Transition to middlegame: pieces developed or material exchanges
        phaseEl.textContent = "Middlegame";
        phaseEl.style.color = "#2ecc71";
      } else {
        // Opening: early game, most pieces on board
        phaseEl.textContent = "Opening";
        phaseEl.style.color = "#3498db";
      }
      
      // Update pieces count display
      document.getElementById("pieces-count").textContent = pieceCount;
      
      // Update check status
      const checkEl = document.getElementById("check-status");
      if (game.in_check()) {
        const turn = game.turn();
        checkEl.textContent = turn === 'w' ? "White in Check" : "Black in Check";
        checkEl.style.color = "#e74c3c";
        checkEl.style.fontWeight = "700";
      } else {
        checkEl.textContent = "None";
        checkEl.style.color = "#7f8c8d";
        checkEl.style.fontWeight = "500";
      }
      
      // Update castling rights
      const fen = game.fen();
      const castlingRights = fen.split(' ')[2];
      const castlingEl = document.getElementById("castling-rights");
      if (castlingRights === '-') {
        castlingEl.textContent = "None";
        castlingEl.style.color = "#7f8c8d";
      } else {
        const whiteCanCastle = castlingRights.includes('K') || castlingRights.includes('Q');
        const blackCanCastle = castlingRights.includes('k') || castlingRights.includes('q');
        if (whiteCanCastle && blackCanCastle) {
          castlingEl.textContent = "Both";
          castlingEl.style.color = "#2ecc71";
        } else if (whiteCanCastle) {
          castlingEl.textContent = "White Only";
          castlingEl.style.color = "#3498db";
        } else if (blackCanCastle) {
          castlingEl.textContent = "Black Only";
          castlingEl.style.color = "#34495e";
        } else {
          castlingEl.textContent = "None";
          castlingEl.style.color = "#7f8c8d";
        }
      }
    }

    function updateCapturedPieces() {
      const whiteCapDiv = document.getElementById("white-captures-display");
      const blackCapDiv = document.getElementById("black-captures-display");
      
      whiteCapDiv.innerHTML = capturedPieces.white.length > 0 ? 
        capturedPieces.white.map(p => `<div class="captured-piece" style="background-image: url('lib/img/chesspieces/wikipedia/${p}.png')"></div>`).join('') :
        '';
      
      blackCapDiv.innerHTML = capturedPieces.black.length > 0 ? 
        capturedPieces.black.map(p => `<div class="captured-piece" style="background-image: url('lib/img/chesspieces/wikipedia/${p}.png')"></div>`).join('') :
        '';
    }

    function updateMaterialBalance() {
      const pieceValues = { p: 1, n: 3, b: 3, r: 5, q: 9, k: 0 };
      
      let whiteMaterial = 0;
      let blackMaterial = 0;
      
      const board = game.board();
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          const piece = board[i][j];
          if (piece) {
            const value = pieceValues[piece.type];
            if (piece.color === 'w') {
              whiteMaterial += value;
            } else {
              blackMaterial += value;
            }
          }
        }
      }
      
      const difference = whiteMaterial - blackMaterial;
      const balanceEl = document.getElementById("material-balance");
      
      balanceEl.classList.remove('positive', 'negative', 'equal');
      
      if (difference > 0) {
        balanceEl.textContent = `White +${difference}`;
        balanceEl.classList.add('positive');
      } else if (difference < 0) {
        balanceEl.textContent = `Black +${Math.abs(difference)}`;
        balanceEl.classList.add('negative');
      } else {
        balanceEl.textContent = 'Equal';
        balanceEl.classList.add('equal');
      }
    }

    function trackCapturedPiece(move) {
      if (move.captured) {
        const capturedPieceCode = move.color === 'w' ? 'b' + move.captured.toUpperCase() : 'w' + move.captured.toUpperCase();
        if (move.color === 'w') {
          capturedPieces.white.push(capturedPieceCode);
        } else {
          capturedPieces.black.push(capturedPieceCode);
        }
        
        // Track captures by piece type for achievements (only player's captures)
        const isPlayerMove = (move.color === 'w' && playerColor === 'white') || (move.color === 'b' && playerColor === 'black');
        if (isPlayerMove) {
          gameStats.totalCaptures++;
          lifetimeStats.totalCaptures++;
          
          const pieceType = move.captured.toLowerCase();
          if (pieceType === 'q') {
            gameStats.capturesByQueen++;
            lifetimeStats.capturesByQueen++;
            // Also track that we captured a queen
            lifetimeStats.capturedQueens++;
          } else if (pieceType === 'r') {
            gameStats.capturesByRook++;
            lifetimeStats.capturesByRook++;
            lifetimeStats.capturedRooks++;
          } else if (pieceType === 'b') {
            gameStats.capturesByBishop++;
            lifetimeStats.capturesByBishop++;
            lifetimeStats.capturedBishops++;
          } else if (pieceType === 'n') {
            gameStats.capturesByKnight++;
            lifetimeStats.capturesByKnight++;
            lifetimeStats.capturedKnights++;
          } else if (pieceType === 'p') {
            gameStats.capturesByPawn++;
            lifetimeStats.capturesByPawn++;
            lifetimeStats.capturedPawns++;
          }
          
          saveLifetimeStats();
        }
      }
      
      // Track other move types
      const isPlayerMove = (move.color === 'w' && playerColor === 'white') || (move.color === 'b' && playerColor === 'black');
      if (isPlayerMove) {
        if (move.flags && move.flags.includes('k')) {
          gameStats.castlingMoves++;
          lifetimeStats.castlingMoves++;
        }
        if (move.promotion) {
          gameStats.promotions++;
          lifetimeStats.promotions++;
        }
        if (move.flags && move.flags.includes('e')) {
          gameStats.enPassants++;
          lifetimeStats.enPassants++;
        }
        if (move.san && move.san.includes('+')) {
          gameStats.checksGiven++;
          lifetimeStats.checksGiven++;
        }
        saveLifetimeStats();
      }
    }

    function celebrateCheckmate(playerWon) {
      console.log('celebrateCheckmate called, playerWon:', playerWon);
      if (playerWon) {
        // === VICTORY CELEBRATION - ULTRA ENHANCED ===
        
        // Screen flash effect
        const screenFlash = document.createElement('div');
        screenFlash.style.position = 'fixed';
        screenFlash.style.top = '0';
        screenFlash.style.left = '0';
        screenFlash.style.width = '100%';
        screenFlash.style.height = '100%';
        screenFlash.style.background = 'radial-gradient(circle, rgba(46, 204, 113, 0.4) 0%, transparent 70%)';
        screenFlash.style.pointerEvents = 'none';
        screenFlash.style.zIndex = '9997';
        screenFlash.style.animation = 'screenFlash 0.8s ease-out';
        document.body.appendChild(screenFlash);
        setTimeout(() => screenFlash.remove(), 800);

        // Victory text animation
        const victoryText = document.createElement('div');
        victoryText.className = 'victory-text';
        victoryText.textContent = 'Victory!';
        victoryText.style.animation = 'textPop 1s ease-out';
        document.body.appendChild(victoryText);
        setTimeout(() => {
          victoryText.style.transition = 'opacity 0.5s ease-out';
          victoryText.style.opacity = '0';
          setTimeout(() => victoryText.remove(), 500);
        }, 2000);

        // Overlay for confetti
        const overlay = document.createElement('div');
        overlay.className = 'checkmate-overlay';
        document.body.appendChild(overlay);

        // Generate MASSIVE confetti with different shapes and trajectories
        const colors = ['#FFD700', '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE', '#2ECC71', '#3498DB', '#FF1493', '#00CED1', '#FFD700', '#FF4500'];
        const shapes = ['circle', 'rect', 'star'];
        
        for (let i = 0; i < 400; i++) {
          setTimeout(() => {
            const confetti = document.createElement('div');
            const shape = shapes[Math.floor(Math.random() * shapes.length)];
            confetti.className = 'confetti ' + shape;
            confetti.style.left = Math.random() * 100 + '%';
            confetti.style.top = -20 + 'px';
            confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
            const size = Math.random() * 20 + 6;
            confetti.style.width = size + 'px';
            confetti.style.height = size + 'px';
            confetti.style.opacity = Math.random() * 0.6 + 0.4;
            const drift = (Math.random() - 0.5) * 200;
            confetti.style.setProperty('--drift', drift + 'px');
            confetti.style.animation = `confetti-fall ${(Math.random() * 2 + 2.5)}s linear forwards`;
            confetti.style.animationDelay = (Math.random() * 0.3) + 's';
            overlay.appendChild(confetti);
            setTimeout(() => confetti.remove(), 5000);
          }, i * 8);
        }

        // Fireworks explosions from board center
        const board = document.getElementById('board');
        const boardRect = board.getBoundingClientRect();
        const centerX = boardRect.left + boardRect.width / 2;
        const centerY = boardRect.top + boardRect.height / 2;

        // Multiple firework bursts
        for (let burst = 0; burst < 8; burst++) {
          setTimeout(() => {
            const numParticles = 30;
            for (let i = 0; i < numParticles; i++) {
              const angle = (Math.PI * 2 * i) / numParticles;
              const distance = 100 + Math.random() * 150;
              const particle = document.createElement('div');
              particle.className = 'particle';
              const tx = Math.cos(angle) * distance;
              const ty = Math.sin(angle) * distance;
              particle.style.setProperty('--tx', tx + 'px');
              particle.style.setProperty('--ty', ty + 'px');
              particle.style.left = centerX + 'px';
              particle.style.top = centerY + 'px';
              particle.style.background = colors[Math.floor(Math.random() * colors.length)];
              particle.style.animation = `particleTrail ${0.8 + Math.random() * 0.4}s ease-out forwards`;
              document.body.appendChild(particle);
              setTimeout(() => particle.remove(), 1200);
            }
          }, burst * 300);
        }

        // Enhanced sparkles around the board
        for (let i = 0; i < 60; i++) {
          setTimeout(() => {
            const sparkle = document.createElement('div');
            sparkle.className = 'sparkle';
            const angle = (Math.PI * 2 * i) / 60;
            const distance = 250 + Math.random() * 200;
            sparkle.style.left = (centerX + Math.cos(angle) * distance) + 'px';
            sparkle.style.top = (centerY + Math.sin(angle) * distance) + 'px';
            sparkle.style.width = (15 + Math.random() * 20) + 'px';
            sparkle.style.height = sparkle.style.width;
            sparkle.style.animation = `sparkle ${0.6 + Math.random() * 0.6}s ease-out`;
            document.body.appendChild(sparkle);
            setTimeout(() => sparkle.remove(), 1500);
          }, i * 30);
        }

        // Ripple effects from board center
        for (let r = 0; r < 5; r++) {
          setTimeout(() => {
            const ripple = document.createElement('div');
            ripple.className = 'ripple';
            ripple.style.left = centerX + 'px';
            ripple.style.top = centerY + 'px';
            ripple.style.width = '20px';
            ripple.style.height = '20px';
            ripple.style.marginLeft = '-10px';
            ripple.style.marginTop = '-10px';
            ripple.style.animation = `ripple ${1.5}s ease-out`;
            document.body.appendChild(ripple);
            setTimeout(() => ripple.remove(), 1500);
          }, r * 200);
        }

        // ULTRA dramatic victory pulse with rotation and enhanced glow
        board.style.animation = 'victoryPulse 0.8s ease-in-out 6';
        board.style.transition = 'all 0.3s ease';
        setTimeout(() => {
          board.style.animation = '';
          board.style.filter = '';
          board.style.boxShadow = '';
        }, 5000);

        setTimeout(() => overlay.remove(), 6000);
      } else {
        // === DEFEAT ANIMATION - ULTRA ENHANCED ===
        
        // Screen flash effect (red)
        const screenFlash = document.createElement('div');
        screenFlash.style.position = 'fixed';
        screenFlash.style.top = '0';
        screenFlash.style.left = '0';
        screenFlash.style.width = '100%';
        screenFlash.style.height = '100%';
        screenFlash.style.background = 'radial-gradient(circle, rgba(231, 76, 60, 0.5) 0%, rgba(139, 0, 0, 0.3) 50%, transparent 100%)';
        screenFlash.style.pointerEvents = 'none';
        screenFlash.style.zIndex = '9997';
        screenFlash.style.animation = 'screenFlash 1.2s ease-out';
        document.body.appendChild(screenFlash);
        setTimeout(() => screenFlash.remove(), 1200);

        // Defeat text animation
        const defeatText = document.createElement('div');
        defeatText.className = 'defeat-text';
        defeatText.textContent = 'Defeat!';
        defeatText.style.animation = 'textPop 0.8s ease-out';
        document.body.appendChild(defeatText);
        setTimeout(() => {
          defeatText.style.transition = 'opacity 0.5s ease-out';
          defeatText.style.opacity = '0';
          setTimeout(() => defeatText.remove(), 500);
        }, 2000);

        const overlay = document.createElement('div');
        overlay.className = 'defeat-overlay';
        document.body.appendChild(overlay);

        // Shake the entire game container with more intensity
        const gameContainer = document.getElementById('game-container');
        if (gameContainer) {
          gameContainer.style.animation = 'defeatPulse 2s ease-out';
          gameContainer.style.filter = 'brightness(0.8)';
          setTimeout(() => {
            gameContainer.style.animation = '';
            gameContainer.style.filter = '';
          }, 2000);
        }

        // Shake the entire page
        document.body.style.animation = 'defeatShake 2s ease-in-out';
        setTimeout(() => {
          document.body.style.animation = '';
        }, 2000);

        const board = document.getElementById('board');
        
        // ULTRA intense shake with massive red glow and distortion
        board.style.animation = 'defeatShake 2s ease-in-out';
        board.style.boxShadow = '0 0 100px 30px rgba(220, 53, 69, 1), inset 0 0 60px rgba(220, 53, 69, 0.5), 0 0 150px rgba(139, 0, 0, 0.8)';
        board.style.filter = 'brightness(0.6) saturate(1.8) contrast(1.2)';
        board.style.border = '4px solid rgba(220, 53, 69, 0.8)';
        
        // Red particles falling from board
        const boardRect = board.getBoundingClientRect();
        for (let i = 0; i < 50; i++) {
          setTimeout(() => {
            const particle = document.createElement('div');
            particle.style.position = 'fixed';
            particle.style.width = '6px';
            particle.style.height = '6px';
            particle.style.background = 'rgba(220, 53, 69, 0.9)';
            particle.style.borderRadius = '50%';
            particle.style.left = (boardRect.left + Math.random() * boardRect.width) + 'px';
            particle.style.top = boardRect.top + 'px';
            particle.style.zIndex = '10000';
            particle.style.pointerEvents = 'none';
            particle.style.animation = `confetti-fall ${1 + Math.random()}s linear forwards`;
            particle.style.setProperty('--drift', (Math.random() - 0.5) * 50 + 'px');
            document.body.appendChild(particle);
            setTimeout(() => particle.remove(), 2000);
          }, i * 30);
        }
        
        setTimeout(() => {
          board.style.animation = '';
          board.style.boxShadow = '';
          board.style.filter = '';
          board.style.border = '';
        }, 2000);

        // Remove overlay after animation
        setTimeout(() => overlay.remove(), 2500);
      }
    }

    function exportPGN() {
      const date = new Date();
      const dateStr = date.toISOString().split('T')[0].replace(/-/g, '.');
      
      let pgn = '[Event "Chess vs TrifangX"]\n';
      pgn += '[Site "Ahrens Labs"]\n';
      pgn += `[Date "${dateStr}"]\n`;
      pgn += '[Round "1"]\n';
      pgn += `[White "${playerColor === 'white' ? 'Player' : 'TrifangX'}"]\n`;
      pgn += `[Black "${playerColor === 'black' ? 'Player' : 'TrifangX'}"]\n`;
      
      let result = '*';
      if (game.in_checkmate()) {
        result = game.turn() === 'w' ? '0-1' : '1-0';
      } else if (game.in_draw() || game.in_stalemate() || game.in_threefold_repetition()) {
        result = '1/2-1/2';
      }
      pgn += `[Result "${result}"]\n\n`;
      
      const history = game.history();
      let moveText = '';
      for (let i = 0; i < history.length; i++) {
        if (i % 2 === 0) {
          moveText += `${Math.floor(i / 2) + 1}. `;
        }
        moveText += history[i] + ' ';
        if (i % 2 === 1) {
          moveText += '\n';
        }
      }
      
      pgn += moveText.trim() + ` ${result}`;
      
      // Create download
      const blob = new Blob([pgn], { type: 'text/plain' });
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `chess_game_${dateStr}.pgn`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
    }
    
    function resignGame() {
      if (gameOver) return;
      
      // Position the modal directly above the resign button (popping out of it)
      const modal = document.getElementById('confirm-modal');
      const resignBtn = document.getElementById('resign-btn');
      
      // Show the modal first
      modal.classList.add('show');
      
      // Use requestAnimationFrame to ensure modal is rendered before getting dimensions
      requestAnimationFrame(() => {
        const modalRect = modal.getBoundingClientRect();
        const btnRect = resignBtn.getBoundingClientRect();
        
        // Position centered horizontally above the button with a small gap
        // Make it appear to "pop out" from the button
        const gap = 8; // 8px gap between button and modal
        modal.style.left = (btnRect.left + btnRect.width / 2 - modalRect.width / 2) + 'px';
        modal.style.top = (btnRect.top - modalRect.height - gap) + 'px';
        modal.style.position = 'fixed'; // Use fixed positioning relative to viewport
      });
    }

    function closeConfirmModal() {
      document.getElementById('confirm-modal').classList.remove('show');
    }

    function confirmResign() {
      closeConfirmModal();
      
      const winner = playerColor === 'white' ? 'black' : 'white';
      const moveContainer = document.getElementById("move-timer-container");
      moveContainer.innerHTML = `RESIGNATION! <span style="color:red;">You Lose!</span>`;
      gameOver = true;
      
      // Play losing celebration
      playSound('checkmate');
      celebrateCheckmate(false);
      
      // Update statistics
      playerStats.losses++;
      savePlayerStats();
      updatePlayerStatsDisplay();
      
      // Send resignation to engine
      sendEngineCommand("resign").catch(err => console.error("Error sending resignation:", err));
      
      // Show rematch modal
      setTimeout(() => showRematchModal("You Resigned", "Would you like to play again?"), 2000);
    }

    function showRematchModal(title, message) {
      const modal = document.getElementById('rematch-modal');
      const titleEl = document.getElementById('rematch-title');
      const messageEl = document.getElementById('rematch-message');
      
      titleEl.textContent = title;
      messageEl.textContent = message;
      
      // Position modal over the board
      const board = document.getElementById('board');
      const boardRect = board.getBoundingClientRect();
      
      modal.classList.add('show');
      
      // Use requestAnimationFrame to ensure modal is rendered before positioning
      requestAnimationFrame(() => {
        const modalRect = modal.getBoundingClientRect();
        // Center over the board
        modal.style.left = (boardRect.left + boardRect.width / 2 - modalRect.width / 2) + 'px';
        modal.style.top = (boardRect.top + boardRect.height / 2 - modalRect.height / 2) + 'px';
        modal.style.position = 'fixed';
      });
    }

    function closeRematchModal() {
      document.getElementById('rematch-modal').classList.remove('show');
    }

    function startRematch() {
      closeRematchModal();
      
      // Reset game state
      gameOver = false;
      
      // Reset game
      if (game) {
        game.reset();
      }
      moveHistory = [];
      currentMoveIndex = -1;
      capturedPieces = { white: [], black: [] };
      lastMoveSquares = { from: null, to: null };
      premoves = [];
      selectedSquare = null;
      
      // Reset game stats for new game
      gameStats = {
        capturesByQueen: 0,
        capturesByRook: 0,
        capturesByBishop: 0,
        capturesByKnight: 0,
        capturesByPawn: 0,
        totalCaptures: 0,
        checksGiven: 0,
        castlingMoves: 0,
        promotions: 0,
        enPassants: 0,
        longestGame: 0,
        shortestWin: Infinity
      };
      
      // Reset UI
      document.getElementById("move-timer-container").innerHTML = 'Time for this move: <span id="timer">00:00.00</span>';
      updateLastMove(null, "00:00.00", 0, 0);
      updateTurnDisplay();
      updateGameStats();
      updateOpeningDisplay();
      document.getElementById("opening-display").style.display = "none";
      
      // Reset board
      if (board) {
        board.position('start');
      }
      
      // Clear highlights
      $("#board .square-55d63").removeClass("highlight-last-move highlight-check premove-highlight premove-source");
      
      // Reset timers
      const timeOption = document.getElementById("time-control").value;
      if (timeOption !== "none") {
        const [base, inc] = timeOption.split("|").map(Number);
        whiteTime = base ? base * 1000 : 0;
        blackTime = base ? base * 1000 : 0;
        increment = inc || 0;
        timeLimited = true;
        document.getElementById("white-total").textContent = formatTime(whiteTime);
        document.getElementById("black-total").textContent = formatTime(blackTime);
        document.getElementById("timers-container").style.display = "flex";
      } else {
        timeLimited = false;
        document.getElementById("timers-container").style.display = "none";
      }
      
      // Clear notation
      document.getElementById("notation-container").innerHTML = '';
      
      // Start new game
      startTimer();
      
      // Restart engine
      sendEngineCommand("start").then(() => {
        applyEngineModifiers(currentEngineStyle);
        if (playerColor === "black") {
          engineMove();
        }
      }).catch(err => console.error("Error restarting engine:", err));
    }

    // === NEW FEATURE FUNCTIONS ===

    function flipBoard() {
      if (!board || !game) return;
      const currentOrientation = board.orientation();
      const newOrientation = currentOrientation === 'white' ? 'black' : 'white';
      board.orientation(newOrientation);
      playSound('move');
    }

    function playSound(type) {
      if (!soundEnabled) return;
      
      // Create audio context for sound generation
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      switch(type) {
        case 'move':
          oscillator.frequency.value = 400;
          oscillator.type = 'sine';
          gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext.currentTime + 0.1);
          break;
        case 'capture':
          oscillator.frequency.value = 600;
          oscillator.type = 'square';
          gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext.currentTime + 0.15);
          break;
        case 'check':
          oscillator.frequency.value = 800;
          oscillator.type = 'sine';
          gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext.currentTime + 0.2);
          break;
        case 'checkmate':
          // Victory sound
          [400, 500, 600, 700].forEach((freq, i) => {
            setTimeout(() => {
              const osc = audioContext.createOscillator();
              const gain = audioContext.createGain();
              osc.connect(gain);
              gain.connect(audioContext.destination);
              osc.frequency.value = freq;
              osc.type = 'sine';
              gain.gain.setValueAtTime(0.2, audioContext.currentTime);
              gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
              osc.start(audioContext.currentTime);
              osc.stop(audioContext.currentTime + 0.3);
            }, i * 100);
          });
          break;
      }
    }

    function loadPlayerStats() {
      const saved = localStorage.getItem('playerStats');
      if (saved) {
        playerStats = JSON.parse(saved);
      }
    }

    function savePlayerStats() {
      localStorage.setItem('playerStats', JSON.stringify(playerStats));
    }

    function updatePlayerStatsDisplay() {
      const total = playerStats.wins + playerStats.losses + playerStats.draws;
      document.getElementById("total-games").textContent = total;
      document.getElementById("total-wins").textContent = playerStats.wins;
      document.getElementById("total-losses").textContent = playerStats.losses;
      document.getElementById("total-draws").textContent = playerStats.draws;
      const winRate = total > 0 ? Math.round((playerStats.wins / total) * 100) : 0;
      document.getElementById("win-rate").textContent = winRate + '%';
      document.getElementById("win-rate").style.color = winRate >= 50 ? '#2ecc71' : winRate >= 30 ? '#f39c12' : '#e74c3c';
    }

    function checkAchievements() {
      const total = playerStats.wins + playerStats.losses + playerStats.draws;
      const winRate = total > 0 ? (playerStats.wins / total) * 100 : 0;
      
      const newAchievements = [];
      
      // Game count achievements
      if (total >= 1 && !achievements.includes('first_game')) {
        newAchievements.push({ id: 'first_game', name: 'ðŸŽ® First Game', desc: 'Played your first game' });
        achievements.push('first_game');
      }
      if (playerStats.wins >= 1 && !achievements.includes('first_win')) {
        newAchievements.push({ id: 'first_win', name: 'ðŸ† First Victory', desc: 'Won your first game' });
        achievements.push('first_win');
      }
      if (playerStats.wins >= 10 && !achievements.includes('ten_wins')) {
        newAchievements.push({ id: 'ten_wins', name: 'â­ Decade of Wins', desc: 'Won 10 games' });
        achievements.push('ten_wins');
      }
      if (playerStats.wins >= 50 && !achievements.includes('fifty_wins')) {
        newAchievements.push({ id: 'fifty_wins', name: 'ðŸ‘‘ Master Player', desc: 'Won 50 games' });
        achievements.push('fifty_wins');
      }
      if (total >= 100 && !achievements.includes('century')) {
        newAchievements.push({ id: 'century', name: 'ðŸ’¯ Century Club', desc: 'Played 100 games' });
        achievements.push('century');
      }
      if (winRate >= 70 && total >= 10 && !achievements.includes('excellent')) {
        newAchievements.push({ id: 'excellent', name: 'ðŸŒŸ Excellent Player', desc: '70%+ win rate (10+ games)' });
        achievements.push('excellent');
      }
      
      // In-game capture achievements (lifetime stats)
      if (lifetimeStats.capturesByQueen >= 10 && !achievements.includes('queen_capturer')) {
        newAchievements.push({ id: 'queen_capturer', name: 'ðŸ‘¸ Queen Capturer', desc: 'Captured 10 pieces with your queen' });
        achievements.push('queen_capturer');
      }
      if (lifetimeStats.capturesByRook >= 10 && !achievements.includes('rook_capturer')) {
        newAchievements.push({ id: 'rook_capturer', name: 'ðŸ° Rook Capturer', desc: 'Captured 10 pieces with your rook' });
        achievements.push('rook_capturer');
      }
      if (lifetimeStats.capturesByBishop >= 10 && !achievements.includes('bishop_capturer')) {
        newAchievements.push({ id: 'bishop_capturer', name: 'â™— Bishop Capturer', desc: 'Captured 10 pieces with your bishop' });
        achievements.push('bishop_capturer');
      }
      if (lifetimeStats.capturesByKnight >= 10 && !achievements.includes('knight_capturer')) {
        newAchievements.push({ id: 'knight_capturer', name: 'ðŸ´ Knight Capturer', desc: 'Captured 10 pieces with your knight' });
        achievements.push('knight_capturer');
      }
      if (lifetimeStats.capturesByPawn >= 10 && !achievements.includes('pawn_capturer')) {
        newAchievements.push({ id: 'pawn_capturer', name: 'â™Ÿï¸ Pawn Capturer', desc: 'Captured 10 pieces with your pawn' });
        achievements.push('pawn_capturer');
      }
      if (lifetimeStats.totalCaptures >= 50 && !achievements.includes('capture_master')) {
        newAchievements.push({ id: 'capture_master', name: 'âš”ï¸ Capture Master', desc: 'Captured 50 pieces total' });
        achievements.push('capture_master');
      }
      if (lifetimeStats.totalCaptures >= 100 && !achievements.includes('capture_legend')) {
        newAchievements.push({ id: 'capture_legend', name: 'ðŸ—¡ï¸ Capture Legend', desc: 'Captured 100 pieces total' });
        achievements.push('capture_legend');
      }
      
      // Special move achievements
      if (lifetimeStats.castlingMoves >= 5 && !achievements.includes('castler')) {
        newAchievements.push({ id: 'castler', name: 'ðŸ° Castler', desc: 'Castled 5 times' });
        achievements.push('castler');
      }
      if (lifetimeStats.promotions >= 5 && !achievements.includes('promoter')) {
        newAchievements.push({ id: 'promoter', name: 'â¬†ï¸ Promoter', desc: 'Promoted 5 pawns' });
        achievements.push('promoter');
      }
      if (lifetimeStats.enPassants >= 1 && !achievements.includes('en_passant')) {
        newAchievements.push({ id: 'en_passant', name: 'ðŸŽ¯ En Passant', desc: 'Performed an en passant capture' });
        achievements.push('en_passant');
      }
      if (lifetimeStats.checksGiven >= 50 && !achievements.includes('check_giver')) {
        newAchievements.push({ id: 'check_giver', name: 'âœ“ Check Giver', desc: 'Gave 50 checks' });
        achievements.push('check_giver');
      }
      
      // Milestone achievements (always achievable)
      if (playerStats.wins >= 3 && !achievements.includes('three_wins')) {
        newAchievements.push({ id: 'three_wins', name: 'ðŸ”¥ Three Wins', desc: 'Won 3 games', points: 25 });
        achievements.push('three_wins');
      }
      if (playerStats.wins >= 5 && !achievements.includes('five_wins')) {
        newAchievements.push({ id: 'five_wins', name: 'âš¡ Five Wins', desc: 'Won 5 games', points: 50 });
        achievements.push('five_wins');
      }
      if (playerStats.wins >= 15 && !achievements.includes('fifteen_wins')) {
        newAchievements.push({ id: 'fifteen_wins', name: 'ðŸŒŸ Fifteen Wins', desc: 'Won 15 games', points: 100 });
        achievements.push('fifteen_wins');
      }
      if (playerStats.wins >= 100 && !achievements.includes('centurion')) {
        newAchievements.push({ id: 'centurion', name: 'ðŸ’¯ Centurion', desc: 'Won 100 games', points: 500 });
        achievements.push('centurion');
      }
      if (winRate >= 80 && total >= 20 && !achievements.includes('grandmaster')) {
        newAchievements.push({ id: 'grandmaster', name: 'ðŸŽ–ï¸ Grandmaster', desc: '80%+ win rate (20+ games)', points: 300 });
        achievements.push('grandmaster');
      }
      
      // More motivating achievements
      if (playerStats.wins >= 25 && !achievements.includes('quarter_century')) {
        newAchievements.push({ id: 'quarter_century', name: 'ðŸŽ¯ Quarter Century', desc: 'Won 25 games', points: 150 });
        achievements.push('quarter_century');
      }
      if (playerStats.wins >= 200 && !achievements.includes('double_centurion')) {
        newAchievements.push({ id: 'double_centurion', name: 'ðŸ’¯ðŸ’¯ Double Centurion', desc: 'Won 200 games', points: 1000 });
        achievements.push('double_centurion');
      }
      if (playerStats.wins >= 500 && !achievements.includes('half_millennium')) {
        newAchievements.push({ id: 'half_millennium', name: 'ðŸ† Half Millennium', desc: 'Won 500 games', points: 2500 });
        achievements.push('half_millennium');
      }
      if (total >= 50 && !achievements.includes('fifty_games')) {
        newAchievements.push({ id: 'fifty_games', name: 'ðŸ“Š Fifty Games', desc: 'Played 50 games', points: 75 });
        achievements.push('fifty_games');
      }
      if (total >= 250 && !achievements.includes('two_fifty')) {
        newAchievements.push({ id: 'two_fifty', name: 'ðŸ“ˆ Two Fifty', desc: 'Played 250 games', points: 400 });
        achievements.push('two_fifty');
      }
      if (total >= 500 && !achievements.includes('five_hundred')) {
        newAchievements.push({ id: 'five_hundred', name: 'ðŸŽ² Five Hundred', desc: 'Played 500 games', points: 800 });
        achievements.push('five_hundred');
      }
      if (winRate >= 60 && total >= 10 && !achievements.includes('good_player')) {
        newAchievements.push({ id: 'good_player', name: 'ðŸ‘ Good Player', desc: '60%+ win rate (10+ games)', points: 100 });
        achievements.push('good_player');
      }
      if (winRate >= 90 && total >= 20 && !achievements.includes('near_perfect')) {
        newAchievements.push({ id: 'near_perfect', name: 'âœ¨ Near Perfect', desc: '90%+ win rate (20+ games)', points: 500 });
        achievements.push('near_perfect');
      }
      
      // In-game action achievements
      if (lifetimeStats.capturesByQueen >= 25 && !achievements.includes('queen_master')) {
        newAchievements.push({ id: 'queen_master', name: 'ðŸ‘¸ Queen Master', desc: 'Captured 25 pieces with queen', points: 150 });
        achievements.push('queen_master');
      }
      if (lifetimeStats.capturesByQueen >= 50 && !achievements.includes('queen_legend')) {
        newAchievements.push({ id: 'queen_legend', name: 'ðŸ‘‘ Queen Legend', desc: 'Captured 50 pieces with queen', points: 300 });
        achievements.push('queen_legend');
      }
      if (lifetimeStats.totalCaptures >= 200 && !achievements.includes('capture_king')) {
        newAchievements.push({ id: 'capture_king', name: 'ðŸ‘‘ Capture King', desc: 'Captured 200 pieces total', points: 400 });
        achievements.push('capture_king');
      }
      if (lifetimeStats.totalCaptures >= 500 && !achievements.includes('capture_god')) {
        newAchievements.push({ id: 'capture_god', name: 'âš¡ Capture God', desc: 'Captured 500 pieces total', points: 1000 });
        achievements.push('capture_god');
      }
      if (lifetimeStats.castlingMoves >= 10 && !achievements.includes('castling_master')) {
        newAchievements.push({ id: 'castling_master', name: 'ðŸ° Castling Master', desc: 'Castled 10 times', points: 100 });
        achievements.push('castling_master');
      }
      if (lifetimeStats.castlingMoves >= 25 && !achievements.includes('castling_legend')) {
        newAchievements.push({ id: 'castling_legend', name: 'ðŸ° Castling Legend', desc: 'Castled 25 times', points: 250 });
        achievements.push('castling_legend');
      }
      if (lifetimeStats.promotions >= 10 && !achievements.includes('promotion_master')) {
        newAchievements.push({ id: 'promotion_master', name: 'â¬†ï¸ Promotion Master', desc: 'Promoted 10 pawns', points: 150 });
        achievements.push('promotion_master');
      }
      if (lifetimeStats.promotions >= 25 && !achievements.includes('promotion_legend')) {
        newAchievements.push({ id: 'promotion_legend', name: 'â¬†ï¸ Promotion Legend', desc: 'Promoted 25 pawns', points: 300 });
        achievements.push('promotion_legend');
      }
      if (lifetimeStats.checksGiven >= 100 && !achievements.includes('check_master')) {
        newAchievements.push({ id: 'check_master', name: 'âœ“ Check Master', desc: 'Gave 100 checks', points: 200 });
        achievements.push('check_master');
      }
      if (lifetimeStats.checksGiven >= 250 && !achievements.includes('check_legend')) {
        newAchievements.push({ id: 'check_legend', name: 'âœ“ Check Legend', desc: 'Gave 250 checks', points: 400 });
        achievements.push('check_legend');
      }
      if (lifetimeStats.enPassants >= 3 && !achievements.includes('en_passant_master')) {
        newAchievements.push({ id: 'en_passant_master', name: 'ðŸŽ¯ En Passant Master', desc: 'Performed 3 en passants', points: 200 });
        achievements.push('en_passant_master');
      }
      if (lifetimeStats.enPassants >= 10 && !achievements.includes('en_passant_legend')) {
        newAchievements.push({ id: 'en_passant_legend', name: 'ðŸŽ¯ En Passant Legend', desc: 'Performed 10 en passants', points: 500 });
        achievements.push('en_passant_legend');
      }
      
      // Balanced play achievements
      if (playerStats.draws >= 10 && !achievements.includes('peacemaker')) {
        newAchievements.push({ id: 'peacemaker', name: 'ðŸ¤ Peacemaker', desc: 'Drew 10 games', points: 100 });
        achievements.push('peacemaker');
      }
      if (playerStats.draws >= 25 && !achievements.includes('diplomat')) {
        newAchievements.push({ id: 'diplomat', name: 'ðŸ¤ Diplomat', desc: 'Drew 25 games', points: 200 });
        achievements.push('diplomat');
      }
      
      // Captured piece achievements (what pieces you captured, not what captured them)
      if (lifetimeStats.capturedQueens >= 5 && !achievements.includes('queen_hunter_5')) {
        newAchievements.push({ id: 'queen_hunter_5', name: 'ðŸ‘¸ Queen Hunter', desc: 'Captured 5 queens', points: 200 });
        achievements.push('queen_hunter_5');
      }
      if (lifetimeStats.capturedQueens >= 10 && !achievements.includes('queen_hunter_10')) {
        newAchievements.push({ id: 'queen_hunter_10', name: 'ðŸ‘¸ Queen Slayer', desc: 'Captured 10 queens', points: 500 });
        achievements.push('queen_hunter_10');
      }
      if (lifetimeStats.capturedRooks >= 10 && !achievements.includes('rook_hunter_10')) {
        newAchievements.push({ id: 'rook_hunter_10', name: 'ðŸ° Rook Hunter', desc: 'Captured 10 rooks', points: 150 });
        achievements.push('rook_hunter_10');
      }
      if (lifetimeStats.capturedRooks >= 25 && !achievements.includes('rook_hunter_25')) {
        newAchievements.push({ id: 'rook_hunter_25', name: 'ðŸ° Rook Slayer', desc: 'Captured 25 rooks', points: 300 });
        achievements.push('rook_hunter_25');
      }
      if (lifetimeStats.capturedBishops >= 10 && !achievements.includes('bishop_hunter_10')) {
        newAchievements.push({ id: 'bishop_hunter_10', name: 'â™— Bishop Hunter', desc: 'Captured 10 bishops', points: 150 });
        achievements.push('bishop_hunter_10');
      }
      if (lifetimeStats.capturedBishops >= 25 && !achievements.includes('bishop_hunter_25')) {
        newAchievements.push({ id: 'bishop_hunter_25', name: 'â™— Bishop Slayer', desc: 'Captured 25 bishops', points: 300 });
        achievements.push('bishop_hunter_25');
      }
      if (lifetimeStats.capturedKnights >= 10 && !achievements.includes('knight_hunter_10')) {
        newAchievements.push({ id: 'knight_hunter_10', name: 'ðŸ´ Knight Hunter', desc: 'Captured 10 knights', points: 150 });
        achievements.push('knight_hunter_10');
      }
      if (lifetimeStats.capturedKnights >= 25 && !achievements.includes('knight_hunter_25')) {
        newAchievements.push({ id: 'knight_hunter_25', name: 'ðŸ´ Knight Slayer', desc: 'Captured 25 knights', points: 300 });
        achievements.push('knight_hunter_25');
      }
      if (lifetimeStats.capturedPawns >= 50 && !achievements.includes('pawn_hunter_50')) {
        newAchievements.push({ id: 'pawn_hunter_50', name: 'â™Ÿï¸ Pawn Hunter', desc: 'Captured 50 pawns', points: 100 });
        achievements.push('pawn_hunter_50');
      }
      if (lifetimeStats.capturedPawns >= 100 && !achievements.includes('pawn_hunter_100')) {
        newAchievements.push({ id: 'pawn_hunter_100', name: 'â™Ÿï¸ Pawn Slayer', desc: 'Captured 100 pawns', points: 200 });
        achievements.push('pawn_hunter_100');
      }
      
      if (newAchievements.length > 0) {
        saveAchievements();
        updateAchievementsDisplay();
        updateTotalPoints();
        showAchievementNotification(newAchievements);
      }
    }

    function loadAchievements() {
      const saved = localStorage.getItem('achievements');
      if (saved) {
        achievements = JSON.parse(saved);
      }
    }

    function saveAchievements() {
      localStorage.setItem('achievements', JSON.stringify(achievements));
    }

    function getAllAchievementsList() {
      return [
        // General Achievements
        { id: 'first_game', name: 'ðŸŽ® First Game', desc: 'Played your first game', category: 'General', points: 10, progress: () => {
          const total = playerStats.wins + playerStats.losses + playerStats.draws;
          return { current: total, target: 1 };
        }},
        { id: 'first_win', name: 'ðŸ† First Victory', desc: 'Won your first game', category: 'General', points: 25, progress: () => {
          return { current: playerStats.wins, target: 1 };
        }},
        { id: 'three_wins', name: 'ðŸ”¥ Three Wins', desc: 'Won 3 games', category: 'General', points: 25, progress: () => {
          return { current: playerStats.wins, target: 3 };
        }},
        { id: 'five_wins', name: 'âš¡ Five Wins', desc: 'Won 5 games', category: 'General', points: 50, progress: () => {
          return { current: playerStats.wins, target: 5 };
        }},
        { id: 'ten_wins', name: 'â­ Decade of Wins', desc: 'Won 10 games', category: 'General', points: 75, progress: () => {
          return { current: playerStats.wins, target: 10 };
        }},
        { id: 'fifteen_wins', name: 'ðŸŒŸ Fifteen Wins', desc: 'Won 15 games', category: 'General', points: 100, progress: () => {
          return { current: playerStats.wins, target: 15 };
        }},
        { id: 'quarter_century', name: 'ðŸŽ¯ Quarter Century', desc: 'Won 25 games', category: 'General', points: 150, progress: () => {
          return { current: playerStats.wins, target: 25 };
        }},
        { id: 'fifty_wins', name: 'ðŸ‘‘ Master Player', desc: 'Won 50 games', category: 'General', points: 200, progress: () => {
          return { current: playerStats.wins, target: 50 };
        }},
        { id: 'centurion', name: 'ðŸ’¯ Centurion', desc: 'Won 100 games', category: 'General', points: 500, progress: () => {
          return { current: playerStats.wins, target: 100 };
        }},
        { id: 'double_centurion', name: 'ðŸ’¯ðŸ’¯ Double Centurion', desc: 'Won 200 games', category: 'General', points: 1000, progress: () => {
          return { current: playerStats.wins, target: 200 };
        }},
        { id: 'half_millennium', name: 'ðŸ† Half Millennium', desc: 'Won 500 games', category: 'General', points: 2500, progress: () => {
          return { current: playerStats.wins, target: 500 };
        }},
        { id: 'fifty_games', name: 'ðŸ“Š Fifty Games', desc: 'Played 50 games', category: 'General', points: 75, progress: () => {
          const total = playerStats.wins + playerStats.losses + playerStats.draws;
          return { current: total, target: 50 };
        }},
        { id: 'century', name: 'ðŸ’¯ Century Club', desc: 'Played 100 games', category: 'General', points: 150, progress: () => {
          const total = playerStats.wins + playerStats.losses + playerStats.draws;
          return { current: total, target: 100 };
        }},
        { id: 'two_fifty', name: 'ðŸ“ˆ Two Fifty', desc: 'Played 250 games', category: 'General', points: 400, progress: () => {
          const total = playerStats.wins + playerStats.losses + playerStats.draws;
          return { current: total, target: 250 };
        }},
        { id: 'five_hundred', name: 'ðŸŽ² Five Hundred', desc: 'Played 500 games', category: 'General', points: 800, progress: () => {
          const total = playerStats.wins + playerStats.losses + playerStats.draws;
          return { current: total, target: 500 };
        }},
        { id: 'good_player', name: 'ðŸ‘ Good Player', desc: '60%+ win rate (10+ games)', category: 'General', points: 100, progress: () => {
          const total = playerStats.wins + playerStats.losses + playerStats.draws;
          const winRate = total > 0 ? (playerStats.wins / total) * 100 : 0;
          return { current: Math.round(winRate), target: 60, needsTotal: total >= 10 };
        }},
        { id: 'excellent', name: 'ðŸŒŸ Excellent Player', desc: '70%+ win rate (10+ games)', category: 'General', points: 200, progress: () => {
          const total = playerStats.wins + playerStats.losses + playerStats.draws;
          const winRate = total > 0 ? (playerStats.wins / total) * 100 : 0;
          return { current: Math.round(winRate), target: 70, needsTotal: total >= 10 };
        }},
        { id: 'grandmaster', name: 'ðŸŽ–ï¸ Grandmaster', desc: '80%+ win rate (20+ games)', category: 'General', points: 300, progress: () => {
          const total = playerStats.wins + playerStats.losses + playerStats.draws;
          const winRate = total > 0 ? (playerStats.wins / total) * 100 : 0;
          return { current: Math.round(winRate), target: 80, needsTotal: total >= 20 };
        }},
        { id: 'near_perfect', name: 'âœ¨ Near Perfect', desc: '90%+ win rate (20+ games)', category: 'General', points: 500, progress: () => {
          const total = playerStats.wins + playerStats.losses + playerStats.draws;
          const winRate = total > 0 ? (playerStats.wins / total) * 100 : 0;
          return { current: Math.round(winRate), target: 90, needsTotal: total >= 20 };
        }},
        { id: 'peacemaker', name: 'ðŸ¤ Peacemaker', desc: 'Drew 10 games', category: 'General', points: 100, progress: () => {
          return { current: playerStats.draws, target: 10 };
        }},
        { id: 'diplomat', name: 'ðŸ¤ Diplomat', desc: 'Drew 25 games', category: 'General', points: 200, progress: () => {
          return { current: playerStats.draws, target: 25 };
        }},
        
        // Captured Piece Achievements (what pieces you captured)
        { id: 'queen_hunter_5', name: 'ðŸ‘¸ Queen Hunter', desc: 'Captured 5 queens', category: 'In-Game', points: 200, groupKey: 'captured_queens', progress: () => {
          return { current: lifetimeStats.capturedQueens, target: 5 };
        }},
        { id: 'queen_hunter_10', name: 'ðŸ‘¸ Queen Slayer', desc: 'Captured 10 queens', category: 'In-Game', points: 500, groupKey: 'captured_queens', progress: () => {
          return { current: lifetimeStats.capturedQueens, target: 10 };
        }},
        { id: 'rook_hunter_10', name: 'ðŸ° Rook Hunter', desc: 'Captured 10 rooks', category: 'In-Game', points: 150, groupKey: 'captured_rooks', progress: () => {
          return { current: lifetimeStats.capturedRooks, target: 10 };
        }},
        { id: 'rook_hunter_25', name: 'ðŸ° Rook Slayer', desc: 'Captured 25 rooks', category: 'In-Game', points: 300, groupKey: 'captured_rooks', progress: () => {
          return { current: lifetimeStats.capturedRooks, target: 25 };
        }},
        { id: 'bishop_hunter_10', name: 'â™— Bishop Hunter', desc: 'Captured 10 bishops', category: 'In-Game', points: 150, groupKey: 'captured_bishops', progress: () => {
          return { current: lifetimeStats.capturedBishops, target: 10 };
        }},
        { id: 'bishop_hunter_25', name: 'â™— Bishop Slayer', desc: 'Captured 25 bishops', category: 'In-Game', points: 300, groupKey: 'captured_bishops', progress: () => {
          return { current: lifetimeStats.capturedBishops, target: 25 };
        }},
        { id: 'knight_hunter_10', name: 'ðŸ´ Knight Hunter', desc: 'Captured 10 knights', category: 'In-Game', points: 150, groupKey: 'captured_knights', progress: () => {
          return { current: lifetimeStats.capturedKnights, target: 10 };
        }},
        { id: 'knight_hunter_25', name: 'ðŸ´ Knight Slayer', desc: 'Captured 25 knights', category: 'In-Game', points: 300, groupKey: 'captured_knights', progress: () => {
          return { current: lifetimeStats.capturedKnights, target: 25 };
        }},
        { id: 'pawn_hunter_50', name: 'â™Ÿï¸ Pawn Hunter', desc: 'Captured 50 pawns', category: 'In-Game', points: 100, groupKey: 'captured_pawns', progress: () => {
          return { current: lifetimeStats.capturedPawns, target: 50 };
        }},
        { id: 'pawn_hunter_100', name: 'â™Ÿï¸ Pawn Slayer', desc: 'Captured 100 pawns', category: 'In-Game', points: 200, groupKey: 'captured_pawns', progress: () => {
          return { current: lifetimeStats.capturedPawns, target: 100 };
        }},
        
        // Group keys for other achievement types
        { id: 'queen_capturer', name: 'ðŸ‘¸ Queen Capturer', desc: 'Captured 10 pieces with your queen', category: 'In-Game', points: 50, groupKey: 'captures_with_queen', progress: () => {
          return { current: lifetimeStats.capturesByQueen, target: 10 };
        }},
        { id: 'queen_master', name: 'ðŸ‘¸ Queen Master', desc: 'Captured 25 pieces with queen', category: 'In-Game', points: 150, groupKey: 'captures_with_queen', progress: () => {
          return { current: lifetimeStats.capturesByQueen, target: 25 };
        }},
        { id: 'queen_legend', name: 'ðŸ‘‘ Queen Legend', desc: 'Captured 50 pieces with queen', category: 'In-Game', points: 300, groupKey: 'captures_with_queen', progress: () => {
          return { current: lifetimeStats.capturesByQueen, target: 50 };
        }},
        { id: 'rook_capturer', name: 'ðŸ° Rook Capturer', desc: 'Captured 10 pieces with your rook', category: 'In-Game', points: 50, groupKey: 'captures_with_rook', progress: () => {
          return { current: lifetimeStats.capturesByRook, target: 10 };
        }},
        { id: 'bishop_capturer', name: 'â™— Bishop Capturer', desc: 'Captured 10 pieces with your bishop', category: 'In-Game', points: 50, groupKey: 'captures_with_bishop', progress: () => {
          return { current: lifetimeStats.capturesByBishop, target: 10 };
        }},
        { id: 'knight_capturer', name: 'ðŸ´ Knight Capturer', desc: 'Captured 10 pieces with your knight', category: 'In-Game', points: 50, groupKey: 'captures_with_knight', progress: () => {
          return { current: lifetimeStats.capturesByKnight, target: 10 };
        }},
        { id: 'pawn_capturer', name: 'â™Ÿï¸ Pawn Capturer', desc: 'Captured 10 pieces with your pawn', category: 'In-Game', points: 50, groupKey: 'captures_with_pawn', progress: () => {
          return { current: lifetimeStats.capturesByPawn, target: 10 };
        }},
        { id: 'capture_master', name: 'âš”ï¸ Capture Master', desc: 'Captured 50 pieces total', category: 'In-Game', points: 100, groupKey: 'total_captures', progress: () => {
          return { current: lifetimeStats.totalCaptures, target: 50 };
        }},
        { id: 'capture_legend', name: 'ðŸ—¡ï¸ Capture Legend', desc: 'Captured 100 pieces total', category: 'In-Game', points: 200, groupKey: 'total_captures', progress: () => {
          return { current: lifetimeStats.totalCaptures, target: 100 };
        }},
        { id: 'capture_king', name: 'ðŸ‘‘ Capture King', desc: 'Captured 200 pieces total', category: 'In-Game', points: 400, groupKey: 'total_captures', progress: () => {
          return { current: lifetimeStats.totalCaptures, target: 200 };
        }},
        { id: 'capture_god', name: 'âš¡ Capture God', desc: 'Captured 500 pieces total', category: 'In-Game', points: 1000, groupKey: 'total_captures', progress: () => {
          return { current: lifetimeStats.totalCaptures, target: 500 };
        }},
        { id: 'castler', name: 'ðŸ° Castler', desc: 'Castled 5 times', category: 'In-Game', points: 50, groupKey: 'castling', progress: () => {
          return { current: lifetimeStats.castlingMoves, target: 5 };
        }},
        { id: 'castling_master', name: 'ðŸ° Castling Master', desc: 'Castled 10 times', category: 'In-Game', points: 100, groupKey: 'castling', progress: () => {
          return { current: lifetimeStats.castlingMoves, target: 10 };
        }},
        { id: 'castling_legend', name: 'ðŸ° Castling Legend', desc: 'Castled 25 times', category: 'In-Game', points: 250, groupKey: 'castling', progress: () => {
          return { current: lifetimeStats.castlingMoves, target: 25 };
        }},
        { id: 'promoter', name: 'â¬†ï¸ Promoter', desc: 'Promoted 5 pawns', category: 'In-Game', points: 75, groupKey: 'promotions', progress: () => {
          return { current: lifetimeStats.promotions, target: 5 };
        }},
        { id: 'promotion_master', name: 'â¬†ï¸ Promotion Master', desc: 'Promoted 10 pawns', category: 'In-Game', points: 150, groupKey: 'promotions', progress: () => {
          return { current: lifetimeStats.promotions, target: 10 };
        }},
        { id: 'promotion_legend', name: 'â¬†ï¸ Promotion Legend', desc: 'Promoted 25 pawns', category: 'In-Game', points: 300, groupKey: 'promotions', progress: () => {
          return { current: lifetimeStats.promotions, target: 25 };
        }},
        { id: 'en_passant', name: 'ðŸŽ¯ En Passant', desc: 'Performed an en passant capture', category: 'In-Game', points: 100, groupKey: 'en_passants', progress: () => {
          return { current: lifetimeStats.enPassants, target: 1 };
        }},
        { id: 'en_passant_master', name: 'ðŸŽ¯ En Passant Master', desc: 'Performed 3 en passants', category: 'In-Game', points: 200, groupKey: 'en_passants', progress: () => {
          return { current: lifetimeStats.enPassants, target: 3 };
        }},
        { id: 'en_passant_legend', name: 'ðŸŽ¯ En Passant Legend', desc: 'Performed 10 en passants', category: 'In-Game', points: 500, groupKey: 'en_passants', progress: () => {
          return { current: lifetimeStats.enPassants, target: 10 };
        }},
        { id: 'check_giver', name: 'âœ“ Check Giver', desc: 'Gave 50 checks', category: 'In-Game', points: 75, groupKey: 'checks', progress: () => {
          return { current: lifetimeStats.checksGiven, target: 50 };
        }},
        { id: 'check_master', name: 'âœ“ Check Master', desc: 'Gave 100 checks', category: 'In-Game', points: 200, groupKey: 'checks', progress: () => {
          return { current: lifetimeStats.checksGiven, target: 100 };
        }},
        { id: 'check_legend', name: 'âœ“ Check Legend', desc: 'Gave 250 checks', category: 'In-Game', points: 400, groupKey: 'checks', progress: () => {
          return { current: lifetimeStats.checksGiven, target: 250 };
        }}
      ];
    }

    function updateTotalPoints() {
      const allAchievements = getAllAchievementsList();
      let totalPoints = 0;
      achievements.forEach(achId => {
        const ach = allAchievements.find(a => a.id === achId);
        if (ach && ach.points) {
          totalPoints += ach.points;
        }
      });
      const pointsEl = document.getElementById('total-achievement-points');
      if (pointsEl) {
        pointsEl.textContent = totalPoints.toLocaleString();
      }
    }

    function updateAchievementsDisplay() {
      const container = document.getElementById("achievements-list");
      container.innerHTML = '';
      
      const allAchievements = getAllAchievementsList();
      const unlocked = allAchievements.filter(ach => achievements.includes(ach.id));
      
      // Show only unlocked achievements in the small panel
      unlocked.slice(0, 6).forEach(ach => {
        const div = document.createElement('div');
        div.className = 'stats-row';
        const pointsText = ach.points ? ` <span style="color: #f39c12; font-weight: 700;">(${ach.points} pts)</span>` : '';
        div.innerHTML = `
          <span class="stats-label">${ach.name}:</span>
          <span class="stats-value" style="font-size: 0.85em;">${ach.desc}${pointsText}</span>
        `;
        container.appendChild(div);
      });
      
      if (unlocked.length === 0) {
        const div = document.createElement('div');
        div.className = 'stats-row';
        div.style.opacity = '0.6';
        div.innerHTML = '<span class="stats-value" style="font-size: 0.9em; font-style: italic;">No achievements unlocked yet</span>';
        container.appendChild(div);
      }
    }

    function showAllAchievements() {
      const modal = document.getElementById('all-achievements-modal');
      const container = document.getElementById('all-achievements-list');
      container.innerHTML = '';
      
      const allAchievements = getAllAchievementsList();
      
      // First group by category
      const byCategory = {};
      allAchievements.forEach(ach => {
        if (!byCategory[ach.category]) {
          byCategory[ach.category] = [];
        }
        byCategory[ach.category].push(ach);
      });
      
      // Render by category
      Object.keys(byCategory).forEach(category => {
        const categoryDiv = document.createElement('div');
        categoryDiv.style.marginBottom = '30px';
        
        const categoryTitle = document.createElement('h3');
        categoryTitle.textContent = category;
        categoryTitle.style.cssText = 'font-family: "Inter", sans-serif; font-size: 1.3em; font-weight: 700; color: #2c3e50; margin-bottom: 15px; padding-bottom: 8px; border-bottom: 2px solid #3498db;';
        categoryDiv.appendChild(categoryTitle);
        
        // Group achievements within category by groupKey
        const grouped = {};
        const ungrouped = [];
        
        byCategory[category].forEach(ach => {
          if (ach.groupKey) {
            if (!grouped[ach.groupKey]) {
              grouped[ach.groupKey] = [];
            }
            grouped[ach.groupKey].push(ach);
          } else {
            ungrouped.push(ach);
          }
        });
        
        // Sort grouped achievements by target value
        Object.keys(grouped).forEach(key => {
          grouped[key].sort((a, b) => {
            const aTarget = a.progress().target;
            const bTarget = b.progress().target;
            return aTarget - bTarget;
          });
        });
        
        // Render grouped achievements
        Object.keys(grouped).forEach(groupKey => {
          const group = grouped[groupKey];
          const groupDiv = document.createElement('div');
          groupDiv.className = 'achievement-group';
          groupDiv.style.marginBottom = '20px';
          
          // Find the next achievement to work on
          let nextAchievement = null;
          let nextIndex = -1;
          for (let i = 0; i < group.length; i++) {
            const ach = group[i];
            const isUnlocked = achievements.includes(ach.id);
            if (!isUnlocked) {
              nextAchievement = ach;
              nextIndex = i;
              break;
            }
          }
          
          // If all are unlocked, show the last one
          if (!nextAchievement && group.length > 0) {
            nextAchievement = group[group.length - 1];
            nextIndex = group.length - 1;
          }
          
          // Create the visible card (next achievement)
          if (nextAchievement) {
            const isUnlocked = achievements.includes(nextAchievement.id);
            const progress = nextAchievement.progress();
            const progressPercent = progress.target > 0 ? Math.min(100, (progress.current / progress.target) * 100) : 0;
            const showProgress = !isUnlocked && progressPercent < 100;
            const meetsRequirements = !progress.needsTotal || progress.needsTotal;
            const meetsNoLosses = !progress.needsNoLosses || progress.needsNoLosses;
            
            const card = document.createElement('div');
            card.className = `achievement-card ${isUnlocked ? 'unlocked' : 'locked'}`;
            card.style.position = 'relative';
            
            const pointsText = nextAchievement.points ? `<div style="font-size: 0.9em; color: #f39c12; font-weight: 700; margin-top: 5px;">${nextAchievement.points} points</div>` : '';
            
            // Add expand button if there are more achievements in the group
            const expandButton = group.length > 1 ? `
              <button class="expand-group-btn" onclick="toggleAchievementGroup('${groupKey}')" style="
                position: absolute;
                top: 10px;
                right: 10px;
                background: rgba(52, 152, 219, 0.1);
                border: 2px solid #3498db;
                border-radius: 50%;
                width: 30px;
                height: 30px;
                cursor: pointer;
                font-size: 1.2em;
                color: #3498db;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.3s ease;
                font-weight: 700;
              " onmouseover="this.style.background='rgba(52, 152, 219, 0.2)'" onmouseout="this.style.background='rgba(52, 152, 219, 0.1)'">
                <span id="expand-icon-${groupKey}">â–¼</span>
              </button>
            ` : '';
            
            card.innerHTML = `
              ${expandButton}
              <div class="achievement-name">${nextAchievement.name} ${isUnlocked ? '<span style="color: #2ecc71; font-size: 0.9em;">âœ“</span>' : ''}</div>
              <div class="achievement-desc">${nextAchievement.desc}</div>
              ${pointsText}
              ${showProgress && meetsRequirements && meetsNoLosses ? `
                <div class="achievement-progress">${progress.current} / ${progress.target}</div>
                <div class="achievement-progress-bar">
                  <div class="achievement-progress-fill" style="width: ${progressPercent}%"></div>
                </div>
              ` : isUnlocked ? '<div class="achievement-progress" style="color: #2ecc71; margin-top: 8px;">âœ“ Unlocked</div>' : '<div class="achievement-progress" style="margin-top: 8px;">Locked</div>'}
            `;
            
            groupDiv.appendChild(card);
            
            // Create hidden container for all achievements in group
            const allGroupAchievements = document.createElement('div');
            allGroupAchievements.id = `group-${groupKey}`;
            allGroupAchievements.className = 'achievement-group-all';
            allGroupAchievements.style.display = 'none';
            allGroupAchievements.style.marginTop = '10px';
            allGroupAchievements.style.paddingTop = '10px';
            allGroupAchievements.style.borderTop = '2px solid #e9ecef';
            
            group.forEach((ach, idx) => {
              if (idx === nextIndex) return; // Skip the one already shown
              
              const isUnlocked = achievements.includes(ach.id);
              const progress = ach.progress();
              const progressPercent = progress.target > 0 ? Math.min(100, (progress.current / progress.target) * 100) : 0;
              const showProgress = !isUnlocked && progressPercent < 100;
              const meetsRequirements = !progress.needsTotal || progress.needsTotal;
              const meetsNoLosses = !progress.needsNoLosses || progress.needsNoLosses;
              
              const subCard = document.createElement('div');
              subCard.className = `achievement-card ${isUnlocked ? 'unlocked' : 'locked'}`;
              subCard.style.marginBottom = '10px';
              
              const pointsText = ach.points ? `<div style="font-size: 0.9em; color: #f39c12; font-weight: 700; margin-top: 5px;">${ach.points} points</div>` : '';
              subCard.innerHTML = `
                <div class="achievement-name">${ach.name} ${isUnlocked ? '<span style="color: #2ecc71; font-size: 0.9em;">âœ“</span>' : ''}</div>
                <div class="achievement-desc">${ach.desc}</div>
                ${pointsText}
                ${showProgress && meetsRequirements && meetsNoLosses ? `
                  <div class="achievement-progress">${progress.current} / ${progress.target}</div>
                  <div class="achievement-progress-bar">
                    <div class="achievement-progress-fill" style="width: ${progressPercent}%"></div>
                  </div>
                ` : isUnlocked ? '<div class="achievement-progress" style="color: #2ecc71; margin-top: 8px;">âœ“ Unlocked</div>' : '<div class="achievement-progress" style="margin-top: 8px;">Locked</div>'}
              `;
              
              allGroupAchievements.appendChild(subCard);
            });
            
            groupDiv.appendChild(allGroupAchievements);
            categoryDiv.appendChild(groupDiv);
          }
        });
        
        // Render ungrouped achievements
        if (ungrouped.length > 0) {
          const categoryGrid = document.createElement('div');
          categoryGrid.className = 'achievements-grid';
          categoryGrid.style.gridTemplateColumns = 'repeat(auto-fill, minmax(280px, 1fr))';
          categoryGrid.style.marginBottom = '0';
          
          ungrouped.forEach(ach => {
            const isUnlocked = achievements.includes(ach.id);
            const progress = ach.progress();
            const progressPercent = progress.target > 0 ? Math.min(100, (progress.current / progress.target) * 100) : 0;
            const showProgress = !isUnlocked && progressPercent < 100;
            const meetsRequirements = !progress.needsTotal || progress.needsTotal;
            const meetsNoLosses = !progress.needsNoLosses || progress.needsNoLosses;
            
            const card = document.createElement('div');
            card.className = `achievement-card ${isUnlocked ? 'unlocked' : 'locked'}`;
            
            const pointsText = ach.points ? `<div style="font-size: 0.9em; color: #f39c12; font-weight: 700; margin-top: 5px;">${ach.points} points</div>` : '';
            card.innerHTML = `
              <div class="achievement-name">${ach.name} ${isUnlocked ? '<span style="color: #2ecc71; font-size: 0.9em;">âœ“</span>' : ''}</div>
              <div class="achievement-desc">${ach.desc}</div>
              ${pointsText}
              ${showProgress && meetsRequirements && meetsNoLosses ? `
                <div class="achievement-progress">${progress.current} / ${progress.target}</div>
                <div class="achievement-progress-bar">
                  <div class="achievement-progress-fill" style="width: ${progressPercent}%"></div>
                </div>
              ` : isUnlocked ? '<div class="achievement-progress" style="color: #2ecc71; margin-top: 8px;">âœ“ Unlocked</div>' : '<div class="achievement-progress" style="margin-top: 8px;">Locked</div>'}
            `;
            
            categoryGrid.appendChild(card);
          });
          
          categoryDiv.appendChild(categoryGrid);
        }
        
        container.appendChild(categoryDiv);
      });
      
      modal.classList.add('show');
    }

    function toggleAchievementGroup(groupKey) {
      const groupDiv = document.getElementById(`group-${groupKey}`);
      const icon = document.getElementById(`expand-icon-${groupKey}`);
      
      if (groupDiv.style.display === 'none') {
        groupDiv.style.display = 'block';
        icon.textContent = 'â–²';
      } else {
        groupDiv.style.display = 'none';
        icon.textContent = 'â–¼';
      }
    }

    function closeAllAchievements() {
      document.getElementById('all-achievements-modal').classList.remove('show');
    }

    function loadLifetimeStats() {
      const saved = localStorage.getItem('lifetimeStats');
      if (saved) {
        lifetimeStats = JSON.parse(saved);
      }
    }

    function saveLifetimeStats() {
      localStorage.setItem('lifetimeStats', JSON.stringify(lifetimeStats));
    }

    function showAchievementNotification(newAchievements) {
      newAchievements.forEach((ach, index) => {
        setTimeout(() => {
          const notification = document.createElement('div');
          notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #2ecc71, #27ae60);
            color: white;
            padding: 20px 25px;
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(46, 204, 113, 0.4);
            z-index: 10004;
            font-family: 'Inter', sans-serif;
            font-weight: 600;
            animation: slideInRight 0.5s ease-out;
            max-width: 300px;
          `;
          notification.innerHTML = `
            <div style="font-size: 1.5em; margin-bottom: 8px;">${ach.name}</div>
            <div style="font-size: 0.9em; opacity: 0.95;">${ach.desc}</div>
          `;
          document.body.appendChild(notification);
          
          setTimeout(() => {
            notification.style.animation = 'slideOutRight 0.5s ease-in forwards';
            setTimeout(() => notification.remove(), 500);
          }, 3000);
        }, index * 400);
      });
    }

    function setupTimerDisplayOrder() {
      // Get the parent container
      const container = document.getElementById('timers-container');
      
      // Get the individual time slots
      const whiteSlot = document.getElementById('time-slot-white');
      const blackSlot = document.getElementById('time-slot-black');

      // Determine player and engine colors
      const playerIsWhite = playerColor === 'white';
      const playerSlot = playerIsWhite ? whiteSlot : blackSlot;
      const engineSlot = playerIsWhite ? blackSlot : whiteSlot;

      // Remove existing children
      container.innerHTML = '';

      // Engine time always on top, Player time always on bottom
      container.appendChild(engineSlot);
      container.appendChild(playerSlot);
    }

    async function startGame() {
      gameOver = false;
      
      const side = document.getElementById("color-select").value;
      const timeOption = document.getElementById("time-control").value;      blindfoldMode = document.getElementById("blindfold-mode").checked;      showHistoryInBlindfold = document.getElementById("show-history").checked;      playerColor = side === "random" ? (Math.random() < 0.5 ? "white" : "black") : side;
      const [base, inc] =
        timeOption === "none" ? [null, null] : timeOption.split("|").map(Number);

      timeLimited = timeOption !== "none";
      increment = inc || 0;
      whiteTime = base ? base * 1000 : 0;
      blackTime = base ? base * 1000 : 0;

      // Show or hide timers based on time control
      const timersContainer = document.getElementById("timers-container");
      if (timeLimited) {
        timersContainer.style.display = "flex";
      } else {
        timersContainer.style.display = "none";
      }

      // Reset game (don't create new, just reset existing)
      if (!game) {
        game = new Chess();
      } else {
        game.reset();
      }
      moveHistory = [];
      currentMoveIndex = -1;
      capturedPieces = { white: [], black: [] };
      lastMoveSquares = { from: null, to: null };
      gameStartTime = new Date();
      premoves = []; // Clear any premoves
      
      // Reset game stats for new game
      gameStats = {
        capturesByQueen: 0,
        capturesByRook: 0,
        capturesByBishop: 0,
        capturesByKnight: 0,
        capturesByPawn: 0,
        totalCaptures: 0,
        checksGiven: 0,
        castlingMoves: 0,
        promotions: 0,
        enPassants: 0,
        longestGame: 0,
        shortestWin: Infinity
      };
      selectedSquare = null; // Clear any selection
      
      // Hide the options panel with fade effect
      const choosePanel = document.getElementById("choose-side");
      choosePanel.style.transition = "opacity 0.3s ease, transform 0.3s ease";
      choosePanel.style.opacity = "0";
      choosePanel.style.transform = "scale(0.95)";
      setTimeout(() => {
        choosePanel.style.display = "none";
      }, 300);
      
      document.getElementById("move-timer-container").innerHTML = 'Time for this move: <span id="timer">00:00.00</span>';

      updateLastMove(null, "00:00.00", 0, 0);
      updateTurnDisplay();

      // Destroy preview board and create game board
      if (board) {
        board.destroy();
      }
      
      board = Chessboard("board", {
        draggable: true,
        position: "start",
        orientation: playerColor,
        snapSpeed: 50,
        snapbackSpeed: 50,
        appearSpeed: 0,
        moveSpeed: 100,
        trashSpeed: 50,
        dragThrottleRate: 0,
        sparePieces: false,
        dropOffBoard: 'snapback',
        onDragStart: (source, piece, position, orientation) => {
          console.log('onDragStart called for:', source, 'selectedSquare before:', selectedSquare);
          
          // Store the drag start square and time for click detection
          window.dragStartSquare = source;
          window.dragStartTime = Date.now();
          
          // Clear any previous highlights when starting to drag a new piece
          $("#board .square-55d63").removeClass("highlight-legal");
          
          // Don't allow dragging if game is over
          if (game.game_over() || gameOver) {
            return false;
          }
          
          const turn = game.turn();
          const isPlayerTurn = (playerColor === "white" && turn === "w") || (playerColor === "black" && turn === "b");
          
          // Allow dragging opponent's pieces for premove, or own pieces on player's turn
          if (!isPlayerTurn) {
            // This is a premove - allow dragging player's pieces only
            if ((playerColor === "white" && piece.search(/^w/) === -1) || 
                (playerColor === "black" && piece.search(/^b/) === -1)) {
              return false; // Can't premove opponent's pieces
            }
            return true; // Allow premove
          }
          
          // Don't allow dragging opponent's pieces on player's turn
          if ((turn === 'w' && piece.search(/^b/) !== -1) || (turn === 'b' && piece.search(/^w/) !== -1)) {
            return false;
          }
          
          // Highlight legal moves when starting to drag
          highlightLegalMoves(source);
        },
        onDragMove: (newLocation, oldLocation, source, piece, position, orientation) => {
          // Remove previous legal-target class
          $("#board .square-55d63").removeClass("legal-target");
          
          // Only add yellow border if hovering over a legal move square
          const moves = game.moves({ square: source, verbose: true });
          const isLegal = moves.some(move => move.to === newLocation);
          
          if (isLegal) {
            $(`#board .square-${newLocation}`).addClass("legal-target");
          }
        },
        onMouseoutSquare: (square, piece) => {
          // Only remove legal-target class (yellow hover border during drag)
          $("#board .square-55d63").removeClass("legal-target");
          // Don't remove legal move dots - they stay until piece is deselected or moved
        },
        onDrop: (source, target) => {
          console.log('onDrop called:', source, '->', target);
          
          // Detect click-to-move: if dropped on same square, it's a click
          if (source === target) {
            console.log('Click detected (drop on same square):', source);
            handleSquareClick(source);
            return 'snapback'; // Return piece to original position
          }
          
          const turn = game.turn();
          const isPlayerTurn = (playerColor === "white" && turn === "w") || (playerColor === "black" && turn === "b");
          
          // Handle premove (during opponent's turn)
          if (!isPlayerTurn) {
            // Verify there's a piece at the source that belongs to the player
            const sourcePiece = game.get(source);
            if (!sourcePiece || sourcePiece.color !== (playerColor === 'white' ? 'w' : 'b')) {
              return 'snapback';
            }
            
            // Validate premove is theoretically legal for this piece type
            if (!isPremoveLegal(source, target, sourcePiece)) {
              console.log('Premove not valid for piece type:', sourcePiece.type, source, '->', target);
              return 'snapback';
            }
            
            // Add new premove to the array (chain of premoves)
            const newPremove = { from: source, to: target };
            premoves.push(newPremove);
            premoveJustSet = true;
            console.log('Premove added via drag:', newPremove, 'Total premoves:', premoves.length);
            
            // Update visual to show all premoves in the chain
            updatePremoveVisual();
            
            // Don't snapback - keep the piece moved
            return;
          }
          
          // Clear premove if player makes a manual move
          clearPremove();
          
          // Validate move synchronously first
          if (gameOver) {
            return 'snapback';
          }
          
          // Check if move is legal
          const move = game.move({ from: source, to: target, promotion: 'q' });
          if (!move) {
            return 'snapback';
          }
          
          // Move is legal - undo it and let handleMove process it properly
          game.undo();
          handleMove(source, target);
        },
        onSnapEnd: () => {
          // Clean up after drag/drop (clicks are handled in onDrop)
          $("#board .square-55d63").removeClass("legal-target");
          
          // Only remove highlights if not in click-to-move mode
          if (!selectedSquare) {
            removeHighlights();
          }
        },
        onClick: (square) => {
          const turn = game.turn();
          const isPlayerTurn = (playerColor === "white" && turn === "w") || (playerColor === "black" && turn === "b");
          const position = board.position();
          const piece = position[square];
          
          // If there's a selected piece
          if (selectedSquare) {
            // If clicking the same square, deselect
            if (selectedSquare === square) {
              selectedSquare = null;
              removeHighlights();
              return;
            }
            
            // Check if this is a legal move or premove
            if (!isPlayerTurn) {
              // Handle premove click
              if (!piece || (playerColor === "white" && piece.search(/^w/) !== -1) || 
                  (playerColor === "black" && piece.search(/^b/) !== -1)) {
                // Clicking empty square or own piece - try to premove
                const premoveFrom = selectedSquare;
                const premoveTo = square;
                
                // Clear highlights and selection
                selectedSquare = null;
                removeHighlights();
                
                // If clicking own piece, select it instead
                if (piece) {
                  selectedSquare = square;
                  highlightLegalMoves(square);
                } else {
                  // Add new premove to the array (chain of premoves)
                  const newPremove = { from: premoveFrom, to: premoveTo };
                  premoves.push(newPremove);
                  premoveJustSet = true;
                  console.log('Premove added via onClick:', newPremove, 'Total premoves:', premoves.length);
                  
                  // Update visual to show all premoves in the chain
                  updatePremoveVisual();
                }
                return;
              }
            } else {
              // Try to make a normal move
              const move = game.move({ from: selectedSquare, to: square, promotion: 'q' });
              
              if (move) {
                // Legal move
                clearPremove();
                selectedSquare = null;
                removeHighlights();
                game.undo();
                handleMove(move.from, move.to);
                return;
              } else if (piece) {
                // Illegal move but clicked on own piece - change selection
                const pieceColor = piece.search(/^w/) !== -1 ? 'w' : 'b';
                if ((turn === 'w' && pieceColor === 'w') || (turn === 'b' && pieceColor === 'b')) {
                  selectedSquare = square;
                  removeHighlights();
                  highlightLegalMoves(square);
                  return;
                }
              }
              
              // Invalid move, deselect
              selectedSquare = null;
              removeHighlights();
              return;
            }
          }
          
          // No piece selected - select clicked piece if valid
          if (piece) {
            if (!isPlayerTurn) {
              // During opponent's turn, allow selecting own pieces for premove
              if ((playerColor === "white" && piece.search(/^w/) !== -1) || 
                  (playerColor === "black" && piece.search(/^b/) !== -1)) {
                selectedSquare = square;
                highlightLegalMoves(square);
              }
            } else {
              // During player's turn, select own pieces
              const pieceColor = piece.search(/^w/) !== -1 ? 'w' : 'b';
              if ((turn === 'w' && pieceColor === 'w') || (turn === 'b' && pieceColor === 'b')) {
                selectedSquare = square;
                highlightLegalMoves(square);
              }
            }
          } else {
            // Clicked on empty square with no piece selected
            // Cancel all premoves if it's the opponent's turn (when premoves can be set)
            if (!isPlayerTurn && premoves.length > 0) {
              console.log('Empty square clicked during opponent turn, canceling all premoves');
              clearPremove();
            }
          }
        },
        pieceTheme: pieceThemes[currentPieceStyle],
      });
      
      // Add click-to-move functionality using mousedown/mouseup to avoid drag interference
      setTimeout(() => {
        let mouseDownSquare = null;
        
        $('#board').off('mousedown mouseup').on('mousedown', function(e) {
          // Only handle left click
          if (e.button !== 0) return;
          
          let $square = $(e.target);
          
          // If clicked on a piece image, get the parent square
          if ($square.hasClass('piece-417db') || $square.prop('tagName') === 'IMG') {
            $square = $square.parent();
          }
          
          // Make sure we have a square element
          if (!$square.hasClass('square-55d63')) {
            $square = $square.closest('.square-55d63');
          }
          
          if ($square.length === 0) return;
          
          const square = $square.data('square');
          if (square) {
            mouseDownSquare = square;
          }
        }).on('mouseup', function(e) {
          // Only handle left click
          if (e.button !== 0) return;
          
          if (!mouseDownSquare) return;
          
          let $square = $(e.target);
          
          // If released on a piece image, get the parent square
          if ($square.hasClass('piece-417db') || $square.prop('tagName') === 'IMG') {
            $square = $square.parent();
          }
          
          // Make sure we have a square element
          if (!$square.hasClass('square-55d63')) {
            $square = $square.closest('.square-55d63');
          }
          
          if ($square.length === 0) {
            mouseDownSquare = null;
            return;
          }
          
          const square = $square.data('square');
          
          // Only treat as click if mousedown and mouseup on same square
          if (square && square === mouseDownSquare) {
            console.log('Click detected on square:', square);
            handleSquareClick(square);
          }
          
          mouseDownSquare = null;
        });
      }, 100);

      // Cancel premoves on mousedown/touchstart outside of pieces/board
      let premoveJustSet = false;
      $(document).on('mousedown touchstart', function(e) {
        // Don't cancel if we just set a premove in the same event cycle
        if (premoves.length > 0 && !premoveJustSet) {
          // Check if the click is on the board or a piece
          const $target = $(e.target);
          const isOnBoard = $target.closest('#board').length > 0;
          const isOnPiece = $target.hasClass('piece-417db') || $target.hasClass('square-55d63') || $target.closest('.square-55d63').length > 0;
          
          // Only cancel if clicking outside the board/pieces
          if (!isOnBoard && !isOnPiece) {
            console.log('Click detected outside board/pieces, canceling all premoves');
            clearPremove();
          }
        }
        premoveJustSet = false;
      });

      // Prevent native HTML5 drag on piece images
      setTimeout(() => {
        $('#board img').on('dragstart', function(e) {
          e.preventDefault();
          return false;
        });
        // Also set draggable attribute to false
        $('#board img').attr('draggable', 'false');
        
        // Use MutationObserver to handle dynamically added images
        const observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            mutation.addedNodes.forEach(function(node) {
              if (node.tagName === 'IMG') {
                $(node).attr('draggable', 'false');
                $(node).on('dragstart', function(e) {
                  e.preventDefault();
                  return false;
                });
              }
              if (node.querySelectorAll) {
                $(node).find('img').attr('draggable', 'false');
                $(node).find('img').on('dragstart', function(e) {
                  e.preventDefault();
                  return false;
                });
              }
            });
          });
        });
        
        observer.observe(document.getElementById('board'), {
          childList: true,
          subtree: true
        });
      }, 200);
      
      // Add event delegation for dynamically added images
      $('#board').on('dragstart', 'img', function(e) {
        e.preventDefault();
        return false;
      });

      document.getElementById("move-timer-container").style.display = "block";
      document.getElementById("last-move-container").style.display = "block";
      document.getElementById("notation-container").style.display = "block";
      document.getElementById("notation-container").textContent = "";
      document.getElementById("game-stats-panel").style.display = "block";
      document.getElementById("export-pgn-btn").style.display = "block";
      document.getElementById("resign-btn").style.display = "block";
      document.getElementById("flip-board-btn").style.display = "block";
      document.getElementById("player-stats-panel").style.display = "block";
      document.getElementById("achievements-panel").style.display = "block";
      document.getElementById("opening-display").style.display = "none";
      
      // Load sound settings
      soundEnabled = document.getElementById("sound-effects").checked;
      
      // Load and display statistics
      loadPlayerStats();
      loadAchievements();
      loadLifetimeStats();
      updatePlayerStatsDisplay();
      updateAchievementsDisplay();
      updateTotalPoints();
      
      // Initialize stats
      updateGameStats();
      
      // Handle blindfold mode
      if (blindfoldMode) {
        document.getElementById("board").classList.add("blindfold-hidden");
        document.getElementById("timers-container").classList.add("blindfold-hidden");
        document.getElementById("move-input-container").style.display = "block";
        
        // Handle move history visibility in blindfold mode
        if (showHistoryInBlindfold) {
          document.getElementById("notation-container").classList.remove("blindfold-hidden");
        } else {
          document.getElementById("notation-container").classList.add("blindfold-hidden");
        }
      } else {
        document.getElementById("board").classList.remove("blindfold-hidden");
        document.getElementById("timers-container").classList.remove("blindfold-hidden");
        document.getElementById("notation-container").classList.remove("blindfold-hidden");
        document.getElementById("move-input-container").style.display = "none";
      }
      
      startTimer();
      
      // Initialize engine and apply modifiers before allowing moves
      await sendEngineCommand("start");
      await applyEngineModifiers(currentEngineStyle);
      
      if (playerColor === "black") {
        engineMove();
      }
    }

    async function handleMove(source, target) {
      console.log('handleMove called:', source, 'to', target);
      
      removeHighlights();
      const move = game.move({ from: source, to: target, promotion: "q" });
      if (!move) {
        console.log('Move was invalid in handleMove (should not happen)');
        return;
      }

      // Play sound effects
      if (move.captured) {
        playSound('capture');
      } else {
        playSound('move');
      }

      trackCapturedPiece(move);
      lastMoveSquares = { from: source, to: target };
      
      const prevTurn = game.turn() === "w" ? "b" : "w";
      const moveTimeMs = stopTimerAndUpdateTotal(prevTurn);
      updateLastMove(move.san, formatTime(moveTimeMs), game.turn() === "w" ? "black" : "white", game.history().length/2 + 0.5);
      board.position(game.fen());
      highlightLastMove(source, target);
      highlightCheck();
      updateTurnDisplay();
      updateOpeningDisplay();
      updateGameStats();

      if (game.in_checkmate()) {
        // Replaced alert() with UI message
        const moveContainer = document.getElementById("move-timer-container");
        moveContainer.innerHTML = 'CHECKMATE! <span style="color:#2ECC71;">You Win!</span>'; // Green text for win
        playSound('checkmate');
        celebrateCheckmate(true);
        gameOver = true;
        
        // Update statistics and achievements
        playerStats.wins++;
        savePlayerStats();
        updatePlayerStatsDisplay();
        checkAchievements();
        
        // Show rematch modal
        setTimeout(() => showRematchModal("ðŸŽ‰ Victory!", "Congratulations! You won! Play again?"), 2000);
        return;
      }

      startTimer(); // Start move timer for engine
      await engineMove();
    }
    async function engineMove() {
      console.log('=== engineMove START ===');
      console.log('Game over status:', gameOver);
      console.log('Current position:', game.fen());
      try {
        const lastMove = game.history().slice(-1)[0];
        console.log('Last move:', lastMove, 'Game turn:', game.turn());
        console.log('Sending request to engine...');
        const response = await fetch("https://hedgehoglover23.pythonanywhere.com/move", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            move: lastMove,
            color: game.turn() === "w" ? "black" : "white",
          }),
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        console.log('Engine response:', data);
        if (!data.move) {
          console.log('ERROR: No move returned from engine');
          // Replaced alert() with UI message
          const moveContainer = document.getElementById("move-timer-container");
          moveContainer.innerHTML = 'ENGINE ERROR: <span style="color:red;">No move returned.</span>';
          return;
        }

        console.log('Engine move:', data.move);
        // Stop timer *before* making the move on the game object
        const moveTimeMs = stopTimerAndUpdateTotal(game.turn()); 
        const move = game.move(data.move);
        console.log('Move applied to game. New position:', game.fen());
        console.log('Is checkmate?', game.in_checkmate());
        console.log('Is check?', game.in_check());
        console.log('Is game over?', game.game_over());
        
        trackCapturedPiece(move);
        lastMoveSquares = { from: move.from, to: move.to };
        
        updateLastMove(data.move, formatTime(moveTimeMs), game.turn() === "w" ? "black" : "white", game.history().length/2 + 0.5);
        
        // Show opponent's move first
        board.position(game.fen());
        
        highlightLastMove(move.from, move.to);
        highlightCheck();
        updateTurnDisplay();
        updateOpeningDisplay();
        updateGameStats();

        // Play sound for engine move
        if (move.captured) {
          playSound('capture');
        } else {
          playSound('move');
        }
        if (game.in_check()) {
          playSound('check');
        }

        if (game.in_checkmate()) {
          console.log('CHECKMATE DETECTED - Player Lost');
          // Replaced alert() with UI message
          const moveContainer = document.getElementById("move-timer-container");
          moveContainer.innerHTML = 'CHECKMATE! <span style="color:red;">You Lose!</span>';
          playSound('checkmate');
          console.log('About to call celebrateCheckmate(false)');
          try {
            celebrateCheckmate(false);
            console.log('celebrateCheckmate call completed');
          } catch (err) {
            console.error('Error in celebrateCheckmate:', err);
          }
          gameOver = true;
          clearPremove();
          
          // Update statistics and achievements
          playerStats.losses++;
          savePlayerStats();
          updatePlayerStatsDisplay();
          checkAchievements();
          
          // Show rematch modal
          setTimeout(() => showRematchModal("ðŸ’” Defeat", "You were checkmated! Play again?"), 2000);
          return;
        }
        
        // Check if there are premoves and execute the first one if legal
        console.log('Checking for premoves...', premoves);
        if (premoves.length > 0) {
          const firstPremove = premoves[0];
          console.log('Attempting to execute first premove:', firstPremove);
          
          const premoveAttempt = game.move({ from: firstPremove.from, to: firstPremove.to, promotion: 'q' });
          console.log('Premove attempt result:', premoveAttempt);
          
          if (premoveAttempt) {
            // Premove is legal - it's been executed, remove it from the array
            console.log('Premove was legal and executed!');
            premoves.shift(); // Remove the executed premove
            
            const from = premoveAttempt.from;
            const to = premoveAttempt.to;
            
            trackCapturedPiece(premoveAttempt);
            lastMoveSquares = { from, to };
            
            const premoveMoveTimeMs = 0; // Instant premove
            updateLastMove(premoveAttempt.san, "00:00.00", game.turn() === "w" ? "black" : "white", game.history().length/2 + 0.5);
            board.position(game.fen());
            
            // Remove red highlights for this executed premove
            $("#board .square-55d63").removeClass("premove-highlight premove-source");
            
            // Update visual to show remaining premoves if any
            if (premoves.length > 0) {
              updatePremoveVisual();
            }
            
            // Highlight with normal last-move highlight (not red premove highlight)
            highlightLastMove(from, to);
            highlightCheck();
            updateTurnDisplay();
            updateOpeningDisplay();
            updateGameStats();
            
            if (game.in_checkmate()) {
              const moveContainer = document.getElementById("move-timer-container");
              moveContainer.innerHTML = 'CHECKMATE! <span style="color:#2ECC71;">You Win!</span>';
              playSound('checkmate');
              celebrateCheckmate(true);
              gameOver = true;
              clearPremove();
              
              // Update statistics and achievements
              playerStats.wins++;
              savePlayerStats();
              updatePlayerStatsDisplay();
              checkAchievements();
              
              // Show rematch modal
              setTimeout(() => showRematchModal("ðŸŽ‰ Victory!", "Congratulations! You won! Play again?"), 2000);
              return;
            }
            
            // After executing premove, get engine response
            // The next premove in the chain will be executed after the engine moves
            console.log('Premove executed, now getting engine response...', premoves.length, 'premoves remaining');
            startTimer();
            await engineMove();
            return;
          } else {
            // First premove is no longer legal - clear all premoves and restore board position
            console.log('First premove was not legal, clearing all premoves');
            clearPremove();
          }
        }

        startTimer(); // Start move timer for player
      } catch (err) {
        // Replaced alert() with UI message
        const moveContainer = document.getElementById("move-timer-container");
        moveContainer.innerHTML = `CONNECTION ERROR: <span style="color:red;">${err.message || 'Could not reach engine.'}</span>`;
        console.error('Engine connection error:', err);
        gameOver = true;
        
        // Show rematch modal for connection errors
        setTimeout(() => showRematchModal("âš ï¸ Connection Error", "Lost connection to engine. Try again?"), 2000);
      }
    }
    function submitMove() {
      if (gameOver) return;
      
      const moveInput = document.getElementById("move-input");
      const moveStr = moveInput.value.trim();
      
      if (!moveStr) {
        moveInput.style.borderColor = "red";
        setTimeout(() => { moveInput.style.borderColor = "#3498db"; }, 500);
        return;
      }
      
      removeHighlights();
      const move = game.move(moveStr, { sloppy: true });
      
      if (!move) {
        moveInput.style.borderColor = "red";
        setTimeout(() => { moveInput.style.borderColor = "#3498db"; }, 500);
        return;
      }
      
      moveInput.value = "";
      moveInput.style.borderColor = "#3498db";
      
      trackCapturedPiece(move);
      lastMoveSquares = { from: move.from, to: move.to };
      
      const prevTurn = game.turn() === "w" ? "b" : "w";
      const moveTimeMs = stopTimerAndUpdateTotal(prevTurn);
      updateLastMove(move.san, formatTime(moveTimeMs), game.turn() === "w" ? "black" : "white", game.history().length/2 + 0.5);
      
      if (!blindfoldMode) {
        board.position(game.fen());
        highlightLastMove(move.from, move.to);
        highlightCheck();
      }
      
      updateTurnDisplay();
      updateOpeningDisplay();
      updateGameStats();

      if (game.in_checkmate()) {
        const moveContainer = document.getElementById("move-timer-container");
        moveContainer.innerHTML = 'CHECKMATE! <span style="color:#2ECC71;">You Win!</span>';
        playSound('checkmate');
        celebrateCheckmate(true);
        gameOver = true;
        
        // Update statistics and achievements
        playerStats.wins++;
        savePlayerStats();
        updatePlayerStatsDisplay();
        checkAchievements();
        
        // Show rematch modal
        setTimeout(() => showRematchModal("ðŸŽ‰ Victory!", "Congratulations! You won! Play again?"), 2000);
        return;
      }

      startTimer();
      engineMove();
    }  </script>
  <div class="push"></div>
    </div>
  <footer>
        <p>&copy; 2025 Ahrens Labs. All rights reserved.</p>
    </footer>
</body>
</html>