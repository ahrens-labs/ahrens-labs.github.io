<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Chess Game against TrifangX</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Orbitron&family=Roboto+Mono&display=swap" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">
    <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <link rel="stylesheet" href="css/style.css">
    <script src="js/script.js"></script>

  <style>
    /* Chess Engine Page - Enhanced Clean Theme */
    body {
      background: linear-gradient(135deg, #f0f4f8 0%, #e8f2f7 50%, #f0f4f8 100%);
      background-attachment: fixed;
      color: #333;
      min-height: 100vh;
      overflow-x: hidden;
      position: relative;
    }

    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: 
          radial-gradient(circle at 20% 80%, rgba(52, 152, 219, 0.03) 0%, transparent 50%),
          radial-gradient(circle at 80% 20%, rgba(46, 204, 113, 0.02) 0%, transparent 50%);
      background-size: 600px 600px;
      animation: subtleFloat 15s ease-in-out infinite;
      pointer-events: none;
      z-index: -1;
    }

    /* Main content container */
    main {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      max-width: 1200px;
      margin: 0 auto;
    }

    /* Main Title Styling */
    h2 {
      text-align: center;
      font-family: "Inter", sans-serif;
      font-size: 2.5rem;
      font-weight: 700;
      margin-bottom: 2rem;
      color: #2c3e50;
      margin-top: 1rem;
      position: relative;
    }

    h2::after {
      content: '';
      position: absolute;
      bottom: -10px;
      left: 50%;
      transform: translateX(-50%);
      width: 100px;
      height: 3px;
      background: linear-gradient(90deg, #3498db, #2ecc71);
      border-radius: 2px;
    }

    .sharp {
      background: linear-gradient(135deg, #3498db, #2ecc71);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      font-weight: 800;
      animation: shimmer 3s ease-in-out infinite;
    }

    /* Game Controls Container */
    #choose-side {
      background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
      padding: 30px;
      border-radius: 20px;
      box-shadow: 
          0 10px 30px rgba(0, 0, 0, 0.1),
          0 1px 8px rgba(0, 0, 0, 0.1),
          inset 0 1px 0 rgba(255, 255, 255, 0.8);
      max-width: 800px;
      margin: 0 auto 30px auto;
      display: flex;
      flex-direction: column;
      gap: 20px;
      align-items: center;
      text-align: center;
      border: 1px solid rgba(52, 152, 219, 0.1);
      position: relative;
      overflow: hidden;
    }

    #choose-side::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, #3498db, #2ecc71, #3498db);
      background-size: 200% 100%;
      animation: shimmer 3s ease-in-out infinite;
    }

    /* Individual control rows */
    .control-row {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      width: 100%;
      flex-wrap: wrap;
    }

    /* Keep label and select together on same line */
    .control-row label:not([for="blindfold-mode"]):not([for="show-history"]) {
      white-space: nowrap;
    }

    .control-row > label,
    .control-row > select {
      flex-shrink: 0;
    }

    /* Less prominent style options */
    .control-row.style-option {
      font-size: 0.9em;
      opacity: 0.8;
    }

    .control-row.style-option label {
      font-size: 0.95em;
      font-weight: 500;
      color: #5a6c7d;
    }

    .control-row.style-option select {
      font-size: 0.9em;
      min-width: 130px;
      padding: 10px 16px;
    }

    /* Labels */
    label {
      font-family: "Inter", sans-serif;
      color: #2c3e50;
      font-weight: 600;
      margin-right: 10px;
      font-size: 1.1em;
    }

    /* Select Dropdowns */
    select {
      background-color: white;
      color: #333;
      border: 2px solid #3498db;
      border-radius: 20px;
      padding: 12px 18px;
      font-family: "Inter", sans-serif;
      font-size: 1em;
      margin: 0;
      transition: all 0.3s ease;
      box-shadow: 0 2px 8px rgba(52, 152, 219, 0.1);
      min-width: 140px;
      max-width: 160px;
      cursor: pointer;
    }

    /* Engine personality selector - make it stand out */
    #engine-style {
      border: 3px solid #6c757d;
      background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
      font-weight: 600;
      min-width: 180px;
      box-shadow: 0 3px 10px rgba(108, 117, 125, 0.15);
      position: relative;
      transition: all 0.4s ease;
    }

    /* Personality color classes */
    #engine-style.personality-balanced {
      border-color: #6c757d;
      box-shadow: 0 3px 10px rgba(108, 117, 125, 0.3), 0 0 15px rgba(108, 117, 125, 0.2);
      background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
    }

    #engine-style.personality-aggressive {
      border-color: #e74c3c;
      box-shadow: 0 3px 12px rgba(231, 76, 60, 0.4), 0 0 20px rgba(231, 76, 60, 0.3);
      background: linear-gradient(145deg, #ffffff 0%, #fff5f5 100%);
    }

    #engine-style.personality-defensive {
      border-color: #3498db;
      box-shadow: 0 3px 12px rgba(52, 152, 219, 0.4), 0 0 20px rgba(52, 152, 219, 0.3);
      background: linear-gradient(145deg, #ffffff 0%, #f0f8ff 100%);
    }

    #engine-style.personality-positional {
      border-color: #9b59b6;
      box-shadow: 0 3px 12px rgba(155, 89, 182, 0.4), 0 0 20px rgba(155, 89, 182, 0.3);
      background: linear-gradient(145deg, #ffffff 0%, #f8f0ff 100%);
    }

    #engine-style.personality-material {
      border-color: #f39c12;
      box-shadow: 0 3px 12px rgba(243, 156, 18, 0.4), 0 0 20px rgba(243, 156, 18, 0.3);
      background: linear-gradient(145deg, #ffffff 0%, #fffaf0 100%);
    }

    #engine-style.personality-tactical {
      border-color: #1abc9c;
      box-shadow: 0 3px 12px rgba(26, 188, 156, 0.4), 0 0 20px rgba(26, 188, 156, 0.3);
      background: linear-gradient(145deg, #ffffff 0%, #f0fff8 100%);
    }

    #engine-style:hover {
      transform: translateY(-2px) scale(1.02);
      filter: brightness(1.05);
    }

    #engine-style:focus {
      outline: none;
      transform: scale(1.03);
    }

    /* Custom personality class */
    #engine-style.personality-custom {
      border-color: #34495e;
      box-shadow: 0 3px 12px rgba(52, 73, 94, 0.4), 0 0 20px rgba(52, 73, 94, 0.3);
      background: linear-gradient(145deg, #ffffff 0%, #f5f6fa 100%);
    }

    /* Custom modifiers panel */
    #custom-modifiers-panel {
      background: linear-gradient(145deg, #f8f9fa 0%, #ffffff 100%);
      border: 2px solid #34495e;
      border-radius: 15px;
      padding: 20px;
      margin: 15px 0;
      box-shadow: 0 4px 15px rgba(52, 73, 94, 0.15);
      animation: slideDown 0.3s ease;
    }

    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .modifier-input-group {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .modifier-input-group label {
      flex: 1;
      font-size: 0.95em;
      font-weight: 500;
      color: #2c3e50;
      text-align: left;
    }

    .modifier-input-group input[type="number"] {
      width: 80px;
      padding: 8px 12px;
      border: 2px solid #34495e;
      border-radius: 10px;
      font-family: "Roboto Mono", monospace;
      font-size: 0.95em;
      text-align: center;
      transition: all 0.3s ease;
      background: white;
    }

    .modifier-input-group input[type="number"]:hover {
      border-color: #5d6d7e;
      box-shadow: 0 2px 8px rgba(52, 73, 94, 0.2);
    }

    .modifier-input-group input[type="number"]:focus {
      outline: none;
      border-color: #3498db;
      box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.15);
    }

    /* Option elements styling */
    select option {
      background: white;
      color: #333;
      font-family: "Inter", sans-serif;
      padding: 8px;
    }

    select:hover {
      border-color: #2980b9;
      box-shadow: 0 4px 12px rgba(52, 152, 219, 0.2);
      transform: translateY(-1px);
    }

    select:focus {
      outline: none;
      border-color: #3498db;
      box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
    }

    /* Start Game Button */
    button {
      width: 100%;
      padding: 15px 20px;
      font-size: 1.1em;
      background-color: #3498db;
      color: white;
      border: none;
      border-radius: 20px;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      font-family: "Inter", sans-serif;
      font-weight: 600;
      box-shadow: 0 4px 12px rgba(52, 152, 219, 0.2);
      margin: 10px 0;
      max-width: 200px;
    }

    button:hover {
      background-color: #2980b9;
      transform: translateY(-2px) scale(1.02);
      box-shadow: 0 6px 16px rgba(52, 152, 219, 0.3);
    }

    button:active {
      transform: translateY(0) scale(1);
      box-shadow: 0 2px 8px rgba(52, 152, 219, 0.2);
    }

    /* Chess Board Container */
    #board-timers-container {
      display: flex !important;
      flex-direction: row;
      align-items: center;
      gap: 20px;
      min-height: 500px;
    }

    /* Chess Board Styling */
    #board {
      width: 450px;
      height: 450px;
      border-radius: 15px;
      box-shadow: 
          0 15px 35px rgba(0, 0, 0, 0.15),
          0 5px 15px rgba(0, 0, 0, 0.1);
      border: 3px solid #e9ecef;
      overflow: hidden;
      position: relative;
      background-color: white;
      transition: all 0.3s ease;
    }

    #board:hover {
      transform: translateY(-2px);
      box-shadow: 
          0 20px 40px rgba(0, 0, 0, 0.2),
          0 8px 20px rgba(0, 0, 0, 0.1);
    }

    /* Board Color Themes */
    .board-theme-classic .white-1e1d7 { background-color: #f0d9b5 !important; }
    .board-theme-classic .black-3c85d { background-color: #b58863 !important; }

    .board-theme-blue .white-1e1d7 { background-color: #dee3e6 !important; }
    .board-theme-blue .black-3c85d { background-color: #8ca2ad !important; }

    .board-theme-green .white-1e1d7 { background-color: #ffffdd !important; }
    .board-theme-green .black-3c85d { background-color: #86a666 !important; }

    .board-theme-gray .white-1e1d7 { background-color: #e8e8e8 !important; }
    .board-theme-gray .black-3c85d { background-color: #999999 !important; }

    .board-theme-purple .white-1e1d7 { background-color: #e8d4f2 !important; }
    .board-theme-purple .black-3c85d { background-color: #9b6db5 !important; }

    .board-theme-wood .white-1e1d7 { background-color: #f4dec4 !important; }
    .board-theme-wood .black-3c85d { background-color: #8b5a2b !important; }

    .board-theme-coral .white-1e1d7 { background-color: #ffebcd !important; }
    .board-theme-coral .black-3c85d { background-color: #cd853f !important; }

    /* Legal Move Highlights */
    .highlight-legal {
      position: relative;
    }
    .highlight-legal::after {
      content: "";
      position: absolute;
      top: 50%;
      left: 50%;
      width: 20px;
      height: 20px;
      background: radial-gradient(circle, #3498db, transparent);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 10;
      animation: legalMovePulse 1.5s ease-in-out infinite;
    }

    /* Hide default drag-over border */
    #board .square-55d63 {
      box-shadow: none !important;
    }

    /* Enable pointer events for dragging */
    #board img {
      pointer-events: auto !important;
      cursor: grab;
      user-select: none;
      -webkit-user-drag: none;
      -khtml-user-drag: none;
      -moz-user-drag: none;
      -o-user-drag: none;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
    }
    
    #board img[draggable] {
      -webkit-user-drag: none !important;
    }

    #board img:active {
      cursor: grabbing;
    }

    /* Only show yellow border on legal move targets during drag */
    .legal-target {
      box-shadow: inset 0 0 0 3px rgba(255, 235, 59, 0.8) !important;
    }

    @keyframes legalMovePulse {
      0%, 100% { 
        opacity: 0.6; 
        transform: translate(-50%, -50%) scale(1);
      }
      50% { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1.2);
      }
    }

    /* Timers Container */
    #timers-container {
      font-family: "Inter", sans-serif;
      color: #333;
      display: none;
      flex-direction: column;
      justify-content: center;
      gap: 15px;
      user-select: none;
      background-color: white;
      border-radius: 15px;
      padding: 25px;
      border: 1px solid #e9ecef;
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.1);
      min-width: 250px;
      min-height: 150px;
      visibility: visible !important;
    }

    #timers-container div {
      font-size: 1.2em;
      font-weight: 600;
      padding: 15px;
      background-color: #f8f9fa;
      border-radius: 10px;
      border-left: 4px solid #3498db;
      transition: all 0.3s ease;
    }
    
    .time-slot {
      display: block !important;
      visibility: visible !important;
    }

    #timers-container div:hover {
      background-color: #e9ecef;
      transform: translateX(3px);
    }

    /* Move Timer */
    #move-timer-container {
      text-align: center;
      margin: 20px auto;
      font-family: "Inter", sans-serif;
      font-size: 1.3em;
      font-weight: 600;
      user-select: none;
      color: #2c3e50;
      background-color: white;
      border-radius: 15px;
      padding: 20px;
      border: 1px solid #e9ecef;
      max-width: 300px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    /* Last Move Container */
    #last-move-container {
      text-align: center;
      margin: 20px auto;
      font-family: "Inter", sans-serif;
      font-size: 1.2em;
      font-weight: 600;
      color: #2c3e50;
      user-select: none;
      background-color: white;
      border-radius: 15px;
      padding: 20px;
      border: 1px solid #e9ecef;
      max-width: 500px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    #turn-color {
      color: #3498db;
      font-weight: 700;
    }

    #last-move {
      color: #e74c3c;
      font-weight: 700;
    }

    /* Game Statistics Panel */
    #game-stats-panel {
      background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
      padding: 15px;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
      margin: 15px auto;
      max-width: 600px;
      border: 1px solid rgba(52, 152, 219, 0.1);
      font-family: 'Inter', sans-serif;
      display: none;
    }

    #game-stats-panel h3 {
      text-align: center;
      font-size: 1.05rem;
      font-weight: 600;
      color: #2c3e50;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 2px solid #e9ecef;
    }

    .stats-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 10px;
      margin-bottom: 6px;
      background: white;
      border-radius: 6px;
      border-left: 2px solid #3498db;
    }

    .stats-label {
      font-weight: 600;
      color: #2c3e50;
      font-size: 0.9em;
    }

    .stats-value {
      font-weight: 500;
      color: #7f8c8d;
      font-size: 0.9em;
    }

    .captured-pieces {
      display: flex;
      gap: 5px;
      align-items: center;
      flex-wrap: wrap;
    }

    .captured-piece {
      width: 30px;
      height: 30px;
      display: inline-block;
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
    }

    /* Main game container with vertical layout */
    #game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
      margin: 20px auto;
      max-width: 1400px;
    }

    #board-row {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 25px;
    }

    /* Captured pieces beside board */
    #board-with-captures {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 20px;
    }

    #captured-pieces-left {
      display: flex;
      flex-direction: column;
      gap: 30px;
      min-width: 80px;
    }

    #right-panel {
      display: flex;
      flex-direction: column;
      gap: 15px;
      min-width: 350px;
      max-width: 400px;
    }

    #right-panel > div,
    #right-panel > button {
      margin: 0;
    }

    #game-buttons {
      display: flex;
      gap: 10px;
      justify-content: center;
    }

    #game-buttons button {
      flex: 1;
      min-width: 0;
    }
    
    #board-timers-container {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 20px;
    }

    .captured-section {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
      background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
      border-radius: 10px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
    }

    .captured-section-title {
      font-family: 'Inter', sans-serif;
      font-size: 0.75em;
      font-weight: 600;
      color: #7f8c8d;
      margin-bottom: 8px;
      text-align: center;
    }

    .captured-pieces-display {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      max-width: 70px;
      justify-content: center;
    }

    .material-advantage {
      font-weight: 700;
      font-size: 1.1em;
    }

    .material-advantage.positive {
      color: #2ecc71;
    }

    .material-advantage.negative {
      color: #e74c3c;
    }

    #right-panel {
      display: flex;
      flex-direction: column;
      gap: 15px;
      min-width: 350px;
      max-width: 400px;
    }

    #right-panel > div,
    #right-panel > button {
      margin: 0;
    }

    .material-advantage.equal {
      color: #7f8c8d;
    }

    /* Opening Book Display */
    #opening-display {
      background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
      padding: 12px 15px;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
      margin: 15px auto;
      max-width: 600px;
      text-align: center;
      border: 1px solid rgba(52, 152, 219, 0.1);
      display: none;
    }

    #opening-display .opening-label {
      font-family: 'Inter', sans-serif;
      font-size: 0.8em;
      font-weight: 500;
      color: #7f8c8d;
      margin-bottom: 4px;
    }

    #opening-display .opening-name {
      font-family: 'Inter', sans-serif;
      font-size: 1.1em;
      font-weight: 700;
      color: #3498db;
    }

    /* Export PGN Button */
    #export-pgn-btn {
      background-color: #2ecc71;
      color: white;
      padding: 12px 24px;
      border: none;
      border-radius: 20px;
      cursor: pointer;
      font-family: 'Inter', sans-serif;
      font-weight: 600;
      font-size: 1em;
      box-shadow: 0 4px 12px rgba(46, 204, 113, 0.2);
      transition: all 0.3s ease;
      margin: 10px auto;
      display: none;
    }

    #export-pgn-btn:hover {
      background-color: #27ae60;
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(46, 204, 113, 0.3);
    }
    
    /* Resign Button */
    #resign-btn {
      background-color: #e74c3c;
      color: white;
      padding: 12px 24px;
      border: none;
      border-radius: 20px;
      cursor: pointer;
      font-family: 'Inter', sans-serif;
      font-weight: 600;
      font-size: 1em;
      box-shadow: 0 4px 12px rgba(231, 76, 60, 0.2);
      transition: all 0.3s ease;
      margin: 10px auto;
      display: none;
    }

    #resign-btn:hover {
      background-color: #c0392b;
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(231, 76, 60, 0.3);
    }

    /* Board square highlighting */
    .highlight-last-move {
      background-color: rgba(255, 235, 59, 0.4) !important;
    }

    .highlight-check {
      background-color: rgba(231, 76, 60, 0.5) !important;
      animation: checkPulse 1s ease-in-out infinite;
    }

    @keyframes checkPulse {
      0%, 100% { 
        background-color: rgba(231, 76, 60, 0.5) !important;
      }
      50% { 
        background-color: rgba(231, 76, 60, 0.7) !important;
      }
    }

    /* Illegal move animation */
    @keyframes illegalMoveBlink {
      0%, 100% { 
        background-color: transparent;
        box-shadow: none;
      }
      50% {
        background-color: rgba(231, 76, 60, 0.4) !important;
        box-shadow: inset 0 0 10px rgba(231, 76, 60, 0.5) !important;
      }
    }

    .square-55d63.illegal-move {
      animation: illegalMoveBlink 0.4s ease-in-out !important;
    }

    /* Premove highlighting */
    .square-55d63.premove-highlight {
      background-color: rgba(231, 76, 60, 0.6) !important;
      box-shadow: inset 0 0 0 4px rgba(231, 76, 60, 0.9) !important;
    }
    
    div.premove-highlight {
      background-color: rgba(231, 76, 60, 0.6) !important;
      box-shadow: inset 0 0 0 4px rgba(231, 76, 60, 0.9) !important;
    }
    
    /* Premove source highlighting (lighter) */
    .square-55d63.premove-source {
      background-color: rgba(231, 76, 60, 0.3) !important;
      box-shadow: inset 0 0 0 4px rgba(231, 76, 60, 0.5) !important;
    }
    
    div.premove-source {
      background-color: rgba(231, 76, 60, 0.3) !important;
      box-shadow: inset 0 0 0 4px rgba(231, 76, 60, 0.5) !important;
    }

    /* Custom Confirmation Modal */
    #confirm-modal {
      display: none;
      position: absolute;
      z-index: 10000;
      animation: popIn 0.2s ease-out;
    }

    #confirm-modal.show {
      display: block;
    }

    .confirm-dialog {
      background: white;
      border-radius: 12px;
      padding: 20px 25px;
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.25), 0 0 0 1px rgba(0, 0, 0, 0.05);
      min-width: 280px;
      max-width: 320px;
      position: relative;
      border: 2px solid #e74c3c;
    }

    .confirm-dialog::after {
      content: '';
      position: absolute;
      bottom: -10px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 10px solid transparent;
      border-right: 10px solid transparent;
      border-top: 10px solid #e74c3c;
    }

    .confirm-dialog::before {
      content: '';
      position: absolute;
      bottom: -8px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 9px solid transparent;
      border-right: 9px solid transparent;
      border-top: 9px solid white;
      z-index: 1;
    }

    .confirm-dialog h3 {
      margin: 0 0 10px 0;
      color: #e74c3c;
      font-family: 'Inter', sans-serif;
      font-size: 1.1em;
      font-weight: 600;
    }

    .confirm-dialog p {
      margin: 0 0 15px 0;
      color: #555;
      font-family: 'Inter', sans-serif;
      font-size: 0.95em;
      line-height: 1.4;
    }

    .confirm-buttons {
      display: flex;
      gap: 10px;
      justify-content: stretch;
    }

    .confirm-buttons button {
      flex: 1;
      padding: 8px 16px;
      border: none;
      border-radius: 8px;
      font-family: 'Inter', sans-serif;
      font-size: 0.9em;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .confirm-buttons .confirm-yes {
      background: linear-gradient(135deg, #e74c3c, #c0392b);
      color: white;
    }

    .confirm-buttons .confirm-yes:hover {
      transform: translateY(-1px);
      box-shadow: 0 3px 8px rgba(231, 76, 60, 0.4);
    }

    .confirm-buttons .confirm-no {
      background: linear-gradient(135deg, #ecf0f1, #bdc3c7);
      color: #555;
    }

    .confirm-buttons .confirm-no:hover {
      transform: translateY(-1px);
      box-shadow: 0 3px 8px rgba(189, 195, 199, 0.4);
    }

    @keyframes popIn {
      from { 
        opacity: 0;
        transform: translateY(10px) scale(0.95);
      }
      to { 
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    /* Move History/Notation Container */
    #notation-container {
      background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
      padding: 15px;
      border-radius: 15px;
      box-shadow: 
          0 4px 15px rgba(0, 0, 0, 0.08),
          inset 0 1px 0 rgba(255, 255, 255, 0.8);
      border: 1px solid rgba(52, 152, 219, 0.1);
      font-family: 'Roboto Mono', monospace;
      font-size: 0.9rem;
      line-height: 1.6;
      max-height: 350px;
      overflow-y: auto;
      display: none;
      color: #34495e;
    }

    #notation-container::before {
      content: 'Move History';
      display: block;
      font-family: 'Inter', sans-serif;
      font-size: 1.2rem;
      font-weight: 600;
      color: #2c3e50;
      text-align: center;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 2px solid #e9ecef;
    }

    .move-pair {
      margin-bottom: 8px;
      padding: 8px 12px;
      background: white;
      border-radius: 8px;
      transition: all 0.2s ease;
    }

    .move-pair:hover {
      background: #f8f9fa;
      transform: translateX(3px);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    }

    .move-number {
      color: #7f8c8d;
      margin-right: -10px;
      font-weight: 600;
      min-width: 30px;
      display: inline-block;
    }

    .white-move {
      color: #2c3e50;
      margin-right: -10px;
      font-weight: 600;
      padding: 4px 8px;
      background: rgba(52, 152, 219, 0.08);
      border-radius: 4px;
      border-left: 3px solid #3498db;
    }

    .move-item {
      cursor: pointer;
      padding: 3px 3px;
      margin: 0;
      border-radius: 4px;
      transition: all 0.2s ease;
      display: inline-block;
    }

    .move-item:hover {
      background: rgba(52, 152, 219, 0.2);
    }

    .move-item.highlighted {
      background: #3498db;
      color: white;
      font-weight: 700;
      box-shadow: 0 2px 6px rgba(52, 152, 219, 0.4);
    }

    .black-move {
      color: #34495e;
      font-weight: 500;
      padding: 4px 8px;
      background: rgba(44, 62, 80, 0.05);
      border-radius: 4px;
      border-left: 3px solid #2c3e50;
    }

    /* Hidden State */
    #timers-container,
    #move-timer-container,
    #last-move-container,
    #notation-container {
      display: none;
    }

    /* Blindfold Mode */
    .blindfold-hidden {
      display: none !important;
    }

    #move-input-container {
      text-align: center;
      margin: 20px auto;
      padding: 20px;
      background-color: white;
      border-radius: 15px;
      border: 1px solid #e9ecef;
      max-width: 600px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    #show-history-row {
      display: none;
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      main {
        padding: 15px;
      }
      
      #board-timers-container {
        flex-direction: column;
        gap: 20px;
      }
      
      #board {
        width: 350px;
        height: 350px;
      }
      
      h2 {
        font-size: 2rem;
      }
      
      #choose-side {
        padding: 20px;
        margin: 0 10px 20px 10px;
      }
      
      .control-row {
        flex-direction: column;
        gap: 10px;
        text-align: center;
      }
      
      select, button {
        width: 200px;
        max-width: 90%;
      }
      
      #timers-container {
        min-width: 200px;
      }
    }
  </style>
</head>
<body>
    <div class="wrapper">
        <header>
            <div class="header-content">
                <a href="index.html" class="logo-link">
                    <img src="img/EagleLogo.png" alt="Ahrens Labs logo" class="header-logo">
                </a>
                <h1>Ahrens Labs</h1>
                <nav>
                    <ul>
                        <li><a href="index.html">Home</a></li>
                        <li><a href="labs.html">Labs & Projects</a></li>
                        <li><a href="contact.html">Contact</a></li>
                        <li><a href="chess_engine.html" class="active">Chess Engine</a></li>
                    </ul>
                </nav>
            </div>
        </header>
	    
	<h2>
    Play Chess against Trifang<span class="sharp">X</span>
    </h2>
  <div id="choose-side">
    <div class="control-row">
      <label for="color-select">Choose your side: </label>
      <select id="color-select">
        <option value="random">Random</option>
        <option value="white">White</option>
        <option value="black">Black</option>
      </select>
      
      <label for="time-control" style="margin-left: 15px;">Time control: </label>
      <select id="time-control">
        <option value="none">None</option>
        <option value="60">1 min</option>
        <option value="180|2">3 | 2</option>egal 
        <option value="300|0">5 min</option>
        <option value="600|0">10 min</option>
        <option value="900|5">15 | 5</option>
        <option value="3600|0">60 min</option>
      </select>
    </div>
    
    <div class="control-row style-option">
      <label for="board-style">Board Style: </label>
      <select id="board-style" onchange="changeBoardStyle()">
        <option value="classic">Classic</option>
        <option value="blue">Blue</option>
        <option value="green">Green</option>
        <option value="gray">Gray</option>
        <option value="purple">Purple</option>
        <option value="wood">Wood</option>
        <option value="coral">Coral</option>
      </select>
      
      <label for="piece-style" style="margin-left: 20px;">Piece Style: </label>
      <select id="piece-style" onchange="changePieceStyle()">
        <option value="wikipedia">Wikipedia</option>
        <option value="alpha">Alpha</option>
        <option value="cburnett">CBurnett</option>
        <option value="merida">Merida</option>
        <option value="pirouetti">Pirouetti</option>
        <option value="spatial">Spatial</option>
      </select>
    </div>
    
    <div class="control-row">
      <label for="engine-style">Engine Personality:</label>
      <select id="engine-style" onchange="changeEngineStyle()">
        <option value="balanced">‚öñÔ∏è Balanced</option>
        <option value="aggressive">‚öîÔ∏è Aggressive</option>
        <option value="defensive">üõ°Ô∏è Defensive</option>
        <option value="positional">üéØ Positional</option>
        <option value="material">üíé Material-Focused</option>
        <option value="tactical">‚ö° Tactical</option>
        <option value="custom">üéõÔ∏è Custom</option>
      </select>
    </div>
    
    <!-- Custom modifiers panel -->
    <div id="custom-modifiers-panel" style="display: none;">
      <div style="text-align: center; margin-bottom: 15px; font-weight: 600; color: #2c3e50;">
        Customize Engine Modifiers (0.0 - 3.0)
      </div>
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; max-width: 600px; margin: 0 auto;">
        <div class="modifier-input-group">
          <label for="mod-material">Material:</label>
          <input type="number" id="mod-material" min="0" max="3" step="0.1" value="1.0" onchange="updateCustomModifiers()">
        </div>
        <div class="modifier-input-group">
          <label for="mod-king-safety">King Safety:</label>
          <input type="number" id="mod-king-safety" min="0" max="3" step="0.1" value="1.0" onchange="updateCustomModifiers()">
        </div>
        <div class="modifier-input-group">
          <label for="mod-centralization">Centralization:</label>
          <input type="number" id="mod-centralization" min="0" max="3" step="0.1" value="1.0" onchange="updateCustomModifiers()">
        </div>
        <div class="modifier-input-group">
          <label for="mod-attack">Attack:</label>
          <input type="number" id="mod-attack" min="0" max="3" step="0.1" value="1.0" onchange="updateCustomModifiers()">
        </div>
        <div class="modifier-input-group">
          <label for="mod-piece-activity">Piece Activity:</label>
          <input type="number" id="mod-piece-activity" min="0" max="3" step="0.1" value="1.0" onchange="updateCustomModifiers()">
        </div>
        <div class="modifier-input-group">
          <label for="mod-defense">Defense:</label>
          <input type="number" id="mod-defense" min="0" max="3" step="0.1" value="1.0" onchange="updateCustomModifiers()">
        </div>
        <div class="modifier-input-group">
          <label for="mod-pawn-structure">Pawn Structure:</label>
          <input type="number" id="mod-pawn-structure" min="0" max="3" step="0.1" value="1.0" onchange="updateCustomModifiers()">
        </div>
        <div style="grid-column: 1 / -1; text-align: center; margin-top: 5px;">
          <button onclick="resetCustomModifiers()" style="padding: 8px 20px; font-size: 0.9em; background: linear-gradient(135deg, #95a5a6, #7f8c8d); border: none; border-radius: 15px; color: white; cursor: pointer; font-weight: 600;">
            Reset to 1.0
          </button>
        </div>
      </div>
    </div>
    
    <div class="control-row">
      <label for="blindfold-mode">
        <input type="checkbox" id="blindfold-mode" onchange="toggleHistoryOption()" style="margin-right: 8px;">
        Blindfold Mode
      </label>
    
      <label for="show-history" id="show-history-row" style="margin-left: 20px; display: none;">
        <input type="checkbox" id="show-history" style="margin-right: 8px;">
        Show Move History in Blindfold
      </label>
    </div>
    
    <div class="control-row">
      <button onclick="startGame()">Start Game</button>
    </div>
  </div>

  <div id="game-container">
    <div id="move-timer-container">
      Time for this move: <span id="timer">00:00.00</span>
    </div>

    <div id="board-row">
      <div id="board-with-captures">
        <div id="captured-pieces-left">
          <div class="captured-section" id="black-captured-section">
            <div class="captured-section-title">Black Pieces</div>
            <div class="captured-pieces-display" id="black-captures-display"></div>
          </div>
          <div class="captured-section" id="white-captured-section">
            <div class="captured-section-title">White Pieces</div>
            <div class="captured-pieces-display" id="white-captures-display"></div>
          </div>
        </div>

        <div id="board-timers-container">
          <div id="board"></div>

          <div id="timers-container">
              <!-- The divs here will be reordered by JavaScript in startGame() based on playerColor. -->
              <!-- They now have IDs for easier manipulation -->
            <div id="time-slot-white" class="time-slot">
              White Time Left: <span id="white-total">--:--.--</span>
            </div>
            <div id="time-slot-black" class="time-slot">
              Black Time Left: <span id="black-total">--:--.--</span>
            </div>
          </div>
        </div>
      </div>

      <div id="right-panel">
        <div id="opening-display">
          <div class="opening-label">Opening:</div>
          <div class="opening-name" id="opening-name">-</div>
        </div>

      <div id="game-stats-panel">
        <h3>Game Statistics</h3>
        <div class="stats-row">
          <span class="stats-label">Material Balance:</span>
          <span class="stats-value material-advantage" id="material-balance">Equal</span>
        </div>
        <div class="stats-row">
          <span class="stats-label">Total Moves:</span>
          <span class="stats-value" id="total-moves">0</span>
        </div>
      </div>

      <div id="notation-container"></div>

      <div id="game-buttons">
        <button id="export-pgn-btn" onclick="exportPGN()">Export Game (PGN)</button>
        <button id="resign-btn" onclick="resignGame()" style="display: none;">Resign</button>
      </div>
    </div>
  </div>

  <div id="last-move-container">
    Turn: <span id="turn-color">White</span> | Last Move: <span id="last-move">None</span>
  </div>

  <!-- Custom Confirmation Modal -->
  <div id="confirm-modal">
    <div class="confirm-dialog">
      <h3>‚ö†Ô∏è Resign Game?</h3>
      <p>Are you sure you want to resign? This cannot be undone.</p>
      <div class="confirm-buttons">
        <button class="confirm-no" onclick="closeConfirmModal()">Cancel</button>
        <button class="confirm-yes" onclick="confirmResign()">Resign</button>
      </div>
    </div>
  </div>

  <div id="move-input-container" style="display: none;">
    <input type="text" id="move-input" placeholder="Enter move (e.g., e4, Nf3, O-O)" 
           onkeypress="if(event.key === 'Enter') submitMove()"
           style="padding: 12px 18px; font-size: 1.1em; border: 2px solid #3498db; 
                  border-radius: 20px; margin-right: 10px; font-family: 'Inter', sans-serif;
                  box-shadow: 0 2px 8px rgba(52, 152, 219, 0.1);">
    <button onclick="submitMove()" 
            style="padding: 12px 24px; font-size: 1.1em; background-color: #3498db; 
                   color: white; border: none; border-radius: 20px; cursor: pointer;
                   font-family: 'Inter', sans-serif; font-weight: 600; max-width: none;">
      Submit Move
    </button>
  </div>

  <script>
    let game, board;
    let playerColor = "white";
    let timerStart = 0;
    let timerInterval = null;
    let whiteTime, blackTime, increment;
    let timeLimited = false;
    let gameOver = false;
    let blindfoldMode = false;
    let showHistoryInBlindfold = false;
    let moveHistory = [];
    let currentMoveIndex = -1;
    let capturedPieces = { white: [], black: [] };
    let lastMoveSquares = { from: null, to: null };
    let gameStartTime = null;
    let currentPieceStyle = 'wikipedia';
    let premove = null; // Store premove as {from: 'e2', to: 'e4'}
    let selectedSquare = null; // Track clicked piece for click-to-move
    let currentEngineStyle = 'balanced'; // Track current engine personality

    // Engine personality presets
    const enginePersonalities = {
      balanced: {
        material: 1.0,
        king_safety_b: 1.0, king_safety_w: 1.0,
        centralization_b: 1.0, centralization_w: 1.0,
        attack_b: 1.0, attack_w: 1.0,
        piece_activity_b: 1.0, piece_activity_w: 1.0,
        defense_b: 1.0, defense_w: 1.0,
        pawn_structure_b: 1.0, pawn_structure_w: 1.0
      },
      aggressive: {
        material: 0.7,
        king_safety_b: 0.5, king_safety_w: 0.5,
        centralization_b: 1.5, centralization_w: 1.5,
        attack_b: 2.5, attack_w: 2.5,
        piece_activity_b: 1.8, piece_activity_w: 1.8,
        defense_b: 0.4, defense_w: 0.4,
        pawn_structure_b: 0.6, pawn_structure_w: 0.6
      },
      defensive: {
        material: 1.2,
        king_safety_b: 2.2, king_safety_w: 2.2,
        centralization_b: 0.7, centralization_w: 0.7,
        attack_b: 0.5, attack_w: 0.5,
        piece_activity_b: 0.6, piece_activity_w: 0.6,
        defense_b: 2.0, defense_w: 2.0,
        pawn_structure_b: 1.8, pawn_structure_w: 1.8
      },
      positional: {
        material: 0.8,
        king_safety_b: 1.4, king_safety_w: 1.4,
        centralization_b: 2.0, centralization_w: 2.0,
        attack_b: 0.7, attack_w: 0.7,
        piece_activity_b: 1.5, piece_activity_w: 1.5,
        defense_b: 1.6, defense_w: 1.6,
        pawn_structure_b: 1.9, pawn_structure_w: 1.9
      },
      material: {
        material: 2.5,
        king_safety_b: 0.7, king_safety_w: 0.7,
        centralization_b: 0.6, centralization_w: 0.6,
        attack_b: 0.9, attack_w: 0.9,
        piece_activity_b: 0.5, piece_activity_w: 0.5,
        defense_b: 0.7, defense_w: 0.7,
        pawn_structure_b: 1.1, pawn_structure_w: 1.1
      },
      tactical: {
        material: 0.9,
        king_safety_b: 0.6, king_safety_w: 0.6,
        centralization_b: 1.6, centralization_w: 1.6,
        attack_b: 2.2, attack_w: 2.2,
        piece_activity_b: 2.0, piece_activity_w: 2.0,
        defense_b: 0.7, defense_w: 0.7,
        pawn_structure_b: 0.8, pawn_structure_w: 0.8
      },
      custom: {
        material: 1.0,
        king_safety_b: 1.0, king_safety_w: 1.0,
        centralization_b: 1.0, centralization_w: 1.0,
        attack_b: 1.0, attack_w: 1.0,
        piece_activity_b: 1.0, piece_activity_w: 1.0,
        defense_b: 1.0, defense_w: 1.0,
        pawn_structure_b: 1.0, pawn_structure_w: 1.0
      }
    };

    // Piece style themes
    const pieceThemes = {
      wikipedia: 'lib/img/chesspieces/wikipedia/{piece}.png',
      alpha: 'https://lichess1.org/assets/piece/alpha/{piece}.svg',
      cburnett: 'https://lichess1.org/assets/piece/cburnett/{piece}.svg',
      merida: 'https://lichess1.org/assets/piece/merida/{piece}.svg',
      pirouetti: 'https://lichess1.org/assets/piece/pirouetti/{piece}.svg',
      spatial: 'https://lichess1.org/assets/piece/spatial/{piece}.svg'
    };

    // Opening Book Database
    const openingBook = {
      "e4": "King's Pawn Opening",
      "e4 e5": "Open Game",
      "e4 e5 Nf3 Nc6 Bb5": "Ruy Lopez (Spanish Opening)",
      "e4 e5 Nf3 Nc6 Bb5 a6": "Ruy Lopez: Morphy Defense",
      "e4 e5 Nf3 Nc6 Bb5 a6 Ba4 Nf6 O-O": "Ruy Lopez: Closed Variation",
      "e4 e5 Nf3 Nc6 Bb5 a6 Ba4 Nf6 O-O Be7": "Ruy Lopez: Closed, Chigorin Defense",
      "e4 e5 Nf3 Nc6 Bb5 Nf6": "Ruy Lopez: Berlin Defense",
      "e4 e5 Nf3 Nc6 Bc4": "Italian Game",
      "e4 e5 Nf3 Nc6 Bc4 Bc5": "Italian Game: Giuoco Piano",
      "e4 e5 Nf3 Nc6 Bc4 Bc5 c3": "Italian Game: Giuoco Pianissimo",
      "e4 e5 Nf3 Nc6 Bc4 Bc5 b4": "Italian Game: Evans Gambit",
      "e4 e5 Nf3 Nc6 Bc4 Nf6": "Italian Game: Two Knights Defense",
      "e4 e5 Nf3 Nf6": "Petrov's Defense (Russian Game)",
      "e4 c5": "Sicilian Defense",
      "e4 c5 Nf3 d6": "Sicilian Defense: Open Variation",
      "e4 c5 Nf3 d6 d4 cxd4 Nxd4 Nf6 Nc3 a6": "Sicilian Defense: Najdorf Variation",
      "e4 c5 Nf3 d6 d4 cxd4 Nxd4 Nf6 Nc3 g6": "Sicilian Defense: Dragon Variation",
      "e4 c5 Nf3 d6 d4 cxd4 Nxd4 Nf6 Nc3 e6": "Sicilian Defense: Scheveningen Variation",
      "e4 c5 Nf3 Nc6": "Sicilian Defense: Closed Variation",
      "e4 c5 Nf3 e6": "Sicilian Defense: French Variation",
      "e4 c5 c3": "Sicilian Defense: Alapin Variation",
      "e4 e6": "French Defense",
      "e4 e6 d4 d5": "French Defense: Main Line",
      "e4 e6 d4 d5 Nc3": "French Defense: Classical Variation",
      "e4 e6 d4 d5 Nd2": "French Defense: Tarrasch Variation",
      "e4 e6 d4 d5 exd5": "French Defense: Exchange Variation",
      "e4 c6": "Caro-Kann Defense",
      "e4 c6 d4 d5": "Caro-Kann Defense: Main Line",
      "e4 c6 d4 d5 Nc3": "Caro-Kann Defense: Classical Variation",
      "e4 c6 d4 d5 exd5": "Caro-Kann Defense: Exchange Variation",
      "e4 d5": "Scandinavian Defense (Center Counter)",
      "e4 d5 exd5 Qxd5": "Scandinavian Defense: Main Line",
      "e4 d5 exd5 Nf6": "Scandinavian Defense: Modern Variation",
      "d4": "Queen's Pawn Opening",
      "d4 d5": "Closed Game",
      "d4 d5 c4": "Queen's Gambit",
      "d4 d5 c4 e6": "Queen's Gambit Declined",
      "d4 d5 c4 e6 Nc3 Nf6": "Queen's Gambit Declined: Orthodox Variation",
      "d4 d5 c4 e6 Nc3 Nf6 Bg5": "Queen's Gambit Declined: Classical Variation",
      "d4 d5 c4 c6": "Slav Defense",
      "d4 d5 c4 c6 Nf3 Nf6 Nc3 dxc4": "Slav Defense: Accepted Variation",
      "d4 d5 c4 c6 Nf3 Nf6 Nc3 e6": "Semi-Slav Defense",
      "d4 d5 c4 dxc4": "Queen's Gambit Accepted",
      "d4 Nf6 c4 g6": "King's Indian Defense",
      "d4 Nf6 c4 g6 Nc3 Bg7": "King's Indian Defense: Main Line",
      "d4 Nf6 c4 g6 Nc3 Bg7 e4": "King's Indian Defense: Classical Variation",
      "d4 Nf6 c4 e6": "Indian Defense",
      "d4 Nf6 c4 e6 Nc3 Bb4": "Nimzo-Indian Defense",
      "d4 Nf6 c4 e6 Nc3 Bb4 Qc2": "Nimzo-Indian Defense: Classical Variation",
      "d4 Nf6 c4 e6 Nc3 Bb4 e3": "Nimzo-Indian Defense: Rubinstein Variation",
      "d4 Nf6 c4 e6 Nf3 b6": "Queen's Indian Defense",
      "d4 Nf6 Nf3 g6": "King's Indian Attack",
      "d4 Nf6 Nf3 e6": "Indian Game",
      "d4 Nf6 c4 c5 d5": "Benoni Defense: Modern Benoni",
      "d4 Nf6 c4 c5 d5 e6": "Benoni Defense: Modern Variation",
      "Nf3": "R√©ti Opening",
      "Nf3 d5 c4": "R√©ti Opening: Anglo-Slav Variation",
      "Nf3 Nf6 c4 g6": "R√©ti Opening: King's Indian Attack",
      "c4": "English Opening",
      "c4 e5": "English Opening: Reversed Sicilian",
      "c4 Nf6": "English Opening: Anglo-Indian Defense",
      "c4 c5": "English Opening: Symmetrical Variation",
      "e4 e5 Nf3 Nc6 d4": "Scotch Game",
      "e4 e5 Nf3 Nc6 d4 exd4 Nxd4": "Scotch Game: Main Line",
      "e4 e5 Nf3 Nc6 Nc3": "Four Knights Game",
      "e4 e5 Nf3 Nc6 Nc3 Nf6": "Four Knights Game: Spanish Variation",
      "e4 e5 f4": "King's Gambit",
      "e4 e5 f4 exf4": "King's Gambit Accepted",
      "e4 e5 f4 Bc5": "King's Gambit Declined: Classical Defense",
      "d4 Nf6 Bg5": "Trompowsky Attack",
      "d4 Nf6 Bg5 Ne4": "Trompowsky Attack: Main Line",
      "d4 d5 Nf3": "London System",
      "d4 d5 Nf3 Nf6 Bf4": "London System: Main Line",
      "e4 g6": "Modern Defense",
      "e4 Nc6": "Nimzowitsch Defense",
      "d4 f5": "Dutch Defense",
      "d4 f5 g3": "Dutch Defense: Leningrad Variation",
      "f4": "Bird's Opening",
      "b3": "Larsen's Opening (Queen's Fianchetto)"
    };

    // --- sendEngineCommand function ---
    function sendEngineCommand(endpoint) {
    // Key change: Add 'return' here to return the promise chain
    return fetch(`https://hedgehoglover23.pythonanywhere.com/${endpoint}`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({})
    })
    .then(response => {
        if (!response.ok) {
            return response.json().then(err => {
                throw new Error(`Server error for /${endpoint}: ${err.message || response.statusText}`);
            }).catch(() => {
                throw new Error(`Server error for /${endpoint}: ${response.status} ${response.statusText}`);
            });
        }
        return response.json(); // This 'return' passes the parsed data down
    })
    .then(data => {
        console.log(`Command /${endpoint} successful:`, data.message || data.status || data);
        return data; // This 'return data' is correct for the internal chain
    })
    .catch(error => {
        console.error(`Error sending command /${endpoint}:`, error);
        throw error; // Propagate the error so the awaiting function can catch it
    });
}

    function toggleHistoryOption() {
      const blindfoldChecked = document.getElementById("blindfold-mode").checked;
      const historyRow = document.getElementById("show-history-row");
      if (blindfoldChecked) {
        historyRow.style.display = "inline-block";
      } else {
        historyRow.style.display = "none";
      }
    }

    function updateCustomModifiers() {
      // Helper function to clamp values between 0 and 3
      const clampValue = (value) => {
        const num = parseFloat(value);
        if (isNaN(num)) return 1.0;
        return Math.max(0, Math.min(3, num));
      };
      
      // Get values and clamp them
      const material = clampValue(document.getElementById('mod-material').value);
      const kingSafety = clampValue(document.getElementById('mod-king-safety').value);
      const centralization = clampValue(document.getElementById('mod-centralization').value);
      const attack = clampValue(document.getElementById('mod-attack').value);
      const pieceActivity = clampValue(document.getElementById('mod-piece-activity').value);
      const defense = clampValue(document.getElementById('mod-defense').value);
      const pawnStructure = clampValue(document.getElementById('mod-pawn-structure').value);
      
      // Update input fields with clamped values
      document.getElementById('mod-material').value = material.toFixed(1);
      document.getElementById('mod-king-safety').value = kingSafety.toFixed(1);
      document.getElementById('mod-centralization').value = centralization.toFixed(1);
      document.getElementById('mod-attack').value = attack.toFixed(1);
      document.getElementById('mod-piece-activity').value = pieceActivity.toFixed(1);
      document.getElementById('mod-defense').value = defense.toFixed(1);
      document.getElementById('mod-pawn-structure').value = pawnStructure.toFixed(1);
      
      // Update the custom personality in enginePersonalities object
      enginePersonalities.custom.material = material;
      enginePersonalities.custom.king_safety_b = kingSafety;
      enginePersonalities.custom.king_safety_w = kingSafety;
      enginePersonalities.custom.centralization_b = centralization;
      enginePersonalities.custom.centralization_w = centralization;
      enginePersonalities.custom.attack_b = attack;
      enginePersonalities.custom.attack_w = attack;
      enginePersonalities.custom.piece_activity_b = pieceActivity;
      enginePersonalities.custom.piece_activity_w = pieceActivity;
      enginePersonalities.custom.defense_b = defense;
      enginePersonalities.custom.defense_w = defense;
      enginePersonalities.custom.pawn_structure_b = pawnStructure;
      enginePersonalities.custom.pawn_structure_w = pawnStructure;
      
      // Save to localStorage
      localStorage.setItem('customModifiers', JSON.stringify({
        material: material,
        king_safety: kingSafety,
        centralization: centralization,
        attack: attack,
        piece_activity: pieceActivity,
        defense: defense,
        pawn_structure: pawnStructure
      }));
      
      // Apply modifiers in real-time
      applyEngineModifiers('custom');
    }

    function resetCustomModifiers() {
      document.getElementById('mod-material').value = 1.0;
      document.getElementById('mod-king-safety').value = 1.0;
      document.getElementById('mod-centralization').value = 1.0;
      document.getElementById('mod-attack').value = 1.0;
      document.getElementById('mod-piece-activity').value = 1.0;
      document.getElementById('mod-defense').value = 1.0;
      document.getElementById('mod-pawn-structure').value = 1.0;
      updateCustomModifiers();
    }

    function loadCustomModifiers() {
      const saved = localStorage.getItem('customModifiers');
      if (saved) {
        const custom = JSON.parse(saved);
        document.getElementById('mod-material').value = custom.material || 1.0;
        document.getElementById('mod-king-safety').value = custom.king_safety || 1.0;
        document.getElementById('mod-centralization').value = custom.centralization || 1.0;
        document.getElementById('mod-attack').value = custom.attack || 1.0;
        document.getElementById('mod-piece-activity').value = custom.piece_activity || 1.0;
        document.getElementById('mod-defense').value = custom.defense || 1.0;
        document.getElementById('mod-pawn-structure').value = custom.pawn_structure || 1.0;
        updateCustomModifiers();
      }
    }

    function toggleHistoryOption() {
      const blindfoldChecked = document.getElementById("blindfold-mode").checked;
      const historyRow = document.getElementById("show-history-row");
      if (blindfoldChecked) {
        historyRow.style.display = "inline-block";
      } else {
        historyRow.style.display = "none";
        document.getElementById("show-history").checked = false;
      }
    }

    function changeBoardStyle() {
      const style = document.getElementById("board-style").value;
      const boardElement = document.getElementById("board");
      
      // Remove all theme classes
      boardElement.className = boardElement.className.replace(/board-theme-\w+/g, '').trim();
      
      // Add new theme class
      boardElement.classList.add(`board-theme-${style}`);
      
      // Save preference to localStorage
      localStorage.setItem('chessboardStyle', style);
    }

    function changeEngineStyle() {
      const style = document.getElementById("engine-style").value;
      const selector = document.getElementById("engine-style");
      const customPanel = document.getElementById("custom-modifiers-panel");
      currentEngineStyle = style;
      
      // Remove all personality classes
      selector.className = selector.className.replace(/personality-\w+/g, '').trim();
      
      // Add new personality class for color
      selector.classList.add('personality-' + style);
      
      // Show/hide custom modifiers panel
      if (style === 'custom') {
        customPanel.style.display = 'block';
        loadCustomModifiers();
      } else {
        customPanel.style.display = 'none';
      }
      
      // Save preference to localStorage
      localStorage.setItem('enginePersonality', style);
      
      // Apply modifiers to engine
      applyEngineModifiers(style);
    }

    async function applyEngineModifiers(personality) {
      const baseModifiers = enginePersonalities[personality];
      
      if (!baseModifiers) {
        console.error('Unknown engine personality:', personality);
        return;
      }

      // Determine which color the engine is playing
      const engineColor = playerColor === 'white' ? 'black' : 'white';
      // NOTE: Code internals are reversed from board!
      // _b modifiers = WHITE pieces on board, _w modifiers = BLACK pieces on board
      const engineSuffix = engineColor === 'black' ? '_w' : '_b';
      const playerSuffix = engineColor === 'black' ? '_b' : '_w';

      // Build asymmetric modifiers: engine gets personality, player gets balanced (1.0)
      const modifiers = {
        material: baseModifiers.material, // Material is symmetric
      };

      // For each personality trait, apply it to engine's color only
      const traits = ['king_safety', 'centralization', 'attack', 'piece_activity', 'defense', 'pawn_structure'];
      
      traits.forEach(trait => {
        // Engine's color gets the personality modifier
        modifiers[trait + engineSuffix] = baseModifiers[trait + engineSuffix];
        // Player's color gets balanced modifier (1.0)
        modifiers[trait + playerSuffix] = 1.0;
      });

      console.log('Applying asymmetric modifiers:', {
        personality,
        engineColor,
        engineSuffix,
        playerSuffix,
        engineModifiers: modifiers
      });

      try {
        const response = await fetch('https://hedgehoglover23.pythonanywhere.com/modifiers', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(modifiers)
        });

        if (response.ok) {
          const data = await response.json();
          console.log('Engine modifiers updated (asymmetric):', data);
        } else {
          console.error('Failed to update engine modifiers:', response.statusText);
        }
      } catch (error) {
        console.error('Error updating engine modifiers:', error);
      }
    }

    function changePieceStyle() {
      const style = document.getElementById("piece-style").value;
      currentPieceStyle = style;
      
      // Save preference to localStorage
      localStorage.setItem('chessPieceStyle', style);
      
      // If board exists, update the piece theme
      if (board) {
        const currentPosition = board.position();
        board.destroy();
        
        // Check if game is active or preview mode
        const isGameStarted = document.getElementById("choose-side").style.display === "none";
        
        if (isGameStarted && game && !gameOver) {
          // Game is active - recreate with full handlers
          recreateBoard();
        } else {
          // Preview mode - recreate preview board
          board = Chessboard('board', {
            draggable: false,
            position: currentPosition,
            orientation: 'white',
            pieceTheme: pieceThemes[currentPieceStyle]
          });
        }
        board.position(currentPosition);
      }
    }

    function recreateBoard() {
      board = Chessboard("board", {
        draggable: true,
        position: game ? game.fen() : "start",
        orientation: playerColor,
        snapSpeed: 50,
        snapbackSpeed: 50,
        appearSpeed: 0,
        moveSpeed: 100,
        trashSpeed: 50,
        dragThrottleRate: 0,
        sparePieces: false,
        dropOffBoard: 'snapback',
        onDragStart: (source, piece, position, orientation) => {
          if (game.game_over() || gameOver) {
            const sourceSquare = $(`#board .square-${source}`);
            sourceSquare.addClass('illegal-move');
            setTimeout(() => sourceSquare.removeClass('illegal-move'), 600);
            return false;
          }
          const turn = game.turn();
          if ((playerColor === "white" && turn !== "w") || (playerColor === "black" && turn !== "b")) {
            const sourceSquare = $(`#board .square-${source}`);
            sourceSquare.addClass('illegal-move');
            setTimeout(() => sourceSquare.removeClass('illegal-move'), 600);
            return false;
          }
          if ((turn === 'w' && piece.search(/^b/) !== -1) || (turn === 'b' && piece.search(/^w/) !== -1)) {
            const sourceSquare = $(`#board .square-${source}`);
            sourceSquare.addClass('illegal-move');
            setTimeout(() => sourceSquare.removeClass('illegal-move'), 600);
            return false;
          }
          highlightLegalMoves(source);
        },
        onDragMove: (newLocation, oldLocation, source, piece, position, orientation) => {
          $("#board .square-55d63").removeClass("legal-target");
          const moves = game.moves({ square: source, verbose: true });
          const isLegal = moves.some(move => move.to === newLocation);
          if (isLegal) {
            $(`#board .square-${newLocation}`).addClass("legal-target");
          }
        },
        onDrop: handleMove,
        onSnapEnd: () => {
          removeHighlights();
          $("#board .square-55d63").removeClass("legal-target");
        },
        pieceTheme: pieceThemes[currentPieceStyle],
      });
    }

 $(document).ready(function() {
	 		
        console.log("The page has finished loading!");

        // Load saved board style
        const savedStyle = localStorage.getItem('chessboardStyle') || 'classic';
        document.getElementById('board-style').value = savedStyle;
        changeBoardStyle();

        // Load saved piece style
        const savedPieceStyle = localStorage.getItem('chessPieceStyle') || 'wikipedia';
        currentPieceStyle = savedPieceStyle;
        document.getElementById('piece-style').value = savedPieceStyle;

        // Load saved engine personality
        const savedEngineStyle = localStorage.getItem('enginePersonality') || 'balanced';
        currentEngineStyle = savedEngineStyle;
        const engineStyleSelect = document.getElementById('engine-style');
        engineStyleSelect.value = savedEngineStyle;
        // Apply personality color on load
        engineStyleSelect.classList.add('personality-' + savedEngineStyle);
        
        // Show custom panel if custom personality was selected
        if (savedEngineStyle === 'custom') {
          document.getElementById('custom-modifiers-panel').style.display = 'block';
          loadCustomModifiers();
        }

        // Initialize game object for preview board
        game = new Chess();
        gameOver = false;
        playerColor = "white"; // Default for preview

        // Create preview board with dragging enabled
        board = Chessboard('board', {
          draggable: false,
          position: 'start',
          orientation: 'white',
          pieceTheme: pieceThemes[currentPieceStyle]
        });
        
        console.log('Preview board created with config:', {
          draggable: false
        });
        
        // Show the board container
        document.getElementById('board-timers-container').style.display = 'flex';

        // --- AUTOMATIC LOGIC: Stop then Start the engine on page load ---
        console.log("Attempting to stop and then start the engine automatically on page load...");
        sendEngineCommand('stop')
            .then(() => {
                console.log("Stop command sent successfully. Now sending start command...");
                return sendEngineCommand('start');
            })
            .then(() => {
                console.log("Start command sent successfully. Engine should be reset and running.");
            })
            .catch(error => {
                console.error("Error during automatic engine reset on page load:", error);
                // Replaced alert() with a console log
                console.error("Failed to automatically reset engine on page load. Check console for details.");
            });
    });

        $(document).keydown(function(e) {
            if (!blindfoldMode && board && moveHistory.length > 0) {
                if (e.key === 'ArrowLeft' || e.keyCode === 37) {
                    e.preventDefault();
                    navigateToPreviousMove();
                } else if (e.key === 'ArrowRight' || e.keyCode === 39) {
                    e.preventDefault();
                    navigateToNextMove();
                } else if (e.key === 'ArrowUp' || e.keyCode === 38) {
                    e.preventDefault();
                    navigateToStart();
                } else if (e.key === 'ArrowDown' || e.keyCode === 40) {
                    e.preventDefault();
                    navigateToCurrent();
                }
            }
        });
    function formatTime(ms) {
      const t = Math.max(0, Math.floor(ms));
      const totalHundredths = Math.floor(t / 10);
      const minutes = String(Math.floor(totalHundredths / 6000)).padStart(2, "0");
      const seconds = String(Math.floor((totalHundredths % 6000) / 100)).padStart(2, "0");
      const hundredths = String(totalHundredths % 100).padStart(2, "0");
      return `${minutes}:${seconds}.${hundredths}`;
    }
    
    function updateClockStyles() {
        const turn = game.turn();
        const playerIsWhite = playerColor === 'white';
        
        // Determine which slot is the player's and which is the engine's
        const playerSlot = playerIsWhite ? document.getElementById("time-slot-white") : document.getElementById("time-slot-black");
        const engineSlot = playerIsWhite ? document.getElementById("time-slot-black") : document.getElementById("time-slot-white");
        
        // Remove active class from both
        playerSlot.classList.remove('time-active');
        engineSlot.classList.remove('time-active');

        // Add active class only to the player's clock when it's their turn
        if ((playerIsWhite && turn === 'w') || (!playerIsWhite && turn === 'b')) {
            playerSlot.classList.add('time-active');
        }
    }


    // MODIFIED: Timer always counts up, but only deducts time if it's the player's turn.
    function startTimer() {
      clearInterval(timerInterval);
      timerStart = performance.now();

      const turn = game.turn();
      const isPlayerTurn = (playerColor === "white" && turn === "w") || (playerColor === "black" && turn === "b");
      
      // Update clock styling (active state)
      updateClockStyles();

      // MODIFICATION START: Set player's time to its value and engine's time to "Unlimited"
      if (timeLimited) {
          // Determine element IDs and time references
          const playerTotalId = playerColor === 'white' ? "white-total" : "black-total";
          const engineTotalId = playerColor === 'white' ? "black-total" : "white-total";
          const playerTimeRef = playerColor === 'white' ? whiteTime : blackTime;
          
          // Set player's time display
          document.getElementById(playerTotalId).textContent = formatTime(playerTimeRef);
          
          // Set engine's time display to "Unlimited"
          document.getElementById(engineTotalId).textContent = "Unlimited";
      }
      // MODIFICATION END
      
      timerInterval = setInterval(() => {
          if (gameOver) {
              clearInterval(timerInterval);
              return;
          }

        const elapsed = performance.now() - timerStart;

        // 1. Always update the move timer display (Counts up)
        document.getElementById("timer").textContent = formatTime(elapsed);

        // 2. ONLY manage total time deduction/check if it's time limited AND the player's turn
        if (timeLimited && isPlayerTurn) {
            const totalTimeElementId = playerColor === 'white' ? "white-total" : "black-total";
            const playerTimeRef = playerColor === 'white' ? whiteTime : blackTime;
            
            const newTime = playerTimeRef - elapsed;

            // Update the player's total remaining time (countdown)
            document.getElementById(totalTimeElementId).textContent = formatTime(newTime);
            
            if (newTime <= 0) {
                clearInterval(timerInterval);
                // Replaced alert() with UI message
                const moveContainer = document.getElementById("move-timer-container");
                moveContainer.innerHTML = 'TIME OUT! <span style="color:red;">You lose!</span>';
                gameOver = true;
            }
        }
      }, 10);
    }

    // UNMODIFIED Logic, only checking if the color that just moved was the player's color
    function stopTimerAndUpdateTotal(color) {
      clearInterval(timerInterval);
      const elapsed = performance.now() - timerStart;
      if (timeLimited) {
        if (
          (color === "w" && playerColor === "white") ||
          (color === "b" && playerColor === "black")
          ) {
          if (color === "w") {
            whiteTime = Math.max(0, whiteTime - elapsed);
            whiteTime += increment * 1000;
            document.getElementById("white-total").textContent = formatTime(whiteTime);
          } else {
            blackTime = Math.max(0, blackTime - elapsed);
            blackTime += increment * 1000;
            document.getElementById("black-total").textContent = formatTime(blackTime);
          }
        }
      }
      return elapsed;
    }

function navigateToPreviousMove() {
      if (currentMoveIndex === -1 && moveHistory.length > 0) {
        currentMoveIndex = moveHistory.length - 2;
        if (currentMoveIndex < 0) currentMoveIndex = 0;
        displayPositionAtIndex(currentMoveIndex);
      } else if (currentMoveIndex === 0) {
        currentMoveIndex = -2;
        board.position('start');
        updateMoveHighlight();
      } else if (currentMoveIndex > 0) {
        currentMoveIndex--;
        displayPositionAtIndex(currentMoveIndex);
      }
    }

    function navigateToNextMove() {
      if (currentMoveIndex === -2 && moveHistory.length > 0) {
        currentMoveIndex = 0;
        displayPositionAtIndex(currentMoveIndex);
      } else if (currentMoveIndex === -1) {
        // Already at current position, do nothing
        return;
      } else if (currentMoveIndex < moveHistory.length - 1) {
        currentMoveIndex++;
        displayPositionAtIndex(currentMoveIndex);
      } else if (currentMoveIndex === moveHistory.length - 1) {
        currentMoveIndex = -1;
        board.position(game.fen());
        updateMoveHighlight();
      }
    }

    function navigateToStart() {
      currentMoveIndex = -2;
      board.position('start');
      updateMoveHighlight();
    }

    function navigateToCurrent() {
      currentMoveIndex = -1;
      board.position(game.fen());
      updateMoveHighlight();
    }

    function displayPositionAtIndex(index) {
      if (index >= 0 && index < moveHistory.length) {
        board.position(moveHistory[index]);
        updateMoveHighlight();
      }
    }

    function updateMoveHighlight() {
      $('.move-item').removeClass('highlighted');
      if (currentMoveIndex >= 0 && currentMoveIndex < moveHistory.length) {
        $(`.move-item[data-move-index="${currentMoveIndex}"]`).addClass('highlighted');
      }
    }

    function updateNotationDisplay() {
      const history = game.history();
      const container = document.getElementById("notation-container");
      container.innerHTML = '';

      for (let i = 0; i < history.length; i++) {
        if (i % 2 === 0) {
          const moveNum = Math.floor(i / 2) + 1;
          const moveSpan = document.createElement('span');
          moveSpan.className = 'move-number';
          moveSpan.textContent = moveNum + '.';
          container.appendChild(moveSpan);
          container.appendChild(document.createTextNode(' '));
        }

        const moveSpan = document.createElement('span');
        moveSpan.className = 'move-item';
        if (currentMoveIndex === i || (currentMoveIndex === -1 && i === history.length - 1)) {
          moveSpan.classList.add('highlighted');
        }
        moveSpan.setAttribute('data-move-index', i);
        moveSpan.onclick = function() { jumpToMove(i); };
        moveSpan.textContent = history[i];
        container.appendChild(moveSpan);
        container.appendChild(document.createTextNode(' '));
      }
    }

    function jumpToMove(index) {
      if (!blindfoldMode && index >= 0 && index < moveHistory.length) {
        currentMoveIndex = index;
        displayPositionAtIndex(index);
      }
    }

    function updateLastMove(move, timeStr, color, move_number) {
      const txt = move ? `${move} (${timeStr})` : "None";
      document.getElementById("last-move").textContent = txt;

      if (move) {
        moveHistory.push(game.fen());
        currentMoveIndex = -1;
        updateNotationDisplay();
      }
}

    function updateTurnDisplay() {
      document.getElementById("turn-color").textContent = game.turn() === "w" ? "White" : "Black";
    }

    function highlightLegalMoves(square) {
      const moves = game.moves({ square, verbose: true });
      for (const move of moves) {
        $(`#board .square-${move.to}`).addClass("highlight-legal");
      }
    }

    function removeHighlights() {
      // Don't remove highlights if a piece is selected for click-to-move
      if (!selectedSquare) {
        $("#board .square-55d63").removeClass("highlight-legal");
      }
    }

    function clearPremove() {
      if (premove) {
        // Restore actual game position when clearing premove
        board.position(game.fen());
      }
      premove = null;
      selectedSquare = null;
      $("#board .square-55d63").removeClass("premove-highlight premove-source");
    }

    function handleSquareClick(square) {
      console.log('=== handleSquareClick START ===', square);
      const turn = game.turn();
      const isPlayerTurn = (playerColor === "white" && turn === "w") || (playerColor === "black" && turn === "b");
      const piece = game.get(square);  // Use game.get() to get piece from game state
      console.log('Turn:', turn, 'isPlayerTurn:', isPlayerTurn, 'piece:', piece, 'selectedSquare:', selectedSquare);
      
      // If there's already a premove set, clicking anywhere cancels it
      if (premove) {
        console.log('Canceling premove');
        clearPremove();
        // After canceling premove, continue with normal click handling
      }
      
      // If there's a selected piece
      if (selectedSquare) {
        // If clicking the same square, deselect
        if (selectedSquare === square) {
          selectedSquare = null;
          removeHighlights();
          return;
        }
        
        // Check if this is a legal move or premove
        if (!isPlayerTurn) {
          // Handle premove click - clicking another of own pieces changes selection
          if (piece) {
            const pieceColorFull = piece.color === 'w' ? 'white' : 'black';
            if (pieceColorFull === playerColor) {
              // Clear old highlights before selecting new piece
              $("#board .square-55d63").removeClass("highlight-legal");
              selectedSquare = square;
              highlightLegalMoves(square);
              return;
            }
          }
          
          // Make premove
          const premoveFrom = selectedSquare;
          const premoveTo = square;
          
          selectedSquare = null;
          removeHighlights();
          
          $("#board .square-55d63").removeClass("premove-highlight premove-source");
          if (premove) {
            board.position(game.fen());
          }
          
          premove = { from: premoveFrom, to: premoveTo };
          
          const pos = board.position();
          const movingPiece = pos[premoveFrom];
          delete pos[premoveFrom];
          pos[premoveTo] = movingPiece;
          board.position(pos);
          
          setTimeout(() => {
            $(`#board .square-${premoveFrom}`).addClass("premove-source");
            $(`#board .square-${premoveTo}`).addClass("premove-highlight");
          }, 0);
          return;
        } else {
          // Try to make a normal move
          const moveFrom = selectedSquare;
          const moveTo = square;
          console.log('Attempting move from', moveFrom, 'to', moveTo);
          const testMove = game.move({ from: moveFrom, to: moveTo, promotion: 'q' });
          console.log('Test move result:', testMove);
          
          if (testMove) {
            // Legal move - undo the test move, then execute properly
            game.undo();
            clearPremove();
            selectedSquare = null;
            removeHighlights();
            console.log('Calling handleMove');
            handleMove(moveFrom, moveTo);
            return;
          } else if (piece) {
            const pieceColorFull = piece.color === 'w' ? 'white' : 'black';
            if (pieceColorFull === playerColor) {
              // Illegal move but clicked on own piece - change selection
              console.log('Switching selection to', square);
              // Clear old highlights before selecting new piece
              $("#board .square-55d63").removeClass("highlight-legal");
              selectedSquare = square;
              highlightLegalMoves(square);
              return;
            }
          }
          
          // Invalid move, deselect
          console.log('Invalid move, deselecting');
          selectedSquare = null;
          removeHighlights();
          return;
        }
      }
      
      // No piece selected - select clicked piece if valid
      if (piece) {
        const pieceColorFull = piece.color === 'w' ? 'white' : 'black';
        if (pieceColorFull === playerColor) {
          // Allow selecting own pieces even during opponent's turn (for premoves)
          console.log('Setting selectedSquare to:', square);
          // Clear old highlights before selecting new piece
          $("#board .square-55d63").removeClass("highlight-legal");
          selectedSquare = square;
          highlightLegalMoves(square);
          console.log('After setting, selectedSquare is:', selectedSquare);
        }
      }
    }

    function detectOpening() {
      const history = game.history();
      let movesStr = history.join(" ");
      
      // Check for exact matches, starting with longest sequences
      const sortedOpenings = Object.keys(openingBook).sort((a, b) => b.length - a.length);
      
      for (let opening of sortedOpenings) {
        if (movesStr.startsWith(opening)) {
          return openingBook[opening];
        }
      }
      
      return null;
    }

    function updateOpeningDisplay() {
      const opening = detectOpening();
      const openingNameEl = document.getElementById("opening-name");
      
      if (opening) {
        openingNameEl.textContent = opening;
        document.getElementById("opening-display").style.display = "block";
      } else if (game.history().length > 10) {
        openingNameEl.textContent = "General Position";
        document.getElementById("opening-display").style.display = "block";
      }
    }

    function highlightLastMove(from, to) {
      // Remove previous highlights
      $("#board .square-55d63").removeClass("highlight-last-move");
      
      // Add new highlights
      if (from && to) {
        $("#board .square-" + from).addClass("highlight-last-move");
        $("#board .square-" + to).addClass("highlight-last-move");
      }
    }

    function highlightCheck() {
      // Remove previous check highlights
      $("#board .square-55d63").removeClass("highlight-check");
      
      if (game.in_check()) {
        const turn = game.turn();
        const kingSquare = findKingSquare(turn);
        if (kingSquare) {
          $("#board .square-" + kingSquare).addClass("highlight-check");
        }
      }
    }

    function findKingSquare(color) {
      const board = game.board();
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          const piece = board[i][j];
          if (piece && piece.type === 'k' && piece.color === color) {
            const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
            return files[j] + (8 - i);
          }
        }
      }
      return null;
    }

    function updateGameStats() {
      // Update total moves
      document.getElementById("total-moves").textContent = game.history().length;
      
      // Update captured pieces display
      updateCapturedPieces();
      
      // Calculate and update material balance
      updateMaterialBalance();
    }

    function updateCapturedPieces() {
      const whiteCapDiv = document.getElementById("white-captures-display");
      const blackCapDiv = document.getElementById("black-captures-display");
      
      whiteCapDiv.innerHTML = capturedPieces.white.length > 0 ? 
        capturedPieces.white.map(p => `<div class="captured-piece" style="background-image: url('lib/img/chesspieces/wikipedia/${p}.png')"></div>`).join('') :
        '';
      
      blackCapDiv.innerHTML = capturedPieces.black.length > 0 ? 
        capturedPieces.black.map(p => `<div class="captured-piece" style="background-image: url('lib/img/chesspieces/wikipedia/${p}.png')"></div>`).join('') :
        '';
    }

    function updateMaterialBalance() {
      const pieceValues = { p: 1, n: 3, b: 3, r: 5, q: 9, k: 0 };
      
      let whiteMaterial = 0;
      let blackMaterial = 0;
      
      const board = game.board();
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          const piece = board[i][j];
          if (piece) {
            const value = pieceValues[piece.type];
            if (piece.color === 'w') {
              whiteMaterial += value;
            } else {
              blackMaterial += value;
            }
          }
        }
      }
      
      const difference = whiteMaterial - blackMaterial;
      const balanceEl = document.getElementById("material-balance");
      
      balanceEl.classList.remove('positive', 'negative', 'equal');
      
      if (difference > 0) {
        balanceEl.textContent = `White +${difference}`;
        balanceEl.classList.add('positive');
      } else if (difference < 0) {
        balanceEl.textContent = `Black +${Math.abs(difference)}`;
        balanceEl.classList.add('negative');
      } else {
        balanceEl.textContent = 'Equal';
        balanceEl.classList.add('equal');
      }
    }

    function trackCapturedPiece(move) {
      if (move.captured) {
        const capturedPieceCode = move.color === 'w' ? 'b' + move.captured.toUpperCase() : 'w' + move.captured.toUpperCase();
        if (move.color === 'w') {
          capturedPieces.white.push(capturedPieceCode);
        } else {
          capturedPieces.black.push(capturedPieceCode);
        }
      }
    }

    function exportPGN() {
      const date = new Date();
      const dateStr = date.toISOString().split('T')[0].replace(/-/g, '.');
      
      let pgn = '[Event "Chess vs TrifangX"]\n';
      pgn += '[Site "Ahrens Labs"]\n';
      pgn += `[Date "${dateStr}"]\n`;
      pgn += '[Round "1"]\n';
      pgn += `[White "${playerColor === 'white' ? 'Player' : 'TrifangX'}"]\n`;
      pgn += `[Black "${playerColor === 'black' ? 'Player' : 'TrifangX'}"]\n`;
      
      let result = '*';
      if (game.in_checkmate()) {
        result = game.turn() === 'w' ? '0-1' : '1-0';
      } else if (game.in_draw() || game.in_stalemate() || game.in_threefold_repetition()) {
        result = '1/2-1/2';
      }
      pgn += `[Result "${result}"]\n\n`;
      
      const history = game.history();
      let moveText = '';
      for (let i = 0; i < history.length; i++) {
        if (i % 2 === 0) {
          moveText += `${Math.floor(i / 2) + 1}. `;
        }
        moveText += history[i] + ' ';
        if (i % 2 === 1) {
          moveText += '\n';
        }
      }
      
      pgn += moveText.trim() + ` ${result}`;
      
      // Create download
      const blob = new Blob([pgn], { type: 'text/plain' });
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `chess_game_${dateStr}.pgn`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
    }
    
    function resignGame() {
      if (gameOver) return;
      
      // Position the modal above the resign button
      const modal = document.getElementById('confirm-modal');
      const resignBtn = document.getElementById('resign-btn');
      const btnRect = resignBtn.getBoundingClientRect();
      const modalWidth = 320; // max-width from CSS
      
      modal.style.left = (btnRect.left + btnRect.width / 2 - modalWidth / 2) + 'px';
      modal.style.bottom = (window.innerHeight - btnRect.top + 15) + 'px';
      
      modal.classList.add('show');
    }

    function closeConfirmModal() {
      document.getElementById('confirm-modal').classList.remove('show');
    }

    function confirmResign() {
      closeConfirmModal();
      
      const winner = playerColor === 'white' ? 'black' : 'white';
      const moveContainer = document.getElementById("move-timer-container");
      moveContainer.innerHTML = `RESIGNATION! <span style="color:red;">You Lose!</span>`;
      gameOver = true;
      
      // Send resignation to engine
      sendEngineCommand("resign").catch(err => console.error("Error sending resignation:", err));
          a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
    }

    function setupTimerDisplayOrder() {
      // Get the parent container
      const container = document.getElementById('timers-container');
      
      // Get the individual time slots
      const whiteSlot = document.getElementById('time-slot-white');
      const blackSlot = document.getElementById('time-slot-black');

      // Determine player and engine colors
      const playerIsWhite = playerColor === 'white';
      const playerSlot = playerIsWhite ? whiteSlot : blackSlot;
      const engineSlot = playerIsWhite ? blackSlot : whiteSlot;

      // Remove existing children
      container.innerHTML = '';

      // Engine time always on top, Player time always on bottom
      container.appendChild(engineSlot);
      container.appendChild(playerSlot);
    }

    async function startGame() {
      gameOver = false;
      
      const side = document.getElementById("color-select").value;
      const timeOption = document.getElementById("time-control").value;      blindfoldMode = document.getElementById("blindfold-mode").checked;      showHistoryInBlindfold = document.getElementById("show-history").checked;      playerColor = side === "random" ? (Math.random() < 0.5 ? "white" : "black") : side;
      const [base, inc] =
        timeOption === "none" ? [null, null] : timeOption.split("|").map(Number);

      timeLimited = timeOption !== "none";
      increment = inc || 0;
      whiteTime = base ? base * 1000 : 0;
      blackTime = base ? base * 1000 : 0;

      // Show or hide timers based on time control
      const timersContainer = document.getElementById("timers-container");
      if (timeLimited) {
        timersContainer.style.display = "flex";
      } else {
        timersContainer.style.display = "none";
      }

      // Reset game (don't create new, just reset existing)
      if (!game) {
        game = new Chess();
      } else {
        game.reset();
      }
      moveHistory = [];
      currentMoveIndex = -1;
      capturedPieces = { white: [], black: [] };
      lastMoveSquares = { from: null, to: null };
      gameStartTime = new Date();
      premove = null; // Clear any premove
      selectedSquare = null; // Clear any selection
      
      // Hide the options panel with fade effect
      const choosePanel = document.getElementById("choose-side");
      choosePanel.style.transition = "opacity 0.3s ease, transform 0.3s ease";
      choosePanel.style.opacity = "0";
      choosePanel.style.transform = "scale(0.95)";
      setTimeout(() => {
        choosePanel.style.display = "none";
      }, 300);
      
      document.getElementById("move-timer-container").innerHTML = 'Time for this move: <span id="timer">00:00.00</span>';

      updateLastMove(null, "00:00.00", 0, 0);
      updateTurnDisplay();

      // Destroy preview board and create game board
      if (board) {
        board.destroy();
      }
      
      board = Chessboard("board", {
        draggable: true,
        position: "start",
        orientation: playerColor,
        snapSpeed: 50,
        snapbackSpeed: 50,
        appearSpeed: 0,
        moveSpeed: 100,
        trashSpeed: 50,
        dragThrottleRate: 0,
        sparePieces: false,
        dropOffBoard: 'snapback',
        onDragStart: (source, piece, position, orientation) => {
          console.log('onDragStart called for:', source, 'selectedSquare before:', selectedSquare);
          // Store the drag start square and time for click detection
          window.dragStartSquare = source;
          window.dragStartTime = Date.now();
          
          // Don't clear selection yet - wait to see if this is a click or drag
          
          // Don't allow dragging if game is over
          if (game.game_over() || gameOver) {
            return false;
          }
          
          const turn = game.turn();
          const isPlayerTurn = (playerColor === "white" && turn === "w") || (playerColor === "black" && turn === "b");
          
          // Allow dragging opponent's pieces for premove, or own pieces on player's turn
          if (!isPlayerTurn) {
            // This is a premove - allow dragging player's pieces only
            if ((playerColor === "white" && piece.search(/^w/) === -1) || 
                (playerColor === "black" && piece.search(/^b/) === -1)) {
              return false; // Can't premove opponent's pieces
            }
            return true; // Allow premove
          }
          
          // Don't allow dragging opponent's pieces on player's turn
          if ((turn === 'w' && piece.search(/^b/) !== -1) || (turn === 'b' && piece.search(/^w/) !== -1)) {
            return false;
          }
          
          // Highlight legal moves when starting to drag
          highlightLegalMoves(source);
        },
        onDragMove: (newLocation, oldLocation, source, piece, position, orientation) => {
          // Remove previous legal-target class
          $("#board .square-55d63").removeClass("legal-target");
          
          // Only add yellow border if hovering over a legal move square
          const moves = game.moves({ square: source, verbose: true });
          const isLegal = moves.some(move => move.to === newLocation);
          
          if (isLegal) {
            $(`#board .square-${newLocation}`).addClass("legal-target");
          }
        },
        onMouseoutSquare: (square, piece) => {
          // Only remove legal-target class (yellow hover border during drag)
          $("#board .square-55d63").removeClass("legal-target");
          // Don't remove legal move dots - they stay until piece is deselected or moved
        },
        onDrop: (source, target) => {
          console.log('onDrop called:', source, '->', target);
          
          // Detect click-to-move: if dropped on same square, it's a click
          if (source === target) {
            console.log('Click detected (drop on same square):', source);
            handleSquareClick(source);
            return 'snapback'; // Return piece to original position
          }
          
          const turn = game.turn();
          const isPlayerTurn = (playerColor === "white" && turn === "w") || (playerColor === "black" && turn === "b");
          
          // Handle premove (during opponent's turn)
          if (!isPlayerTurn) {
            // Clear any existing premove highlights and restore actual position
            $("#board .square-55d63").removeClass("premove-highlight premove-source");
            if (premove) {
              // Restore the actual game position before making new premove
              board.position(game.fen());
            }
            
            // Store the premove
            premove = { from: source, to: target };
            
            // Get current board position and make the visual move
            const position = board.position();
            const piece = position[source];
            delete position[source];
            position[target] = piece;
            board.position(position);
            
            // Add highlights AFTER board redraws (board.position removes classes)
            setTimeout(() => {
              const sourceSquare = $(`#board .square-${source}`);
              const targetSquare = $(`#board .square-${target}`);
              sourceSquare.addClass("premove-source");
              targetSquare.addClass("premove-highlight");
            }, 0);
            
            // Don't snapback - piece stays at target
            return;
          }
          
          // Clear premove if player makes a manual move
          clearPremove();
          
          // Validate move synchronously first
          if (gameOver) {
            return 'snapback';
          }
          
          // Check if move is legal
          const move = game.move({ from: source, to: target, promotion: 'q' });
          if (!move) {
            return 'snapback';
          }
          
          // Move is legal - undo it and let handleMove process it properly
          game.undo();
          handleMove(source, target);
        },
        onSnapEnd: () => {
          // Clean up after drag/drop (clicks are handled in onDrop)
          $("#board .square-55d63").removeClass("legal-target");
          
          // Only remove highlights if not in click-to-move mode
          if (!selectedSquare) {
            removeHighlights();
          }
        },
        onClick: (square) => {
          const turn = game.turn();
          const isPlayerTurn = (playerColor === "white" && turn === "w") || (playerColor === "black" && turn === "b");
          const position = board.position();
          const piece = position[square];
          
          // If there's a selected piece
          if (selectedSquare) {
            // If clicking the same square, deselect
            if (selectedSquare === square) {
              selectedSquare = null;
              removeHighlights();
              return;
            }
            
            // Check if this is a legal move or premove
            if (!isPlayerTurn) {
              // Handle premove click
              if (!piece || (playerColor === "white" && piece.search(/^w/) !== -1) || 
                  (playerColor === "black" && piece.search(/^b/) !== -1)) {
                // Clicking empty square or own piece - try to premove
                const premoveFrom = selectedSquare;
                const premoveTo = square;
                
                // Clear highlights and selection
                selectedSquare = null;
                removeHighlights();
                
                // If clicking own piece, select it instead
                if (piece) {
                  selectedSquare = square;
                  highlightLegalMoves(square);
                } else {
                  // Make premove
                  $("#board .square-55d63").removeClass("premove-highlight premove-source");
                  if (premove) {
                    board.position(game.fen());
                  }
                  
                  premove = { from: premoveFrom, to: premoveTo };
                  
                  const pos = board.position();
                  const movingPiece = pos[premoveFrom];
                  delete pos[premoveFrom];
                  pos[premoveTo] = movingPiece;
                  board.position(pos);
                  
                  setTimeout(() => {
                    $(`#board .square-${premoveFrom}`).addClass("premove-source");
                    $(`#board .square-${premoveTo}`).addClass("premove-highlight");
                  }, 0);
                }
                return;
              }
            } else {
              // Try to make a normal move
              const move = game.move({ from: selectedSquare, to: square, promotion: 'q' });
              
              if (move) {
                // Legal move
                clearPremove();
                selectedSquare = null;
                removeHighlights();
                game.undo();
                handleMove(move.from, move.to);
                return;
              } else if (piece) {
                // Illegal move but clicked on own piece - change selection
                const pieceColor = piece.search(/^w/) !== -1 ? 'w' : 'b';
                if ((turn === 'w' && pieceColor === 'w') || (turn === 'b' && pieceColor === 'b')) {
                  selectedSquare = square;
                  removeHighlights();
                  highlightLegalMoves(square);
                  return;
                }
              }
              
              // Invalid move, deselect
              selectedSquare = null;
              removeHighlights();
              return;
            }
          }
          
          // No piece selected - select clicked piece if valid
          if (piece) {
            if (!isPlayerTurn) {
              // During opponent's turn, allow selecting own pieces for premove
              if ((playerColor === "white" && piece.search(/^w/) !== -1) || 
                  (playerColor === "black" && piece.search(/^b/) !== -1)) {
                selectedSquare = square;
                highlightLegalMoves(square);
              }
            } else {
              // During player's turn, select own pieces
              const pieceColor = piece.search(/^w/) !== -1 ? 'w' : 'b';
              if ((turn === 'w' && pieceColor === 'w') || (turn === 'b' && pieceColor === 'b')) {
                selectedSquare = square;
                highlightLegalMoves(square);
              }
            }
          }
        },
        pieceTheme: pieceThemes[currentPieceStyle],
      });

      // Add click-to-move functionality using mousedown/mouseup to avoid drag interference
      setTimeout(() => {
        let mouseDownSquare = null;
        
        $('#board').off('mousedown mouseup').on('mousedown', function(e) {
          // Only handle left click
          if (e.button !== 0) return;
          
          let $square = $(e.target);
          
          // If clicked on a piece image, get the parent square
          if ($square.hasClass('piece-417db') || $square.prop('tagName') === 'IMG') {
            $square = $square.parent();
          }
          
          // Make sure we have a square element
          if (!$square.hasClass('square-55d63')) {
            $square = $square.closest('.square-55d63');
          }
          
          if ($square.length === 0) return;
          
          const square = $square.data('square');
          if (square) {
            mouseDownSquare = square;
          }
        }).on('mouseup', function(e) {
          // Only handle left click
          if (e.button !== 0) return;
          
          if (!mouseDownSquare) return;
          
          let $square = $(e.target);
          
          // If released on a piece image, get the parent square
          if ($square.hasClass('piece-417db') || $square.prop('tagName') === 'IMG') {
            $square = $square.parent();
          }
          
          // Make sure we have a square element
          if (!$square.hasClass('square-55d63')) {
            $square = $square.closest('.square-55d63');
          }
          
          if ($square.length === 0) {
            mouseDownSquare = null;
            return;
          }
          
          const square = $square.data('square');
          
          // Only treat as click if mousedown and mouseup on same square
          if (square && square === mouseDownSquare) {
            console.log('Click detected on square:', square);
            handleSquareClick(square);
          }
          
          mouseDownSquare = null;
        });
      }, 100);

      // Click outside board to cancel premove
      $(document).on('click', function(e) {
        // Check if click was outside the board
        if (premove && !$(e.target).closest('#board').length) {
          console.log('Clicked outside board, canceling premove');
          clearPremove();
        }
      });

      // Prevent native HTML5 drag on piece images
      setTimeout(() => {
        $('#board img').on('dragstart', function(e) {
          e.preventDefault();
          return false;
        });
        // Also set draggable attribute to false
        $('#board img').attr('draggable', 'false');
        
        // Use MutationObserver to handle dynamically added images
        const observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            mutation.addedNodes.forEach(function(node) {
              if (node.tagName === 'IMG') {
                $(node).attr('draggable', 'false');
                $(node).on('dragstart', function(e) {
                  e.preventDefault();
                  return false;
                });
              }
              if (node.querySelectorAll) {
                $(node).find('img').attr('draggable', 'false');
                $(node).find('img').on('dragstart', function(e) {
                  e.preventDefault();
                  return false;
                });
              }
            });
          });
        });
        
        observer.observe(document.getElementById('board'), {
          childList: true,
          subtree: true
        });
      }, 200);
      
      // Add event delegation for dynamically added images
      $('#board').on('dragstart', 'img', function(e) {
        e.preventDefault();
        return false;
      });

      document.getElementById("move-timer-container").style.display = "block";
      document.getElementById("last-move-container").style.display = "block";
      document.getElementById("notation-container").style.display = "block";
      document.getElementById("notation-container").textContent = "";
      document.getElementById("game-stats-panel").style.display = "block";
      document.getElementById("export-pgn-btn").style.display = "block";
      document.getElementById("resign-btn").style.display = "block";
      document.getElementById("opening-display").style.display = "none";
      
      // Initialize stats
      updateGameStats();
      
      // Handle blindfold mode
      if (blindfoldMode) {
        document.getElementById("board").classList.add("blindfold-hidden");
        document.getElementById("timers-container").classList.add("blindfold-hidden");
        document.getElementById("move-input-container").style.display = "block";
        
        // Handle move history visibility in blindfold mode
        if (showHistoryInBlindfold) {
          document.getElementById("notation-container").classList.remove("blindfold-hidden");
        } else {
          document.getElementById("notation-container").classList.add("blindfold-hidden");
        }
      } else {
        document.getElementById("board").classList.remove("blindfold-hidden");
        document.getElementById("timers-container").classList.remove("blindfold-hidden");
        document.getElementById("notation-container").classList.remove("blindfold-hidden");
        document.getElementById("move-input-container").style.display = "none";
      }
      
      startTimer();
      
      // Initialize engine and apply modifiers before allowing moves
      await sendEngineCommand("start");
      await applyEngineModifiers(currentEngineStyle);
      
      if (playerColor === "black") {
        engineMove();
      }
    }

    async function handleMove(source, target) {
      console.log('handleMove called:', source, 'to', target);
      
      removeHighlights();
      const move = game.move({ from: source, to: target, promotion: "q" });
      if (!move) {
        console.log('Move was invalid in handleMove (should not happen)');
        return;
      }

      trackCapturedPiece(move);
      lastMoveSquares = { from: source, to: target };
      
      const prevTurn = game.turn() === "w" ? "b" : "w";
      const moveTimeMs = stopTimerAndUpdateTotal(prevTurn);
      updateLastMove(move.san, formatTime(moveTimeMs), game.turn() === "w" ? "black" : "white", game.history().length/2 + 0.5);
      board.position(game.fen());
      highlightLastMove(source, target);
      highlightCheck();
      updateTurnDisplay();
      updateOpeningDisplay();
      updateGameStats();

      if (game.in_checkmate()) {
        // Replaced alert() with UI message
        const moveContainer = document.getElementById("move-timer-container");
        moveContainer.innerHTML = 'CHECKMATE! <span style="color:#2ECC71;">You Win!</span>'; // Green text for win
        gameOver = true;
        return;
      }

      startTimer(); // Start move timer for engine
      await engineMove();
    }
    async function engineMove() {
      try {
        const lastMove = game.history().slice(-1)[0];
        const response = await fetch("https://hedgehoglover23.pythonanywhere.com/move", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            move: lastMove,
            color: game.turn() === "w" ? "black" : "white",
          }),
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        if (!data.move) {
          // Replaced alert() with UI message
          const moveContainer = document.getElementById("move-timer-container");
          moveContainer.innerHTML = 'ENGINE ERROR: <span style="color:red;">No move returned.</span>';
          return;
        }

        // Stop timer *before* making the move on the game object
        const moveTimeMs = stopTimerAndUpdateTotal(game.turn()); 
        const move = game.move(data.move);
        
        trackCapturedPiece(move);
        lastMoveSquares = { from: move.from, to: move.to };
        
        updateLastMove(data.move, formatTime(moveTimeMs), game.turn() === "w" ? "black" : "white", game.history().length/2 + 0.5);
        board.position(game.fen());
        highlightLastMove(move.from, move.to);
        highlightCheck();
        updateTurnDisplay();
        updateOpeningDisplay();
        updateGameStats();

        if (game.in_checkmate()) {
          // Replaced alert() with UI message
          const moveContainer = document.getElementById("move-timer-container");
          moveContainer.innerHTML = 'CHECKMATE! <span style="color:red;">You Lose!</span>';
          gameOver = true;
          clearPremove();
          return;
        }
        
        // Check if there's a premove and execute it if legal
        if (premove) {
          const premoveAttempt = game.move({ from: premove.from, to: premove.to, promotion: 'q' });
          if (premoveAttempt) {
            // Premove is legal - execute it
            clearPremove();
            const from = premoveAttempt.from;
            const to = premoveAttempt.to;
            
            trackCapturedPiece(premoveAttempt);
            lastMoveSquares = { from, to };
            
            const prevTurn = game.turn() === "w" ? "b" : "w";
            const premoveMoveTimeMs = 0; // Instant premove
            updateLastMove(premoveAttempt.san, "00:00.00", game.turn() === "w" ? "black" : "white", game.history().length/2 + 0.5);
            board.position(game.fen());
            highlightLastMove(from, to);
            highlightCheck();
            updateTurnDisplay();
            updateOpeningDisplay();
            updateGameStats();
            
            if (game.in_checkmate()) {
              const moveContainer = document.getElementById("move-timer-container");
              moveContainer.innerHTML = 'CHECKMATE! <span style="color:#2ECC71;">You Win!</span>';
              gameOver = true;
              return;
            }
            
            // Start timer and let engine move
            startTimer();
            await engineMove();
          } else {
            // Premove is no longer legal - clear it
            clearPremove();
          }
        }

        startTimer(); // Start move timer for player
      } catch (err) {
        // Replaced alert() with UI message
        const moveContainer = document.getElementById("move-timer-container");
        moveContainer.innerHTML = `CONNECTION ERROR: <span style="color:red;">${err.message || 'Could not reach engine.'}</span>`;
        console.error('Engine connection error:', err);
        gameOver = true;
      }
    }
    function submitMove() {
      if (gameOver) return;
      
      const moveInput = document.getElementById("move-input");
      const moveStr = moveInput.value.trim();
      
      if (!moveStr) {
        moveInput.style.borderColor = "red";
        setTimeout(() => { moveInput.style.borderColor = "#3498db"; }, 500);
        return;
      }
      
      removeHighlights();
      const move = game.move(moveStr, { sloppy: true });
      
      if (!move) {
        moveInput.style.borderColor = "red";
        setTimeout(() => { moveInput.style.borderColor = "#3498db"; }, 500);
        return;
      }
      
      moveInput.value = "";
      moveInput.style.borderColor = "#3498db";
      
      trackCapturedPiece(move);
      lastMoveSquares = { from: move.from, to: move.to };
      
      const prevTurn = game.turn() === "w" ? "b" : "w";
      const moveTimeMs = stopTimerAndUpdateTotal(prevTurn);
      updateLastMove(move.san, formatTime(moveTimeMs), game.turn() === "w" ? "black" : "white", game.history().length/2 + 0.5);
      
      if (!blindfoldMode) {
        board.position(game.fen());
        highlightLastMove(move.from, move.to);
        highlightCheck();
      }
      
      updateTurnDisplay();
      updateOpeningDisplay();
      updateGameStats();

      if (game.in_checkmate()) {
        const moveContainer = document.getElementById("move-timer-container");
        moveContainer.innerHTML = 'CHECKMATE! <span style="color:#2ECC71;">You Win!</span>';
        gameOver = true;
        return;
      }

      startTimer();
      engineMove();
    }  </script>
  <div class="push"></div>
    </div>
  <footer>
        <p>&copy; 2025 Ahrens Labs. All rights reserved.</p>
    </footer>
</body>
</html>